import {
  require_jsx_runtime
} from "./chunk-Q5NRD6C5.js";
import {
  require_react
} from "./chunk-EMPBR7P3.js";
import {
  __toESM
} from "./chunk-DNCPQDPH.js";

// node_modules/@shopify/hydrogen-react/dist/browser-dev/AddToCartButton.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react14 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/CartProvider.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/@xstate/fsm/es/index.mjs
function t(t2, n2) {
  var e2 = "function" == typeof Symbol && t2[Symbol.iterator];
  if (!e2) return t2;
  var r2, i2, o2 = e2.call(t2), a2 = [];
  try {
    for (; (void 0 === n2 || n2-- > 0) && !(r2 = o2.next()).done; ) a2.push(r2.value);
  } catch (t3) {
    i2 = { error: t3 };
  } finally {
    try {
      r2 && !r2.done && (e2 = o2.return) && e2.call(o2);
    } finally {
      if (i2) throw i2.error;
    }
  }
  return a2;
}
var n;
!function(t2) {
  t2[t2.NotStarted = 0] = "NotStarted", t2[t2.Running = 1] = "Running", t2[t2.Stopped = 2] = "Stopped";
}(n || (n = {}));
var e = { type: "xstate.init" };
function r(t2) {
  return void 0 === t2 ? [] : [].concat(t2);
}
function i(t2) {
  return { type: "xstate.assign", assignment: t2 };
}
function o(t2, n2) {
  return "string" == typeof (t2 = "string" == typeof t2 && n2 && n2[t2] ? n2[t2] : t2) ? { type: t2 } : "function" == typeof t2 ? { type: t2.name, exec: t2 } : t2;
}
function a(t2) {
  return function(n2) {
    return t2 === n2;
  };
}
function u(t2) {
  return "string" == typeof t2 ? { type: t2 } : t2;
}
function c(t2, n2) {
  return { value: t2, context: n2, actions: [], changed: false, matches: a(t2) };
}
function f(t2, n2, e2) {
  var r2 = n2, i2 = false;
  return [t2.filter(function(t3) {
    if ("xstate.assign" === t3.type) {
      i2 = true;
      var n3 = Object.assign({}, r2);
      return "function" == typeof t3.assignment ? n3 = t3.assignment(r2, e2) : Object.keys(t3.assignment).forEach(function(i3) {
        n3[i3] = "function" == typeof t3.assignment[i3] ? t3.assignment[i3](r2, e2) : t3.assignment[i3];
      }), r2 = n3, false;
    }
    return true;
  }), r2, i2];
}
function s(n2, i2) {
  void 0 === i2 && (i2 = {});
  var s2 = t(f(r(n2.states[n2.initial].entry).map(function(t2) {
    return o(t2, i2.actions);
  }), n2.context, e), 2), l22 = s2[0], v2 = s2[1], y = { config: n2, _options: i2, initialState: { value: n2.initial, actions: l22, context: v2, matches: a(n2.initial) }, transition: function(e2, i3) {
    var s3, l3, v3 = "string" == typeof e2 ? { value: e2, context: n2.context } : e2, p = v3.value, g2 = v3.context, d = u(i3), x = n2.states[p];
    if (x.on) {
      var m = r(x.on[d.type]);
      try {
        for (var h = function(t2) {
          var n3 = "function" == typeof Symbol && Symbol.iterator, e3 = n3 && t2[n3], r2 = 0;
          if (e3) return e3.call(t2);
          if (t2 && "number" == typeof t2.length) return { next: function() {
            return t2 && r2 >= t2.length && (t2 = void 0), { value: t2 && t2[r2++], done: !t2 };
          } };
          throw new TypeError(n3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }(m), b = h.next(); !b.done; b = h.next()) {
          var S = b.value;
          if (void 0 === S) return c(p, g2);
          var w = "string" == typeof S ? { target: S } : S, j = w.target, E = w.actions, R = void 0 === E ? [] : E, N = w.cond, O = void 0 === N ? function() {
            return true;
          } : N, _ = void 0 === j, k = null != j ? j : p, T = n2.states[k];
          if (O(g2, d)) {
            var q = t(f((_ ? r(R) : [].concat(x.exit, R, T.entry).filter(function(t2) {
              return t2;
            })).map(function(t2) {
              return o(t2, y._options.actions);
            }), g2, d), 3), z = q[0], A = q[1], B = q[2], C = null != j ? j : p;
            return { value: C, context: A, actions: z, changed: j !== p || z.length > 0 || B, matches: a(C) };
          }
        }
      } catch (t2) {
        s3 = { error: t2 };
      } finally {
        try {
          b && !b.done && (l3 = h.return) && l3.call(h);
        } finally {
          if (s3) throw s3.error;
        }
      }
    }
    return c(p, g2);
  } };
  return y;
}
var l = function(t2, n2) {
  return t2.actions.forEach(function(e2) {
    var r2 = e2.exec;
    return r2 && r2(t2.context, n2);
  });
};
function v(t2) {
  var r2 = t2.initialState, i2 = n.NotStarted, o2 = /* @__PURE__ */ new Set(), c2 = { _machine: t2, send: function(e2) {
    i2 === n.Running && (r2 = t2.transition(r2, e2), l(r2, u(e2)), o2.forEach(function(t3) {
      return t3(r2);
    }));
  }, subscribe: function(t3) {
    return o2.add(t3), t3(r2), { unsubscribe: function() {
      return o2.delete(t3);
    } };
  }, start: function(o3) {
    if (o3) {
      var u22 = "object" == typeof o3 ? o3 : { context: t2.config.context, value: o3 };
      r2 = { value: u22.value, actions: [], context: u22.context, matches: a(u22.value) };
    } else r2 = t2.initialState;
    return i2 = n.Running, l(r2, e), c2;
  }, stop: function() {
    return i2 = n.Stopped, o2.clear(), c2;
  }, get state() {
    return r2;
  }, get status() {
    return i2;
  } };
  return c2;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/@xstate/react/es/fsm.mjs
var import_react6 = __toESM(require_react(), 1);

// node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js
var import_react = __toESM(require_react());
var index = import_react.useLayoutEffect;
var use_isomorphic_layout_effect_browser_esm_default = index;

// node_modules/@shopify/hydrogen-react/dist/browser-dev/_virtual/with-selector2.mjs
var withSelector = { exports: {} };

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.mjs
var import_react4 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/_virtual/index.mjs
var shim = { exports: {} };

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.production.min.mjs
var import_react2 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/_virtual/use-sync-external-store-shim.development.mjs
var useSyncExternalStoreShim_development = {};

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.mjs
var import_react3 = __toESM(require_react(), 1);
var hasRequiredUseSyncExternalStoreShim_development;
function requireUseSyncExternalStoreShim_development() {
  if (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;
  hasRequiredUseSyncExternalStoreShim_development = 1;
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      }
      var React3 = import_react3.default;
      var ReactSharedInternals = React3.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is;
      var useState9 = React3.useState, useEffect11 = React3.useEffect, useLayoutEffect2 = React3.useLayoutEffect, useDebugValue = React3.useDebugValue;
      var didWarnOld18Alpha = false;
      var didWarnUncachedGetSnapshot = false;
      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        {
          if (!didWarnOld18Alpha) {
            if (React3.startTransition !== void 0) {
              didWarnOld18Alpha = true;
              error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
            }
          }
        }
        var value = getSnapshot();
        {
          if (!didWarnUncachedGetSnapshot) {
            var cachedValue = getSnapshot();
            if (!objectIs(value, cachedValue)) {
              error("The result of getSnapshot should be cached to avoid an infinite loop");
              didWarnUncachedGetSnapshot = true;
            }
          }
        }
        var _useState = useState9({
          inst: {
            value,
            getSnapshot
          }
        }), inst = _useState[0].inst, forceUpdate = _useState[1];
        useLayoutEffect2(function() {
          inst.value = value;
          inst.getSnapshot = getSnapshot;
          if (checkIfSnapshotChanged(inst)) {
            forceUpdate({
              inst
            });
          }
        }, [subscribe, value, getSnapshot]);
        useEffect11(function() {
          if (checkIfSnapshotChanged(inst)) {
            forceUpdate({
              inst
            });
          }
          var handleStoreChange = function() {
            if (checkIfSnapshotChanged(inst)) {
              forceUpdate({
                inst
              });
            }
          };
          return subscribe(handleStoreChange);
        }, [subscribe]);
        useDebugValue(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        var prevValue = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(prevValue, nextValue);
        } catch (error2) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
        return getSnapshot();
      }
      var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
      var isServerEnvironment = !canUseDOM;
      var shim2 = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
      var useSyncExternalStore$2 = React3.useSyncExternalStore !== void 0 ? React3.useSyncExternalStore : shim2;
      useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
      }
    })();
  }
  return useSyncExternalStoreShim_development;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/use-sync-external-store/shim/index.mjs
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim) return shim.exports;
  hasRequiredShim = 1;
  if (false) {
    shim.exports = requireUseSyncExternalStoreShim_production_min();
  } else {
    shim.exports = requireUseSyncExternalStoreShim_development();
  }
  return shim.exports;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/_virtual/with-selector.development.mjs
var withSelector_development = {};

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.mjs
var import_react5 = __toESM(require_react(), 1);
var hasRequiredWithSelector_development;
function requireWithSelector_development() {
  if (hasRequiredWithSelector_development) return withSelector_development;
  hasRequiredWithSelector_development = 1;
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      }
      var React3 = import_react5.default;
      var shim2 = requireShim();
      function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is;
      var useSyncExternalStore = shim2.useSyncExternalStore;
      var useRef4 = React3.useRef, useEffect11 = React3.useEffect, useMemo9 = React3.useMemo, useDebugValue = React3.useDebugValue;
      function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual2) {
        var instRef = useRef4(null);
        var inst;
        if (instRef.current === null) {
          inst = {
            hasValue: false,
            value: null
          };
          instRef.current = inst;
        } else {
          inst = instRef.current;
        }
        var _useMemo = useMemo9(function() {
          var hasMemo = false;
          var memoizedSnapshot;
          var memoizedSelection;
          var memoizedSelector = function(nextSnapshot) {
            if (!hasMemo) {
              hasMemo = true;
              memoizedSnapshot = nextSnapshot;
              var _nextSelection = selector(nextSnapshot);
              if (isEqual2 !== void 0) {
                if (inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual2(currentSelection, _nextSelection)) {
                    memoizedSelection = currentSelection;
                    return currentSelection;
                  }
                }
              }
              memoizedSelection = _nextSelection;
              return _nextSelection;
            }
            var prevSnapshot = memoizedSnapshot;
            var prevSelection = memoizedSelection;
            if (objectIs(prevSnapshot, nextSnapshot)) {
              return prevSelection;
            }
            var nextSelection = selector(nextSnapshot);
            if (isEqual2 !== void 0 && isEqual2(prevSelection, nextSelection)) {
              return prevSelection;
            }
            memoizedSnapshot = nextSnapshot;
            memoizedSelection = nextSelection;
            return nextSelection;
          };
          var maybeGetServerSnapshot = getServerSnapshot === void 0 ? null : getServerSnapshot;
          var getSnapshotWithSelector = function() {
            return memoizedSelector(getSnapshot());
          };
          var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? void 0 : function() {
            return memoizedSelector(maybeGetServerSnapshot());
          };
          return [getSnapshotWithSelector, getServerSnapshotWithSelector];
        }, [getSnapshot, getServerSnapshot, selector, isEqual2]), getSelection = _useMemo[0], getServerSelection = _useMemo[1];
        var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
        useEffect11(function() {
          inst.hasValue = true;
          inst.value = value;
        }, [value]);
        useDebugValue(value);
        return value;
      }
      withSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
      }
    })();
  }
  return withSelector_development;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/use-sync-external-store/shim/with-selector.mjs
var hasRequiredWithSelector;
function requireWithSelector() {
  if (hasRequiredWithSelector) return withSelector.exports;
  hasRequiredWithSelector = 1;
  if (false) {
    withSelector.exports = requireWithSelector_production_min();
  } else {
    withSelector.exports = requireWithSelector_development();
  }
  return withSelector.exports;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/_virtual/with-selector.mjs
var withSelectorExports = requireWithSelector();

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/@xstate/react/es/useConstant.mjs
var React = __toESM(require_react(), 1);
function useConstant(fn) {
  var ref = React.useRef();
  if (!ref.current) {
    ref.current = { v: fn() };
  }
  return ref.current.v;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/node_modules/@xstate/react/es/fsm.mjs
var __read = function(o2, n2) {
  var m = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m) return o2;
  var i2 = m.call(o2), r2, ar = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m = i2["return"])) m.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar;
};
function identity(a2) {
  return a2;
}
var getServiceState = function(service) {
  var currentValue;
  service.subscribe(function(state) {
    currentValue = state;
  }).unsubscribe();
  return currentValue;
};
function useMachine(stateMachine, options) {
  var persistedStateRef = (0, import_react6.useRef)();
  if (true) {
    var _a = __read((0, import_react6.useState)(stateMachine), 1), initialMachine = _a[0];
    if (stateMachine !== initialMachine) {
      console.warn("Machine given to `useMachine` has changed between renders. This is not supported and might lead to unexpected results.\nPlease make sure that you pass the same Machine as argument each time.");
    }
  }
  var _b = __read(useConstant(function() {
    var queue2 = [];
    var service2 = v(s(stateMachine.config, options ? options : stateMachine._options));
    var send = service2.send;
    service2.send = function(event) {
      if (service2.status === n.NotStarted) {
        queue2.push(event);
        return;
      }
      send(event);
      persistedStateRef.current = service2.state;
    };
    return [service2, queue2];
  }), 2), service = _b[0], queue = _b[1];
  use_isomorphic_layout_effect_browser_esm_default(function() {
    if (options) {
      service._machine._options = options;
    }
  });
  var useServiceResult = useService(service);
  (0, import_react6.useEffect)(function() {
    service.start(persistedStateRef.current);
    queue.forEach(service.send);
    persistedStateRef.current = service.state;
    return function() {
      service.stop();
    };
  }, []);
  return useServiceResult;
}
var isEqual = function(_prevState, nextState) {
  return nextState.changed === false;
};
function useService(service) {
  var getSnapshot = (0, import_react6.useCallback)(function() {
    return getServiceState(service);
  }, [service]);
  var subscribe = (0, import_react6.useCallback)(function(handleStoreChange) {
    var unsubscribe = service.subscribe(handleStoreChange).unsubscribe;
    return unsubscribe;
  }, [service]);
  var storeSnapshot = withSelectorExports.useSyncExternalStoreWithSelector(subscribe, getSnapshot, getSnapshot, identity, isEqual);
  return [storeSnapshot, service.send, service];
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/flatten-connection.mjs
function flattenConnection(connection) {
  if (!connection) {
    const noConnectionErr = `flattenConnection(): needs a 'connection' to flatten, but received '${connection ?? ""}' instead.`;
    {
      throw new Error(noConnectionErr);
    }
  }
  if ("nodes" in connection) {
    return connection.nodes;
  }
  if ("edges" in connection && Array.isArray(connection.edges)) {
    return connection.edges.map((edge) => {
      if (!(edge == null ? void 0 : edge.node)) {
        throw new Error(
          "flattenConnection(): Connection edges must contain nodes"
        );
      }
      return edge.node;
    });
  }
  {
    console.warn(
      `flattenConnection(): The connection did not contain either "nodes" or "edges.node". Returning an empty array.`
    );
  }
  return [];
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/useCartActions.mjs
var import_react9 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/cart-queries.mjs
var CartLineAdd = (cartFragment) => (
  /* GraphQL */
  `
  mutation CartLineAdd(
    $cartId: ID!
    $lines: [CartLineInput!]!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartLinesAdd(cartId: $cartId, lines: $lines) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
);
var CartCreate = (cartFragment) => (
  /* GraphQL */
  `
  mutation CartCreate(
    $input: CartInput!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartCreate(input: $input) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
);
var CartLineRemove = (cartFragment) => (
  /* GraphQL */
  `
  mutation CartLineRemove(
    $cartId: ID!
    $lines: [ID!]!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartLinesRemove(cartId: $cartId, lineIds: $lines) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
);
var CartLineUpdate = (cartFragment) => (
  /* GraphQL */
  `
  mutation CartLineUpdate(
    $cartId: ID!
    $lines: [CartLineUpdateInput!]!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartLinesUpdate(cartId: $cartId, lines: $lines) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
);
var CartNoteUpdate = (cartFragment) => (
  /* GraphQL */
  `
  mutation CartNoteUpdate(
    $cartId: ID!
    $note: String!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartNoteUpdate(cartId: $cartId, note: $note) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
);
var CartBuyerIdentityUpdate = (cartFragment) => (
  /* GraphQL */
  `
  mutation CartBuyerIdentityUpdate(
    $cartId: ID!
    $buyerIdentity: CartBuyerIdentityInput!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartBuyerIdentityUpdate(cartId: $cartId, buyerIdentity: $buyerIdentity) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
);
var CartAttributesUpdate = (cartFragment) => (
  /* GraphQL */
  `
  mutation CartAttributesUpdate(
    $attributes: [AttributeInput!]!
    $cartId: ID!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartAttributesUpdate(attributes: $attributes, cartId: $cartId) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
);
var CartDiscountCodesUpdate = (cartFragment) => (
  /* GraphQL */
  `
  mutation CartDiscountCodesUpdate(
    $cartId: ID!
    $discountCodes: [String!]
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cartDiscountCodesUpdate(cartId: $cartId, discountCodes: $discountCodes) {
      cart {
        ...CartFragment
      }
    }
  }

  ${cartFragment}
`
);
var CartQuery = (cartFragment) => (
  /* GraphQL */
  `
  query CartQuery(
    $id: ID!
    $numCartLines: Int = 250
    $country: CountryCode = ZZ
    $language: LanguageCode
  ) @inContext(country: $country, language: $language) {
    cart(id: $id) {
      ...CartFragment
    }
  }

  ${cartFragment}
`
);
var defaultCartFragment = (
  /* GraphQL */
  `
  fragment CartFragment on Cart {
    id
    checkoutUrl
    totalQuantity
    buyerIdentity {
      countryCode
      customer {
        id
        email
        firstName
        lastName
        displayName
      }
      email
      phone
    }
    lines(first: $numCartLines) {
      edges {
        node {
          id
          quantity
          attributes {
            key
            value
          }
          cost {
            totalAmount {
              amount
              currencyCode
            }
            compareAtAmountPerQuantity {
              amount
              currencyCode
            }
          }
          merchandise {
            ... on ProductVariant {
              id
              availableForSale
              compareAtPrice {
                ...MoneyFragment
              }
              price {
                ...MoneyFragment
              }
              requiresShipping
              title
              image {
                ...ImageFragment
              }
              product {
                handle
                title
                id
              }
              selectedOptions {
                name
                value
              }
            }
          }
        }
      }
    }
    cost {
      subtotalAmount {
        ...MoneyFragment
      }
      totalAmount {
        ...MoneyFragment
      }
      totalDutyAmount {
        ...MoneyFragment
      }
      totalTaxAmount {
        ...MoneyFragment
      }
    }
    note
    attributes {
      key
      value
    }
    discountCodes {
      code
      applicable
    }
  }

  fragment MoneyFragment on MoneyV2 {
    currencyCode
    amount
  }
  fragment ImageFragment on Image {
    id
    url
    altText
    width
    height
  }
`
);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/cart-hooks.mjs
var import_react8 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/ShopifyProvider.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/storefront-api-constants.mjs
var SFAPI_VERSION = "2025-07";

// node_modules/@shopify/hydrogen-react/dist/browser-dev/storefront-client.mjs
var MOCK_SHOP_DOMAIN = "mock.shop";
var isMockShop = (domain) => domain.includes(MOCK_SHOP_DOMAIN);
function createStorefrontClient({
  storeDomain,
  privateStorefrontToken,
  publicStorefrontToken,
  storefrontApiVersion = SFAPI_VERSION,
  contentType
}) {
  if (!storeDomain) {
    {
      storeDomain = MOCK_SHOP_DOMAIN;
      warnOnce(
        `storeDomain missing, defaulting to ${MOCK_SHOP_DOMAIN}`,
        "info"
      );
    }
  }
  if (storefrontApiVersion !== SFAPI_VERSION) {
    warnOnce(
      `The Storefront API version that you're using is different than the version this build of Hydrogen React is targeting.
You may run into unexpected errors if these versions don't match. Received version: "${storefrontApiVersion}"; expected version "${SFAPI_VERSION}"`
    );
  }
  if (!privateStorefrontToken && !globalThis.document && !isMockShop(storeDomain)) {
    warnOnce(
      `Using a private storefront token is recommended for server environments.
Refer to the authentication https://shopify.dev/api/storefront#authentication documentation for more details.`
    );
  }
  if (privateStorefrontToken && globalThis.document) {
    warnOnce(
      "You are attempting to use a private token in an environment where it can be easily accessed by anyone.\nThis is a security risk; please use the public token and the `publicStorefrontToken` prop"
    );
  }
  const getShopifyDomain = (overrideProps) => {
    const domain = (overrideProps == null ? void 0 : overrideProps.storeDomain) ?? storeDomain;
    return domain.includes("://") ? domain : `https://${domain}`;
  };
  return {
    getShopifyDomain,
    getStorefrontApiUrl(overrideProps) {
      const domain = getShopifyDomain(overrideProps);
      const apiUrl = domain + (domain.endsWith("/") ? "api" : "/api");
      if (isMockShop(domain)) return apiUrl;
      return `${apiUrl}/${(overrideProps == null ? void 0 : overrideProps.storefrontApiVersion) ?? storefrontApiVersion}/graphql.json`;
    },
    getPrivateTokenHeaders(overrideProps) {
      if (!privateStorefrontToken && !(overrideProps == null ? void 0 : overrideProps.privateStorefrontToken) && !isMockShop(storeDomain)) {
        throw new Error(
          H2_PREFIX_ERROR + "You did not pass in a `privateStorefrontToken` while using `createStorefrontClient()` or `getPrivateTokenHeaders()`"
        );
      }
      if (!(overrideProps == null ? void 0 : overrideProps.buyerIp)) {
        warnOnce(
          "It is recommended to pass in the `buyerIp` property which improves analytics and data in the admin."
        );
      }
      const finalContentType = (overrideProps == null ? void 0 : overrideProps.contentType) ?? contentType;
      return {
        // default to json
        "content-type": finalContentType === "graphql" ? "application/graphql" : "application/json",
        "X-SDK-Variant": "hydrogen-react",
        "X-SDK-Variant-Source": "react",
        "X-SDK-Version": storefrontApiVersion,
        "Shopify-Storefront-Private-Token": (overrideProps == null ? void 0 : overrideProps.privateStorefrontToken) ?? privateStorefrontToken ?? "",
        ...(overrideProps == null ? void 0 : overrideProps.buyerIp) ? { "Shopify-Storefront-Buyer-IP": overrideProps.buyerIp } : {}
      };
    },
    getPublicTokenHeaders(overrideProps) {
      if (!publicStorefrontToken && !(overrideProps == null ? void 0 : overrideProps.publicStorefrontToken) && !isMockShop(storeDomain)) {
        throw new Error(
          H2_PREFIX_ERROR + "You did not pass in a `publicStorefrontToken` while using `createStorefrontClient()` or `getPublicTokenHeaders()`"
        );
      }
      const finalContentType = (overrideProps == null ? void 0 : overrideProps.contentType) ?? contentType ?? "json";
      return getPublicTokenHeadersRaw(
        finalContentType,
        storefrontApiVersion,
        (overrideProps == null ? void 0 : overrideProps.publicStorefrontToken) ?? publicStorefrontToken ?? ""
      );
    }
  };
}
function getPublicTokenHeadersRaw(contentType, storefrontApiVersion, accessToken) {
  return {
    // default to json
    "content-type": contentType === "graphql" ? "application/graphql" : "application/json",
    "X-SDK-Variant": "hydrogen-react",
    "X-SDK-Variant-Source": "react",
    "X-SDK-Version": storefrontApiVersion,
    "X-Shopify-Storefront-Access-Token": accessToken
  };
}
var warnings = /* @__PURE__ */ new Set();
var H2_PREFIX_ERROR = "[h2:error:createStorefrontClient] ";
var warnOnce = (string, type = "warn") => {
  if (!warnings.has(string)) {
    console[type](`[h2:${type}:createStorefrontClient] ` + string);
    warnings.add(string);
  }
};

// node_modules/@shopify/hydrogen-react/dist/browser-dev/ShopifyProvider.mjs
var defaultShopifyContext = {
  storeDomain: "test",
  storefrontToken: "abc123",
  storefrontApiVersion: SFAPI_VERSION,
  countryIsoCode: "US",
  languageIsoCode: "EN",
  getStorefrontApiUrl() {
    return "";
  },
  getPublicTokenHeaders() {
    return {};
  },
  getShopifyDomain() {
    return "";
  }
};
var ShopifyContext = (0, import_react7.createContext)(
  defaultShopifyContext
);
function ShopifyProvider({
  children,
  ...shopifyConfig
}) {
  if (!shopifyConfig.countryIsoCode || !shopifyConfig.languageIsoCode || !shopifyConfig.storeDomain || !shopifyConfig.storefrontToken || !shopifyConfig.storefrontApiVersion) {
    throw new Error(
      `Please provide the necessary props to '<ShopifyProvider/>'`
    );
  }
  if (shopifyConfig.storefrontApiVersion !== SFAPI_VERSION) {
    console.warn(
      `<ShopifyProvider/>: This version of Hydrogen React is built for Shopify's Storefront API version ${SFAPI_VERSION}, but it looks like you're using version ${shopifyConfig.storefrontApiVersion}. There may be issues or bugs if you use a mismatched version of Hydrogen React and the Storefront API.`
    );
  }
  const finalConfig = (0, import_react7.useMemo)(() => {
    function getShopifyDomain(overrideProps) {
      const domain = (overrideProps == null ? void 0 : overrideProps.storeDomain) ?? shopifyConfig.storeDomain;
      return domain.includes("://") ? domain : `https://${domain}`;
    }
    return {
      ...shopifyConfig,
      getPublicTokenHeaders(overrideProps) {
        return getPublicTokenHeadersRaw(
          overrideProps.contentType,
          shopifyConfig.storefrontApiVersion,
          overrideProps.storefrontToken ?? shopifyConfig.storefrontToken
        );
      },
      getShopifyDomain,
      getStorefrontApiUrl(overrideProps) {
        const finalDomainUrl = getShopifyDomain({
          storeDomain: (overrideProps == null ? void 0 : overrideProps.storeDomain) ?? shopifyConfig.storeDomain
        });
        return `${finalDomainUrl}${finalDomainUrl.endsWith("/") ? "" : "/"}api/${(overrideProps == null ? void 0 : overrideProps.storefrontApiVersion) ?? shopifyConfig.storefrontApiVersion}/graphql.json`;
      }
    };
  }, [shopifyConfig]);
  return (0, import_jsx_runtime.jsx)(ShopifyContext.Provider, { value: finalConfig, children });
}
function useShop() {
  const shopContext = (0, import_react7.useContext)(ShopifyContext);
  if (!shopContext) {
    throw new Error(`'useShop()' must be a descendent of <ShopifyProvider/>`);
  }
  return shopContext;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/cart-constants.mjs
var CART_ID_STORAGE_KEY = "shopifyCartId";
var SHOPIFY_STOREFRONT_ID_HEADER = "Shopify-Storefront-Id";
var SHOPIFY_STOREFRONT_Y_HEADER = "Shopify-Storefront-Y";
var SHOPIFY_STOREFRONT_S_HEADER = "Shopify-Storefront-S";
var SHOPIFY_Y = "_shopify_y";
var SHOPIFY_S = "_shopify_s";

// node_modules/worktop/cookie/index.mjs
var g = /* @__PURE__ */ new Set([
  "domain",
  "path",
  "max-age",
  "expires",
  "samesite",
  "secure",
  "httponly"
]);
function u2(a2) {
  let r2 = {}, e2, t2, n2 = 0, m = a2.split(/;\s*/g), s2, i2;
  for (; n2 < m.length; n2++)
    if (t2 = m[n2], e2 = t2.indexOf("="), ~e2) {
      if (s2 = t2.substring(0, e2++).trim(), i2 = t2.substring(e2).trim(), i2[0] === '"' && (i2 = i2.substring(1, i2.length - 1)), ~i2.indexOf("%"))
        try {
          i2 = decodeURIComponent(i2);
        } catch (f2) {
        }
      g.has(t2 = s2.toLowerCase()) ? t2 === "expires" ? r2.expires = new Date(i2) : t2 === "max-age" ? r2.maxage = +i2 : r2[t2] = i2 : r2[s2] = i2;
    } else
      (s2 = t2.trim().toLowerCase()) && (s2 === "httponly" || s2 === "secure") && (r2[s2] = true);
  return r2;
}
function l2(a2, r2, e2 = {}) {
  let t2 = a2 + "=" + encodeURIComponent(r2);
  return e2.expires && (t2 += "; Expires=" + new Date(e2.expires).toUTCString()), e2.maxage != null && e2.maxage >= 0 && (t2 += "; Max-Age=" + (e2.maxage | 0)), e2.domain && (t2 += "; Domain=" + e2.domain), e2.path && (t2 += "; Path=" + e2.path), e2.samesite && (t2 += "; SameSite=" + e2.samesite), (e2.secure || e2.samesite === "None") && (t2 += "; Secure"), e2.httponly && (t2 += "; HttpOnly"), t2;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/cookies-utils.mjs
var tokenHash = "xxxx-4xxx-xxxx-xxxxxxxxxxxx";
function buildUUID() {
  let hash = "";
  try {
    const crypto = window.crypto;
    const randomValuesArray = new Uint16Array(31);
    crypto.getRandomValues(randomValuesArray);
    let i2 = 0;
    hash = tokenHash.replace(/[x]/g, (c2) => {
      const r2 = randomValuesArray[i2] % 16;
      const v2 = c2 === "x" ? r2 : r2 & 3 | 8;
      i2++;
      return v2.toString(16);
    }).toUpperCase();
  } catch (err) {
    hash = tokenHash.replace(/[x]/g, (c2) => {
      const r2 = Math.random() * 16 | 0;
      const v2 = c2 === "x" ? r2 : r2 & 3 | 8;
      return v2.toString(16);
    }).toUpperCase();
  }
  return `${hexTime()}-${hash}`;
}
function hexTime() {
  let dateNumber = 0;
  let perfNumber = 0;
  dateNumber = (/* @__PURE__ */ new Date()).getTime() >>> 0;
  try {
    perfNumber = performance.now() >>> 0;
  } catch (err) {
    perfNumber = 0;
  }
  const output = Math.abs(dateNumber + perfNumber).toString(16).toLowerCase();
  return output.padStart(8, "0");
}
function getShopifyCookies(cookies) {
  const cookieData = u2(cookies);
  return {
    [SHOPIFY_Y]: cookieData[SHOPIFY_Y] || "",
    [SHOPIFY_S]: cookieData[SHOPIFY_S] || ""
  };
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/cart-hooks.mjs
function useCartFetch() {
  const { storefrontId, getPublicTokenHeaders, getStorefrontApiUrl } = useShop();
  return (0, import_react8.useCallback)(
    ({
      query,
      variables
    }) => {
      const headers = getPublicTokenHeaders({ contentType: "json" });
      if (storefrontId) {
        headers[SHOPIFY_STOREFRONT_ID_HEADER] = storefrontId;
      }
      const cookieData = getShopifyCookies(document.cookie);
      headers[SHOPIFY_STOREFRONT_Y_HEADER] = cookieData[SHOPIFY_Y];
      headers[SHOPIFY_STOREFRONT_S_HEADER] = cookieData[SHOPIFY_S];
      return fetch(getStorefrontApiUrl(), {
        method: "POST",
        headers,
        body: JSON.stringify({
          query: query.toString(),
          variables
        })
      }).then(
        (res) => res.json()
      ).catch((error) => {
        return {
          data: void 0,
          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
          errors: error == null ? void 0 : error.toString()
        };
      });
    },
    [getPublicTokenHeaders, storefrontId, getStorefrontApiUrl]
  );
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/useCartActions.mjs
function useCartActions({
  numCartLines,
  cartFragment,
  countryCode = "US",
  languageCode = "EN"
}) {
  const fetchCart = useCartFetch();
  const cartFetch = (0, import_react9.useCallback)(
    (cartId) => {
      return fetchCart({
        query: CartQuery(cartFragment),
        variables: {
          id: cartId,
          numCartLines,
          country: countryCode,
          language: languageCode
        }
      });
    },
    [fetchCart, cartFragment, numCartLines, countryCode, languageCode]
  );
  const cartCreate = (0, import_react9.useCallback)(
    (cart) => {
      return fetchCart({
        query: CartCreate(cartFragment),
        variables: {
          input: cart,
          numCartLines,
          country: countryCode,
          language: languageCode
        }
      });
    },
    [cartFragment, countryCode, fetchCart, numCartLines, languageCode]
  );
  const cartLineAdd = (0, import_react9.useCallback)(
    (cartId, lines) => {
      return fetchCart({
        query: CartLineAdd(cartFragment),
        variables: {
          cartId,
          lines,
          numCartLines,
          country: countryCode,
          language: languageCode
        }
      });
    },
    [cartFragment, countryCode, fetchCart, numCartLines, languageCode]
  );
  const cartLineUpdate = (0, import_react9.useCallback)(
    (cartId, lines) => {
      return fetchCart({
        query: CartLineUpdate(cartFragment),
        variables: {
          cartId,
          lines,
          numCartLines,
          country: countryCode,
          language: languageCode
        }
      });
    },
    [cartFragment, countryCode, fetchCart, numCartLines, languageCode]
  );
  const cartLineRemove = (0, import_react9.useCallback)(
    (cartId, lines) => {
      return fetchCart({
        query: CartLineRemove(cartFragment),
        variables: {
          cartId,
          lines,
          numCartLines,
          country: countryCode,
          language: languageCode
        }
      });
    },
    [cartFragment, countryCode, fetchCart, numCartLines, languageCode]
  );
  const noteUpdate = (0, import_react9.useCallback)(
    (cartId, note) => {
      return fetchCart({
        query: CartNoteUpdate(cartFragment),
        variables: {
          cartId,
          note,
          numCartLines,
          country: countryCode,
          language: languageCode
        }
      });
    },
    [fetchCart, cartFragment, numCartLines, countryCode, languageCode]
  );
  const buyerIdentityUpdate = (0, import_react9.useCallback)(
    (cartId, buyerIdentity) => {
      return fetchCart({
        query: CartBuyerIdentityUpdate(cartFragment),
        variables: {
          cartId,
          buyerIdentity,
          numCartLines,
          country: countryCode,
          language: languageCode
        }
      });
    },
    [cartFragment, countryCode, fetchCart, numCartLines, languageCode]
  );
  const cartAttributesUpdate = (0, import_react9.useCallback)(
    (cartId, attributes) => {
      return fetchCart({
        query: CartAttributesUpdate(cartFragment),
        variables: {
          cartId,
          attributes,
          numCartLines,
          country: countryCode,
          language: languageCode
        }
      });
    },
    [cartFragment, countryCode, fetchCart, numCartLines, languageCode]
  );
  const discountCodesUpdate = (0, import_react9.useCallback)(
    (cartId, discountCodes) => {
      return fetchCart({
        query: CartDiscountCodesUpdate(cartFragment),
        variables: {
          cartId,
          discountCodes,
          numCartLines,
          country: countryCode,
          language: languageCode
        }
      });
    },
    [cartFragment, countryCode, fetchCart, numCartLines, languageCode]
  );
  return (0, import_react9.useMemo)(
    () => ({
      cartFetch,
      cartCreate,
      cartLineAdd,
      cartLineUpdate,
      cartLineRemove,
      noteUpdate,
      buyerIdentityUpdate,
      cartAttributesUpdate,
      discountCodesUpdate,
      cartFragment
    }),
    [
      cartFetch,
      cartCreate,
      cartLineAdd,
      cartLineUpdate,
      cartLineRemove,
      noteUpdate,
      buyerIdentityUpdate,
      cartAttributesUpdate,
      discountCodesUpdate,
      cartFragment
    ]
  );
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/useCartAPIStateMachine.mjs
var import_react10 = __toESM(require_react(), 1);
function invokeCart(action, options) {
  return {
    entry: [
      ...(options == null ? void 0 : options.entryActions) || [],
      i({
        lastValidCart: (context) => context == null ? void 0 : context.cart
      }),
      "onCartActionEntry",
      "onCartActionOptimisticUI",
      action
    ],
    on: {
      RESOLVE: {
        target: (options == null ? void 0 : options.resolveTarget) || "idle",
        actions: [
          i({
            prevCart: (context) => context == null ? void 0 : context.lastValidCart,
            cart: (_, event) => {
              var _a;
              return (_a = event == null ? void 0 : event.payload) == null ? void 0 : _a.cart;
            },
            rawCartResult: (_, event) => {
              var _a;
              return (_a = event == null ? void 0 : event.payload) == null ? void 0 : _a.rawCartResult;
            },
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            errors: (_) => void 0
          })
        ]
      },
      ERROR: {
        target: (options == null ? void 0 : options.errorTarget) || "error",
        actions: [
          i({
            prevCart: (context) => context == null ? void 0 : context.lastValidCart,
            cart: (context) => context == null ? void 0 : context.lastValidCart,
            errors: (_, event) => {
              var _a;
              return (_a = event == null ? void 0 : event.payload) == null ? void 0 : _a.errors;
            }
          })
        ]
      },
      CART_COMPLETED: {
        target: "cartCompleted",
        actions: i({
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          prevCart: (_) => void 0,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          cart: (_) => void 0,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          lastValidCart: (_) => void 0,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          rawCartResult: (_) => void 0,
          // eslint-disable-next-line @typescript-eslint/no-unused-vars
          errors: (_) => void 0
        })
      }
    },
    exit: ["onCartActionComplete", ...(options == null ? void 0 : options.exitActions) || []]
  };
}
var INITIALIZING_CART_EVENTS = {
  CART_FETCH: {
    target: "cartFetching"
  },
  CART_CREATE: {
    target: "cartCreating"
  },
  CART_SET: {
    target: "idle",
    actions: [
      i({
        rawCartResult: (_, event) => event.payload.cart,
        cart: (_, event) => cartFromGraphQL(event.payload.cart)
      })
    ]
  }
};
var UPDATING_CART_EVENTS = {
  CARTLINE_ADD: {
    target: "cartLineAdding"
  },
  CARTLINE_UPDATE: {
    target: "cartLineUpdating"
  },
  CARTLINE_REMOVE: {
    target: "cartLineRemoving"
  },
  NOTE_UPDATE: {
    target: "noteUpdating"
  },
  BUYER_IDENTITY_UPDATE: {
    target: "buyerIdentityUpdating"
  },
  CART_ATTRIBUTES_UPDATE: {
    target: "cartAttributesUpdating"
  },
  DISCOUNT_CODES_UPDATE: {
    target: "discountCodesUpdating"
  }
};
function createCartMachine(initialCart) {
  return s({
    id: "Cart",
    initial: initialCart ? "idle" : "uninitialized",
    context: {
      cart: initialCart && cartFromGraphQL(initialCart)
    },
    states: {
      uninitialized: {
        on: INITIALIZING_CART_EVENTS
      },
      cartCompleted: {
        on: INITIALIZING_CART_EVENTS
      },
      initializationError: {
        on: INITIALIZING_CART_EVENTS
      },
      idle: {
        on: { ...INITIALIZING_CART_EVENTS, ...UPDATING_CART_EVENTS }
      },
      error: {
        on: { ...INITIALIZING_CART_EVENTS, ...UPDATING_CART_EVENTS }
      },
      cartFetching: invokeCart("cartFetchAction", {
        errorTarget: "initializationError"
      }),
      cartCreating: invokeCart("cartCreateAction", {
        errorTarget: "initializationError"
      }),
      cartLineRemoving: invokeCart("cartLineRemoveAction"),
      cartLineUpdating: invokeCart("cartLineUpdateAction"),
      cartLineAdding: invokeCart("cartLineAddAction"),
      noteUpdating: invokeCart("noteUpdateAction"),
      buyerIdentityUpdating: invokeCart("buyerIdentityUpdateAction"),
      cartAttributesUpdating: invokeCart("cartAttributesUpdateAction"),
      discountCodesUpdating: invokeCart("discountCodesUpdateAction")
    }
  });
}
function useCartAPIStateMachine({
  numCartLines,
  onCartActionEntry,
  onCartActionOptimisticUI,
  onCartActionComplete,
  data: cart,
  cartFragment,
  countryCode,
  languageCode
}) {
  const {
    cartFetch,
    cartCreate,
    cartLineAdd,
    cartLineUpdate,
    cartLineRemove,
    noteUpdate,
    buyerIdentityUpdate,
    cartAttributesUpdate,
    discountCodesUpdate
  } = useCartActions({
    numCartLines,
    cartFragment,
    countryCode,
    languageCode
  });
  const cartMachine = (0, import_react10.useMemo)(() => createCartMachine(cart), [cart]);
  const [state, send, service] = useMachine(cartMachine, {
    actions: {
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      cartFetchAction: async (_, event) => {
        var _a;
        if (event.type !== "CART_FETCH") return;
        const { data, errors } = await cartFetch((_a = event == null ? void 0 : event.payload) == null ? void 0 : _a.cartId);
        const resultEvent = eventFromFetchResult(event, data == null ? void 0 : data.cart, errors);
        send(resultEvent);
      },
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      cartCreateAction: async (_, event) => {
        var _a;
        if (event.type !== "CART_CREATE") return;
        const { data, errors } = await cartCreate(event == null ? void 0 : event.payload);
        const resultEvent = eventFromFetchResult(
          event,
          (_a = data == null ? void 0 : data.cartCreate) == null ? void 0 : _a.cart,
          errors
        );
        send(resultEvent);
      },
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      cartLineAddAction: async (context, event) => {
        var _a, _b;
        if (event.type !== "CARTLINE_ADD" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id)) return;
        const { data, errors } = await cartLineAdd(
          context.cart.id,
          event.payload.lines
        );
        const resultEvent = eventFromFetchResult(
          event,
          (_b = data == null ? void 0 : data.cartLinesAdd) == null ? void 0 : _b.cart,
          errors
        );
        send(resultEvent);
      },
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      cartLineUpdateAction: async (context, event) => {
        var _a, _b;
        if (event.type !== "CARTLINE_UPDATE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id)) return;
        const { data, errors } = await cartLineUpdate(
          context.cart.id,
          event.payload.lines
        );
        const resultEvent = eventFromFetchResult(
          event,
          (_b = data == null ? void 0 : data.cartLinesUpdate) == null ? void 0 : _b.cart,
          errors
        );
        send(resultEvent);
      },
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      cartLineRemoveAction: async (context, event) => {
        var _a, _b;
        if (event.type !== "CARTLINE_REMOVE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id)) return;
        const { data, errors } = await cartLineRemove(
          context.cart.id,
          event.payload.lines
        );
        const resultEvent = eventFromFetchResult(
          event,
          (_b = data == null ? void 0 : data.cartLinesRemove) == null ? void 0 : _b.cart,
          errors
        );
        send(resultEvent);
      },
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      noteUpdateAction: async (context, event) => {
        var _a, _b;
        if (event.type !== "NOTE_UPDATE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id)) return;
        const { data, errors } = await noteUpdate(
          context.cart.id,
          event.payload.note
        );
        const resultEvent = eventFromFetchResult(
          event,
          (_b = data == null ? void 0 : data.cartNoteUpdate) == null ? void 0 : _b.cart,
          errors
        );
        send(resultEvent);
      },
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      buyerIdentityUpdateAction: async (context, event) => {
        var _a, _b;
        if (event.type !== "BUYER_IDENTITY_UPDATE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id))
          return;
        const { data, errors } = await buyerIdentityUpdate(
          context.cart.id,
          event.payload.buyerIdentity
        );
        const resultEvent = eventFromFetchResult(
          event,
          (_b = data == null ? void 0 : data.cartBuyerIdentityUpdate) == null ? void 0 : _b.cart,
          errors
        );
        send(resultEvent);
      },
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      cartAttributesUpdateAction: async (context, event) => {
        var _a, _b;
        if (event.type !== "CART_ATTRIBUTES_UPDATE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id))
          return;
        const { data, errors } = await cartAttributesUpdate(
          context.cart.id,
          event.payload.attributes
        );
        const resultEvent = eventFromFetchResult(
          event,
          (_b = data == null ? void 0 : data.cartAttributesUpdate) == null ? void 0 : _b.cart,
          errors
        );
        send(resultEvent);
      },
      // eslint-disable-next-line @typescript-eslint/no-misused-promises
      discountCodesUpdateAction: async (context, event) => {
        var _a, _b;
        if (event.type !== "DISCOUNT_CODES_UPDATE" || !((_a = context == null ? void 0 : context.cart) == null ? void 0 : _a.id))
          return;
        const { data, errors } = await discountCodesUpdate(
          context.cart.id,
          event.payload.discountCodes
        );
        const resultEvent = eventFromFetchResult(
          event,
          (_b = data == null ? void 0 : data.cartDiscountCodesUpdate) == null ? void 0 : _b.cart,
          errors
        );
        send(resultEvent);
      },
      ...onCartActionEntry && {
        onCartActionEntry: (context, event) => {
          if (isCartActionEvent(event)) {
            onCartActionEntry(context, event);
          }
        }
      },
      ...onCartActionOptimisticUI && {
        onCartActionOptimisticUI: i((context, event) => {
          return onCartActionOptimisticUI(context, event);
        })
      },
      ...onCartActionComplete && {
        onCartActionComplete: (context, event) => {
          if (isCartFetchResultEvent(event)) {
            onCartActionComplete(context, event);
          }
        }
      }
    }
  });
  return (0, import_react10.useMemo)(() => [state, send, service], [state, send, service]);
}
function cartFromGraphQL(cart) {
  return {
    ...cart,
    lines: flattenConnection(cart == null ? void 0 : cart.lines),
    note: cart.note ?? void 0
  };
}
function eventFromFetchResult(cartActionEvent, cart, errors) {
  if (errors) {
    return { type: "ERROR", payload: { errors, cartActionEvent } };
  }
  if (!cart) {
    return {
      type: "CART_COMPLETED",
      payload: {
        cartActionEvent
      }
    };
  }
  return {
    type: "RESOLVE",
    payload: {
      cart: cartFromGraphQL(cart),
      rawCartResult: cart,
      cartActionEvent
    }
  };
}
function isCartActionEvent(event) {
  return event.type === "CART_CREATE" || event.type === "CARTLINE_ADD" || event.type === "CARTLINE_UPDATE" || event.type === "CARTLINE_REMOVE" || event.type === "NOTE_UPDATE" || event.type === "BUYER_IDENTITY_UPDATE" || event.type === "CART_ATTRIBUTES_UPDATE" || event.type === "DISCOUNT_CODES_UPDATE";
}
function isCartFetchResultEvent(event) {
  return event.type === "RESOLVE" || event.type === "ERROR" || event.type === "CART_COMPLETED";
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/CartProvider.mjs
var CartContext = (0, import_react11.createContext)(null);
function useCart() {
  const context = (0, import_react11.useContext)(CartContext);
  if (!context) {
    throw new Error("Expected a Cart Context, but no Cart Context was found");
  }
  return context;
}
function CartProvider({
  children,
  numCartLines,
  onCreate,
  onLineAdd,
  onLineRemove,
  onLineUpdate,
  onNoteUpdate,
  onBuyerIdentityUpdate,
  onAttributesUpdate,
  onDiscountCodesUpdate,
  onCreateComplete,
  onLineAddComplete,
  onLineRemoveComplete,
  onLineUpdateComplete,
  onNoteUpdateComplete,
  onBuyerIdentityUpdateComplete,
  onAttributesUpdateComplete,
  onDiscountCodesUpdateComplete,
  data: cart,
  cartFragment = defaultCartFragment,
  customerAccessToken,
  countryCode,
  languageCode
}) {
  var _a, _b, _c, _d, _e, _f, _g;
  const shop = useShop();
  if (!shop)
    throw new Error(
      "<CartProvider> needs to be a descendant of <ShopifyProvider>"
    );
  countryCode = (countryCode ?? shop.countryIsoCode ?? "US").toUpperCase();
  languageCode = (languageCode ?? shop.languageIsoCode ?? "EN").toUpperCase();
  if (countryCode) countryCode = countryCode.toUpperCase();
  const [prevCountryCode, setPrevCountryCode] = (0, import_react11.useState)(countryCode);
  const [prevCustomerAccessToken, setPrevCustomerAccessToken] = (0, import_react11.useState)(customerAccessToken);
  const customerOverridesCountryCode = (0, import_react11.useRef)(false);
  if (prevCountryCode !== countryCode || prevCustomerAccessToken !== customerAccessToken) {
    setPrevCountryCode(countryCode);
    setPrevCustomerAccessToken(customerAccessToken);
    customerOverridesCountryCode.current = false;
  }
  const [cartState, cartSend] = useCartAPIStateMachine({
    numCartLines,
    data: cart,
    cartFragment,
    countryCode,
    languageCode,
    onCartActionEntry(_, event) {
      try {
        switch (event.type) {
          case "CART_CREATE":
            return onCreate == null ? void 0 : onCreate();
          case "CARTLINE_ADD":
            return onLineAdd == null ? void 0 : onLineAdd();
          case "CARTLINE_REMOVE":
            return onLineRemove == null ? void 0 : onLineRemove();
          case "CARTLINE_UPDATE":
            return onLineUpdate == null ? void 0 : onLineUpdate();
          case "NOTE_UPDATE":
            return onNoteUpdate == null ? void 0 : onNoteUpdate();
          case "BUYER_IDENTITY_UPDATE":
            return onBuyerIdentityUpdate == null ? void 0 : onBuyerIdentityUpdate();
          case "CART_ATTRIBUTES_UPDATE":
            return onAttributesUpdate == null ? void 0 : onAttributesUpdate();
          case "DISCOUNT_CODES_UPDATE":
            return onDiscountCodesUpdate == null ? void 0 : onDiscountCodesUpdate();
        }
      } catch (error) {
        console.error("Cart entry action failed", error);
      }
    },
    onCartActionOptimisticUI(context, event) {
      var _a2, _b2, _c2, _d2;
      if (!context.cart) return { ...context };
      switch (event.type) {
        case "CARTLINE_REMOVE":
          return {
            ...context,
            cart: {
              ...context.cart,
              lines: (_b2 = (_a2 = context == null ? void 0 : context.cart) == null ? void 0 : _a2.lines) == null ? void 0 : _b2.filter(
                (line) => (line == null ? void 0 : line.id) && !event.payload.lines.includes(line == null ? void 0 : line.id)
              )
            }
          };
        case "CARTLINE_UPDATE":
          return {
            ...context,
            cart: {
              ...context.cart,
              lines: (_d2 = (_c2 = context == null ? void 0 : context.cart) == null ? void 0 : _c2.lines) == null ? void 0 : _d2.map((line) => {
                const updatedLine = event.payload.lines.find(
                  ({ id }) => id === (line == null ? void 0 : line.id)
                );
                if (updatedLine && updatedLine.quantity) {
                  return {
                    ...line,
                    quantity: updatedLine.quantity
                  };
                }
                return line;
              })
            }
          };
      }
      return { ...context };
    },
    onCartActionComplete(context, event) {
      const cartActionEvent = event.payload.cartActionEvent;
      try {
        switch (event.type) {
          case "RESOLVE":
            switch (cartActionEvent.type) {
              case "CART_CREATE":
                return onCreateComplete == null ? void 0 : onCreateComplete();
              case "CARTLINE_ADD":
                return onLineAddComplete == null ? void 0 : onLineAddComplete();
              case "CARTLINE_REMOVE":
                return onLineRemoveComplete == null ? void 0 : onLineRemoveComplete();
              case "CARTLINE_UPDATE":
                return onLineUpdateComplete == null ? void 0 : onLineUpdateComplete();
              case "NOTE_UPDATE":
                return onNoteUpdateComplete == null ? void 0 : onNoteUpdateComplete();
              case "BUYER_IDENTITY_UPDATE":
                if (countryCodeNotUpdated(context, cartActionEvent)) {
                  customerOverridesCountryCode.current = true;
                }
                return onBuyerIdentityUpdateComplete == null ? void 0 : onBuyerIdentityUpdateComplete();
              case "CART_ATTRIBUTES_UPDATE":
                return onAttributesUpdateComplete == null ? void 0 : onAttributesUpdateComplete();
              case "DISCOUNT_CODES_UPDATE":
                return onDiscountCodesUpdateComplete == null ? void 0 : onDiscountCodesUpdateComplete();
            }
        }
      } catch (error) {
        console.error("onCartActionComplete failed", error);
      }
    }
  });
  const cartReady = (0, import_react11.useRef)(false);
  const [isCartReady, setIsCartReady] = (0, import_react11.useState)(false);
  const cartCompleted = cartState.matches("cartCompleted");
  const countryChanged = (cartState.value === "idle" || cartState.value === "error" || cartState.value === "cartCompleted") && countryCode !== ((_c = (_b = (_a = cartState == null ? void 0 : cartState.context) == null ? void 0 : _a.cart) == null ? void 0 : _b.buyerIdentity) == null ? void 0 : _c.countryCode) && !cartState.context.errors;
  const fetchingFromStorage = (0, import_react11.useRef)(false);
  (0, import_react11.useEffect)(() => {
    if (!cartReady.current && !fetchingFromStorage.current) {
      if (!cart && storageAvailable("localStorage")) {
        fetchingFromStorage.current = true;
        try {
          const cartId = window.localStorage.getItem(CART_ID_STORAGE_KEY);
          if (cartId) {
            cartSend({ type: "CART_FETCH", payload: { cartId } });
          }
        } catch (error) {
          console.warn("error fetching cartId");
          console.warn(error);
        }
      }
      cartReady.current = true;
      setIsCartReady(true);
    }
  }, [cart, cartReady, cartSend]);
  (0, import_react11.useEffect)(() => {
    if (!countryChanged || customerOverridesCountryCode.current) return;
    cartSend({
      type: "BUYER_IDENTITY_UPDATE",
      payload: { buyerIdentity: { countryCode, customerAccessToken } }
    });
  }, [
    countryCode,
    customerAccessToken,
    countryChanged,
    customerOverridesCountryCode,
    cartSend
  ]);
  const onCartReadySend = (0, import_react11.useCallback)(
    (cartEvent) => {
      if (!cartReady.current) {
        return console.warn("Cart isn't ready yet");
      }
      cartSend(cartEvent);
    },
    [cartSend]
  );
  (0, import_react11.useEffect)(() => {
    var _a2, _b2, _c2;
    if (((_b2 = (_a2 = cartState == null ? void 0 : cartState.context) == null ? void 0 : _a2.cart) == null ? void 0 : _b2.id) && storageAvailable("localStorage")) {
      try {
        window.localStorage.setItem(
          CART_ID_STORAGE_KEY,
          (_c2 = cartState.context.cart) == null ? void 0 : _c2.id
        );
      } catch (error) {
        console.warn("Failed to save cartId to localStorage", error);
      }
    }
  }, [(_e = (_d = cartState == null ? void 0 : cartState.context) == null ? void 0 : _d.cart) == null ? void 0 : _e.id]);
  (0, import_react11.useEffect)(() => {
    if (cartCompleted && storageAvailable("localStorage")) {
      try {
        window.localStorage.removeItem(CART_ID_STORAGE_KEY);
      } catch (error) {
        console.warn("Failed to delete cartId from localStorage", error);
      }
    }
  }, [cartCompleted]);
  const cartCreate = (0, import_react11.useCallback)(
    (cartInput) => {
      var _a2, _b2;
      if (countryCode && !((_a2 = cartInput.buyerIdentity) == null ? void 0 : _a2.countryCode)) {
        if (cartInput.buyerIdentity == null) {
          cartInput.buyerIdentity = {};
        }
        cartInput.buyerIdentity.countryCode = countryCode;
      }
      if (customerAccessToken && !((_b2 = cartInput.buyerIdentity) == null ? void 0 : _b2.customerAccessToken)) {
        if (cartInput.buyerIdentity == null) {
          cartInput.buyerIdentity = {};
        }
        cartInput.buyerIdentity.customerAccessToken = customerAccessToken;
      }
      onCartReadySend({
        type: "CART_CREATE",
        payload: cartInput
      });
    },
    [countryCode, customerAccessToken, onCartReadySend]
  );
  const cartDisplayState = useDelayedStateUntilHydration(cartState);
  const cartContextValue = (0, import_react11.useMemo)(() => {
    var _a2, _b2, _c2, _d2;
    return {
      ...((_a2 = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _a2.cart) ?? { lines: [], attributes: [] },
      status: transposeStatus(cartDisplayState.value),
      error: (_b2 = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _b2.errors,
      totalQuantity: ((_d2 = (_c2 = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _c2.cart) == null ? void 0 : _d2.totalQuantity) ?? 0,
      cartCreate,
      cartReady: isCartReady,
      linesAdd(lines) {
        var _a3, _b3;
        if ((_b3 = (_a3 = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _a3.cart) == null ? void 0 : _b3.id) {
          onCartReadySend({
            type: "CARTLINE_ADD",
            payload: { lines }
          });
        } else {
          cartCreate({ lines });
        }
      },
      linesRemove(lines) {
        onCartReadySend({
          type: "CARTLINE_REMOVE",
          payload: {
            lines
          }
        });
      },
      linesUpdate(lines) {
        onCartReadySend({
          type: "CARTLINE_UPDATE",
          payload: {
            lines
          }
        });
      },
      noteUpdate(note) {
        onCartReadySend({
          type: "NOTE_UPDATE",
          payload: {
            note
          }
        });
      },
      buyerIdentityUpdate(buyerIdentity) {
        onCartReadySend({
          type: "BUYER_IDENTITY_UPDATE",
          payload: {
            buyerIdentity
          }
        });
      },
      cartAttributesUpdate(attributes) {
        onCartReadySend({
          type: "CART_ATTRIBUTES_UPDATE",
          payload: {
            attributes
          }
        });
      },
      discountCodesUpdate(discountCodes) {
        onCartReadySend({
          type: "DISCOUNT_CODES_UPDATE",
          payload: {
            discountCodes
          }
        });
      },
      cartFragment
    };
  }, [
    cartCreate,
    isCartReady,
    (_f = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _f.cart,
    (_g = cartDisplayState == null ? void 0 : cartDisplayState.context) == null ? void 0 : _g.errors,
    cartDisplayState.value,
    cartFragment,
    onCartReadySend
  ]);
  return (0, import_jsx_runtime2.jsx)(CartContext.Provider, { value: cartContextValue, children });
}
function transposeStatus(status) {
  switch (status) {
    case "uninitialized":
    case "initializationError":
      return "uninitialized";
    case "idle":
    case "cartCompleted":
    case "error":
      return "idle";
    case "cartFetching":
      return "fetching";
    case "cartCreating":
      return "creating";
    case "cartLineAdding":
    case "cartLineRemoving":
    case "cartLineUpdating":
    case "noteUpdating":
    case "buyerIdentityUpdating":
    case "cartAttributesUpdating":
    case "discountCodesUpdating":
      return "updating";
  }
}
function useDelayedStateUntilHydration(state) {
  const [isPending, startTransition] = (0, import_react11.useTransition)();
  const [delayedState, setDelayedState] = (0, import_react11.useState)(state);
  const firstTimePending = (0, import_react11.useRef)(false);
  if (isPending) {
    firstTimePending.current = true;
  }
  const firstTimePendingFinished = (0, import_react11.useRef)(false);
  if (!isPending && firstTimePending.current) {
    firstTimePendingFinished.current = true;
  }
  (0, import_react11.useEffect)(() => {
    startTransition(() => {
      if (!firstTimePendingFinished.current) {
        setDelayedState(state);
      }
    });
  }, [state]);
  const displayState = firstTimePendingFinished.current ? state : delayedState;
  return displayState;
}
function storageAvailable(type) {
  let storage;
  try {
    storage = window[type];
    const x = "__storage_test__";
    storage.setItem(x, x);
    storage.removeItem(x);
    return true;
  } catch (e2) {
    return !!(e2 instanceof DOMException && // everything except Firefox
    (e2.code === 22 || // Firefox
    e2.code === 1014 || // test name field too, because code might not be present
    // everything except Firefox
    e2.name === "QuotaExceededError" || // Firefox
    e2.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
    storage && storage.length !== 0);
  }
}
function countryCodeNotUpdated(context, event) {
  var _a, _b;
  return !!(event.payload.buyerIdentity.countryCode && ((_b = (_a = context.cart) == null ? void 0 : _a.buyerIdentity) == null ? void 0 : _b.countryCode) !== event.payload.buyerIdentity.countryCode);
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/ProductProvider.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);
var ProductOptionsContext = (0, import_react12.createContext)(null);
function ProductProvider({
  children,
  data: product,
  initialVariantId: explicitVariantId
}) {
  const variants = (0, import_react12.useMemo)(
    () => flattenConnection(product.variants ?? {}),
    [product.variants]
  );
  if (!isProductVariantArray(variants)) {
    throw new Error(
      `<ProductProvider/> requires 'product.variants.nodes' or 'product.variants.edges'`
    );
  }
  const options = (0, import_react12.useMemo)(() => getOptions(variants), [variants]);
  const [selectedVariant, setSelectedVariant] = (0, import_react12.useState)(() => getVariantBasedOnIdProp(explicitVariantId, variants));
  const [selectedOptions, setSelectedOptions] = (0, import_react12.useState)(
    () => getSelectedOptions(selectedVariant)
  );
  (0, import_react12.useEffect)(() => {
    const newSelectedVariant = getVariantBasedOnIdProp(
      explicitVariantId,
      variants
    );
    setSelectedVariant(newSelectedVariant);
    setSelectedOptions(getSelectedOptions(newSelectedVariant));
  }, [explicitVariantId, variants]);
  const setSelectedOption = (0, import_react12.useCallback)(
    (name, value2) => {
      setSelectedOptions((selectedOptions2) => {
        const opts = { ...selectedOptions2, [name]: value2 };
        setSelectedVariant(getSelectedVariant(variants, opts));
        return opts;
      });
    },
    [setSelectedOptions, variants]
  );
  const isOptionInStock = (0, import_react12.useCallback)(
    (option, value2) => {
      const proposedVariant = getSelectedVariant(variants, {
        ...selectedOptions,
        ...{ [option]: value2 }
      });
      return (proposedVariant == null ? void 0 : proposedVariant.availableForSale) ?? true;
    },
    [selectedOptions, variants]
  );
  const sellingPlanGroups = (0, import_react12.useMemo)(
    () => flattenConnection(product.sellingPlanGroups ?? {}).map(
      (sellingPlanGroup) => ({
        ...sellingPlanGroup,
        sellingPlans: flattenConnection((sellingPlanGroup == null ? void 0 : sellingPlanGroup.sellingPlans) ?? {})
      })
    ),
    [product.sellingPlanGroups]
  );
  const [selectedSellingPlan, setSelectedSellingPlan] = (0, import_react12.useState)(void 0);
  const selectedSellingPlanAllocation = (0, import_react12.useMemo)(() => {
    var _a, _b;
    if (!selectedVariant || !selectedSellingPlan) {
      return;
    }
    if (!((_a = selectedVariant.sellingPlanAllocations) == null ? void 0 : _a.nodes) && !((_b = selectedVariant.sellingPlanAllocations) == null ? void 0 : _b.edges)) {
      throw new Error(
        `<ProductProvider/>: You must include 'sellingPlanAllocations.nodes' or 'sellingPlanAllocations.edges' in your variants in order to calculate selectedSellingPlanAllocation`
      );
    }
    return flattenConnection(selectedVariant.sellingPlanAllocations).find(
      (allocation) => {
        var _a2;
        return ((_a2 = allocation == null ? void 0 : allocation.sellingPlan) == null ? void 0 : _a2.id) === selectedSellingPlan.id;
      }
    );
  }, [selectedVariant, selectedSellingPlan]);
  const value = (0, import_react12.useMemo)(
    () => ({
      product,
      variants,
      variantsConnection: product.variants,
      options,
      selectedVariant,
      setSelectedVariant,
      selectedOptions,
      setSelectedOption,
      setSelectedOptions,
      isOptionInStock,
      selectedSellingPlan,
      setSelectedSellingPlan,
      selectedSellingPlanAllocation,
      sellingPlanGroups,
      sellingPlanGroupsConnection: product.sellingPlanGroups
    }),
    [
      product,
      isOptionInStock,
      options,
      selectedOptions,
      selectedSellingPlan,
      selectedSellingPlanAllocation,
      selectedVariant,
      sellingPlanGroups,
      setSelectedOption,
      variants
    ]
  );
  return (0, import_jsx_runtime3.jsx)(ProductOptionsContext.Provider, { value, children });
}
function useProduct() {
  const context = (0, import_react12.useContext)(ProductOptionsContext);
  if (!context) {
    throw new Error(`'useProduct' must be a child of <ProductProvider />`);
  }
  return context;
}
function getSelectedVariant(variants, choices) {
  var _a, _b;
  if (!variants.length || ((_b = (_a = variants == null ? void 0 : variants[0]) == null ? void 0 : _a.selectedOptions) == null ? void 0 : _b.length) !== Object.keys(choices).length) {
    return;
  }
  return variants == null ? void 0 : variants.find((variant) => {
    return Object.entries(choices).every(([name, value]) => {
      var _a2;
      return (_a2 = variant == null ? void 0 : variant.selectedOptions) == null ? void 0 : _a2.some(
        (option) => (option == null ? void 0 : option.name) === name && (option == null ? void 0 : option.value) === value
      );
    });
  });
}
function getOptions(variants) {
  const map = variants.reduce(
    (memo, variant) => {
      var _a;
      if (!variant.selectedOptions) {
        throw new Error(`'getOptions' requires 'variant.selectedOptions'`);
      }
      (_a = variant == null ? void 0 : variant.selectedOptions) == null ? void 0 : _a.forEach((opt) => {
        memo[(opt == null ? void 0 : opt.name) ?? ""] = memo[(opt == null ? void 0 : opt.name) ?? ""] || /* @__PURE__ */ new Set();
        memo[(opt == null ? void 0 : opt.name) ?? ""].add((opt == null ? void 0 : opt.value) ?? "");
      });
      return memo;
    },
    {}
  );
  return Object.keys(map).map((option) => {
    return {
      name: option,
      values: Array.from(map[option])
    };
  });
}
function getVariantBasedOnIdProp(explicitVariantId, variants) {
  if (explicitVariantId) {
    const foundVariant = variants.find(
      (variant) => (variant == null ? void 0 : variant.id) === explicitVariantId
    );
    if (!foundVariant) {
      console.warn(
        `<ProductProvider/> received a 'initialVariantId' prop, but could not actually find a variant with that ID`
      );
    }
    return foundVariant;
  }
  if (explicitVariantId === null) {
    return null;
  }
  if (explicitVariantId === void 0) {
    return variants.find((variant) => variant == null ? void 0 : variant.availableForSale) || variants[0];
  }
}
function getSelectedOptions(selectedVariant) {
  return (selectedVariant == null ? void 0 : selectedVariant.selectedOptions) ? selectedVariant.selectedOptions.reduce(
    (memo, optionSet) => {
      memo[(optionSet == null ? void 0 : optionSet.name) ?? ""] = (optionSet == null ? void 0 : optionSet.value) ?? "";
      return memo;
    },
    {}
  ) : {};
}
function isProductVariantArray(maybeVariantArray) {
  if (!maybeVariantArray || !Array.isArray(maybeVariantArray)) {
    return false;
  }
  return true;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/BaseButton.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);
function BaseButton(props) {
  const {
    as,
    onClick,
    defaultOnClick,
    children,
    buttonRef,
    ...passthroughProps
  } = props;
  const handleOnClick = (0, import_react13.useCallback)(
    (event) => {
      if (onClick) {
        const clickShouldContinue = onClick(event);
        if (typeof clickShouldContinue === "boolean" && clickShouldContinue === false || (event == null ? void 0 : event.defaultPrevented))
          return;
      }
      defaultOnClick == null ? void 0 : defaultOnClick(event);
    },
    [defaultOnClick, onClick]
  );
  const Component = as || "button";
  return (0, import_jsx_runtime4.jsx)(Component, { ref: buttonRef, onClick: handleOnClick, ...passthroughProps, children });
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/AddToCartButton.mjs
function AddToCartButton(props) {
  const [addingItem, setAddingItem] = (0, import_react14.useState)(false);
  const {
    variantId: explicitVariantId,
    quantity = 1,
    attributes,
    sellingPlanId,
    onClick,
    children,
    accessibleAddingToCartLabel,
    ...passthroughProps
  } = props;
  const { status, linesAdd } = useCart();
  const { selectedVariant } = useProduct();
  const variantId = explicitVariantId ?? (selectedVariant == null ? void 0 : selectedVariant.id) ?? "";
  const disabled = explicitVariantId === null || variantId === "" || selectedVariant === null || addingItem || // Only certain 'as' types such as 'button' contain `disabled`
  passthroughProps.disabled;
  (0, import_react14.useEffect)(() => {
    if (addingItem && status === "idle") {
      setAddingItem(false);
    }
  }, [status, addingItem]);
  const handleAddItem = (0, import_react14.useCallback)(() => {
    setAddingItem(true);
    linesAdd([
      {
        quantity,
        merchandiseId: variantId || "",
        attributes,
        sellingPlanId
      }
    ]);
  }, [linesAdd, quantity, variantId, attributes, sellingPlanId]);
  return (0, import_jsx_runtime5.jsxs)(import_jsx_runtime5.Fragment, { children: [
    (0, import_jsx_runtime5.jsx)(
      BaseButton,
      {
        ...passthroughProps,
        disabled,
        onClick,
        defaultOnClick: handleAddItem,
        children
      }
    ),
    accessibleAddingToCartLabel ? (0, import_jsx_runtime5.jsx)(
      "p",
      {
        style: {
          position: "absolute",
          width: "1px",
          height: "1px",
          padding: "0",
          margin: "-1px",
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          borderWidth: "0"
        },
        role: "alert",
        "aria-live": "assertive",
        children: addingItem ? accessibleAddingToCartLabel : null
      }
    ) : null
  ] });
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/analytics-constants.mjs
var AnalyticsEventName = {
  PAGE_VIEW: "PAGE_VIEW",
  ADD_TO_CART: "ADD_TO_CART",
  PAGE_VIEW_2: "PAGE_VIEW_2",
  COLLECTION_VIEW: "COLLECTION_VIEW",
  PRODUCT_VIEW: "PRODUCT_VIEW",
  SEARCH_VIEW: "SEARCH_VIEW"
};
var AnalyticsPageType = {
  article: "article",
  blog: "blog",
  captcha: "captcha",
  cart: "cart",
  collection: "collection",
  customersAccount: "customers/account",
  customersActivateAccount: "customers/activate_account",
  customersAddresses: "customers/addresses",
  customersLogin: "customers/login",
  customersOrder: "customers/order",
  customersRegister: "customers/register",
  customersResetPassword: "customers/reset_password",
  giftCard: "gift_card",
  home: "index",
  listCollections: "list-collections",
  forbidden: "403",
  notFound: "404",
  page: "page",
  password: "password",
  product: "product",
  policy: "policy",
  search: "search"
};
var ShopifySalesChannel = {
  hydrogen: "hydrogen",
  headless: "headless"
};
var ShopifyAppId = {
  hydrogen: "6167201",
  headless: "12875497473"
};

// node_modules/@shopify/hydrogen-react/dist/browser-dev/analytics-utils.mjs
function schemaWrapper(schemaId, payload) {
  return {
    schema_id: schemaId,
    payload,
    metadata: {
      event_created_at_ms: Date.now()
    }
  };
}
function parseGid(gid) {
  const defaultReturn = {
    id: "",
    resource: null,
    resourceId: null,
    search: "",
    searchParams: new URLSearchParams(),
    hash: ""
  };
  if (typeof gid !== "string") {
    return defaultReturn;
  }
  try {
    const { search, searchParams, pathname, hash } = new URL(gid);
    const pathnameParts = pathname.split("/");
    const lastPathnamePart = pathnameParts[pathnameParts.length - 1];
    const resourcePart = pathnameParts[pathnameParts.length - 2];
    if (!lastPathnamePart || !resourcePart) {
      return defaultReturn;
    }
    const id = `${lastPathnamePart}${search}${hash}` || "";
    const resourceId = lastPathnamePart || null;
    const resource = resourcePart ?? null;
    return { id, resource, resourceId, search, searchParams, hash };
  } catch {
    return defaultReturn;
  }
}
function addDataIf(keyValuePairs, formattedData) {
  if (typeof keyValuePairs !== "object") {
    return {};
  }
  Object.entries(keyValuePairs).forEach(([key, value]) => {
    if (value) {
      formattedData[key] = value;
    }
  });
  return formattedData;
}
function errorIfServer(fnName) {
  if (typeof document === "undefined") {
    console.error(
      `${fnName} should only be used within the useEffect callback or event handlers`
    );
    return true;
  }
  return false;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/analytics-schema-trekkie-storefront-page-view.mjs
var SCHEMA_ID = "trekkie_storefront_page_view/1.4";
var OXYGEN_DOMAIN = "myshopify.dev";
function pageView(payload) {
  const pageViewPayload = payload;
  const { id, resource } = parseGid(pageViewPayload.resourceId);
  const resourceType = resource ? resource.toLowerCase() : void 0;
  return [
    schemaWrapper(
      SCHEMA_ID,
      addDataIf(
        {
          pageType: pageViewPayload.pageType,
          customerId: parseInt(parseGid(pageViewPayload.customerId).id || "0"),
          resourceType,
          resourceId: parseInt(id)
        },
        formatPayload(pageViewPayload)
      )
    )
  ];
}
function formatPayload(payload) {
  return {
    appClientId: payload.shopifySalesChannel ? ShopifyAppId[payload.shopifySalesChannel] : ShopifyAppId.headless,
    isMerchantRequest: isMerchantRequest(payload.url),
    hydrogenSubchannelId: payload.storefrontId || payload.hydrogenSubchannelId || "0",
    isPersistentCookie: payload.hasUserConsent,
    uniqToken: payload.uniqueToken,
    visitToken: payload.visitToken,
    microSessionId: buildUUID(),
    microSessionCount: 1,
    url: payload.url,
    path: payload.path,
    search: payload.search,
    referrer: payload.referrer,
    title: payload.title,
    shopId: parseInt(parseGid(payload.shopId).id),
    currency: payload.currency,
    contentLanguage: payload.acceptedLanguage || "en"
  };
}
function isMerchantRequest(url) {
  if (typeof url !== "string") {
    return false;
  }
  const hostname = new URL(url).hostname;
  if (hostname.indexOf(OXYGEN_DOMAIN) !== -1 || hostname === "localhost") {
    return true;
  }
  return false;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/packages/hydrogen-react/package.json.mjs
var version = "2025.7.0";

// node_modules/@shopify/hydrogen-react/dist/browser-dev/analytics-schema-custom-storefront-customer-tracking.mjs
var SCHEMA_ID2 = "custom_storefront_customer_tracking/1.2";
var PAGE_RENDERED_EVENT_NAME = "page_rendered";
var COLLECTION_PAGE_RENDERED_EVENT_NAME = "collection_page_rendered";
var PRODUCT_PAGE_RENDERED_EVENT_NAME = "product_page_rendered";
var PRODUCT_ADDED_TO_CART_EVENT_NAME = "product_added_to_cart";
var SEARCH_SUBMITTED_EVENT_NAME = "search_submitted";
function prepareAdditionalPayload(payload) {
  return {
    canonical_url: payload.canonicalUrl || payload.url,
    customer_id: parseInt(parseGid(payload.customerId).id || "0")
  };
}
function pageView2(payload) {
  const pageViewPayload = payload;
  const additionalPayload = prepareAdditionalPayload(pageViewPayload);
  const pageType = pageViewPayload.pageType;
  const pageViewEvents = [];
  pageViewEvents.push(
    schemaWrapper(
      SCHEMA_ID2,
      addDataIf(
        {
          event_name: PAGE_RENDERED_EVENT_NAME,
          ...additionalPayload
        },
        formatPayload2(pageViewPayload)
      )
    )
  );
  switch (pageType) {
    case AnalyticsPageType.collection:
      pageViewEvents.push(
        schemaWrapper(
          SCHEMA_ID2,
          addDataIf(
            {
              event_name: COLLECTION_PAGE_RENDERED_EVENT_NAME,
              ...additionalPayload,
              collection_name: pageViewPayload.collectionHandle,
              collection_id: parseInt(
                parseGid(pageViewPayload.collectionId).id
              )
            },
            formatPayload2(pageViewPayload)
          )
        )
      );
      break;
    case AnalyticsPageType.product:
      pageViewEvents.push(
        schemaWrapper(
          SCHEMA_ID2,
          addDataIf(
            {
              event_name: PRODUCT_PAGE_RENDERED_EVENT_NAME,
              ...additionalPayload,
              products: formatProductPayload(pageViewPayload.products),
              total_value: pageViewPayload.totalValue
            },
            formatPayload2(pageViewPayload)
          )
        )
      );
      break;
    case AnalyticsPageType.search:
      pageViewEvents.push(
        schemaWrapper(
          SCHEMA_ID2,
          addDataIf(
            {
              event_name: SEARCH_SUBMITTED_EVENT_NAME,
              ...additionalPayload,
              search_string: pageViewPayload.searchString
            },
            formatPayload2(pageViewPayload)
          )
        )
      );
      break;
  }
  return pageViewEvents;
}
function pageView22(payload) {
  const pageViewPayload = payload;
  const additionalPayload = prepareAdditionalPayload(pageViewPayload);
  return [
    schemaWrapper(
      SCHEMA_ID2,
      addDataIf(
        {
          event_name: PAGE_RENDERED_EVENT_NAME,
          ...additionalPayload
        },
        formatPayload2(pageViewPayload)
      )
    )
  ];
}
function collectionView(payload) {
  const pageViewPayload = payload;
  const additionalPayload = prepareAdditionalPayload(pageViewPayload);
  return [
    schemaWrapper(
      SCHEMA_ID2,
      addDataIf(
        {
          event_name: COLLECTION_PAGE_RENDERED_EVENT_NAME,
          ...additionalPayload,
          collection_name: pageViewPayload.collectionHandle,
          collection_id: parseInt(parseGid(pageViewPayload.collectionId).id)
        },
        formatPayload2(pageViewPayload)
      )
    )
  ];
}
function productView(payload) {
  const pageViewPayload = payload;
  const additionalPayload = prepareAdditionalPayload(pageViewPayload);
  return [
    schemaWrapper(
      SCHEMA_ID2,
      addDataIf(
        {
          event_name: PRODUCT_PAGE_RENDERED_EVENT_NAME,
          ...additionalPayload,
          products: formatProductPayload(pageViewPayload.products),
          total_value: pageViewPayload.totalValue
        },
        formatPayload2(pageViewPayload)
      )
    )
  ];
}
function searchView(payload) {
  const pageViewPayload = payload;
  const additionalPayload = prepareAdditionalPayload(pageViewPayload);
  return [
    schemaWrapper(
      SCHEMA_ID2,
      addDataIf(
        {
          event_name: SEARCH_SUBMITTED_EVENT_NAME,
          ...additionalPayload,
          search_string: pageViewPayload.searchString
        },
        formatPayload2(pageViewPayload)
      )
    )
  ];
}
function addToCart(payload) {
  const addToCartPayload = payload;
  const cartToken = parseGid(addToCartPayload.cartId);
  return [
    schemaWrapper(
      SCHEMA_ID2,
      addDataIf(
        {
          event_name: PRODUCT_ADDED_TO_CART_EVENT_NAME,
          customerId: addToCartPayload.customerId,
          cart_token: (cartToken == null ? void 0 : cartToken.id) ? `${cartToken.id}` : null,
          total_value: addToCartPayload.totalValue,
          products: formatProductPayload(addToCartPayload.products),
          customer_id: parseInt(
            parseGid(addToCartPayload.customerId).id || "0"
          )
        },
        formatPayload2(addToCartPayload)
      )
    )
  ];
}
function formatPayload2(payload) {
  return {
    source: payload.shopifySalesChannel || ShopifySalesChannel.headless,
    asset_version_id: payload.assetVersionId || version,
    hydrogenSubchannelId: payload.storefrontId || payload.hydrogenSubchannelId || "0",
    is_persistent_cookie: payload.hasUserConsent,
    deprecated_visit_token: payload.visitToken,
    unique_token: payload.uniqueToken,
    event_time: Date.now(),
    event_id: buildUUID(),
    event_source_url: payload.url,
    referrer: payload.referrer,
    user_agent: payload.userAgent,
    navigation_type: payload.navigationType,
    navigation_api: payload.navigationApi,
    shop_id: parseInt(parseGid(payload.shopId).id),
    currency: payload.currency,
    ccpa_enforced: payload.ccpaEnforced || false,
    gdpr_enforced: payload.gdprEnforced || false,
    gdpr_enforced_as_string: payload.gdprEnforced ? "true" : "false",
    analytics_allowed: payload.analyticsAllowed || false,
    marketing_allowed: payload.marketingAllowed || false,
    sale_of_data_allowed: payload.saleOfDataAllowed || false
  };
}
function formatProductPayload(products) {
  return products ? products.map((p) => {
    const product = addDataIf(
      {
        variant_gid: p.variantGid,
        category: p.category,
        sku: p.sku,
        product_id: parseInt(parseGid(p.productGid).id),
        variant_id: parseInt(parseGid(p.variantGid).id)
      },
      {
        product_gid: p.productGid,
        name: p.name,
        variant: p.variantName || "",
        brand: p.brand,
        price: parseFloat(p.price),
        quantity: Number(p.quantity || 0)
      }
    );
    return JSON.stringify(product);
  }) : [];
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/analytics.mjs
function sendShopifyAnalytics(event, shopDomain) {
  const { eventName, payload } = event;
  if (!payload.hasUserConsent) return Promise.resolve();
  let events = [];
  const pageViewPayload = payload;
  if (eventName === AnalyticsEventName.PAGE_VIEW) {
    events = events.concat(
      pageView(pageViewPayload),
      pageView2(pageViewPayload)
    );
  } else if (eventName === AnalyticsEventName.ADD_TO_CART) {
    events = events.concat(
      addToCart(payload)
    );
  } else if (eventName === AnalyticsEventName.PAGE_VIEW_2) {
    events = events.concat(
      pageView(pageViewPayload),
      pageView22(pageViewPayload)
    );
  } else if (eventName === AnalyticsEventName.COLLECTION_VIEW) {
    events = events.concat(collectionView(pageViewPayload));
  } else if (eventName === AnalyticsEventName.PRODUCT_VIEW) {
    events = events.concat(productView(pageViewPayload));
  } else if (eventName === AnalyticsEventName.SEARCH_VIEW) {
    events = events.concat(searchView(pageViewPayload));
  }
  if (events.length) {
    return sendToShopify(events, shopDomain);
  } else {
    return Promise.resolve();
  }
}
function isLighthouseUserAgent() {
  if (typeof window === "undefined" || !window.navigator) return false;
  return /Chrome-Lighthouse/.test(window.navigator.userAgent);
}
var ERROR_MESSAGE = "sendShopifyAnalytics request is unsuccessful";
function sendToShopify(events, shopDomain) {
  if (isLighthouseUserAgent()) {
    return Promise.resolve();
  }
  const eventsToBeSent = {
    events,
    metadata: {
      event_sent_at_ms: Date.now()
    }
  };
  try {
    return fetch(
      shopDomain ? `https://${shopDomain}/.well-known/shopify/monorail/unstable/produce_batch` : "https://monorail-edge.shopifysvc.com/unstable/produce_batch",
      {
        method: "post",
        headers: {
          "content-type": "text/plain"
        },
        body: JSON.stringify(eventsToBeSent)
      }
    ).then((response) => {
      if (!response.ok) {
        throw new Error("Response failed");
      }
      return response.text();
    }).then((data) => {
      if (data) {
        const jsonResponse = JSON.parse(data);
        jsonResponse.result.forEach((eventResponse) => {
          if (eventResponse.status !== 200) {
            console.error(ERROR_MESSAGE, "\n\n", eventResponse.message);
          }
        });
      }
    }).catch((err) => {
      console.error(ERROR_MESSAGE, err);
      if (true) {
        throw new Error(ERROR_MESSAGE);
      }
    });
  } catch (error) {
    return Promise.resolve();
  }
}
function getClientBrowserParameters() {
  if (errorIfServer("getClientBrowserParameters")) {
    return {
      uniqueToken: "",
      visitToken: "",
      url: "",
      path: "",
      search: "",
      referrer: "",
      title: "",
      userAgent: "",
      navigationType: "",
      navigationApi: ""
    };
  }
  const [navigationType, navigationApi] = getNavigationType();
  const cookies = getShopifyCookies(document.cookie);
  return {
    uniqueToken: cookies[SHOPIFY_Y],
    visitToken: cookies[SHOPIFY_S],
    url: location.href,
    path: location.pathname,
    search: location.search,
    referrer: document.referrer,
    title: document.title,
    userAgent: navigator.userAgent,
    navigationType,
    navigationApi
  };
}
function getNavigationTypeExperimental() {
  try {
    const navigationEntries = (performance == null ? void 0 : performance.getEntriesByType) && (performance == null ? void 0 : performance.getEntriesByType("navigation"));
    if (navigationEntries && navigationEntries[0]) {
      const rawType = window.performance.getEntriesByType(
        "navigation"
      )[0]["type"];
      const navType = rawType && rawType.toString();
      return navType;
    }
  } catch (err) {
  }
  return void 0;
}
function getNavigationTypeLegacy() {
  var _a, _b;
  try {
    if (PerformanceNavigation && ((_a = performance == null ? void 0 : performance.navigation) == null ? void 0 : _a.type) !== null && ((_b = performance == null ? void 0 : performance.navigation) == null ? void 0 : _b.type) !== void 0) {
      const rawType = performance.navigation.type;
      switch (rawType) {
        case PerformanceNavigation.TYPE_NAVIGATE:
          return "navigate";
        case PerformanceNavigation.TYPE_RELOAD:
          return "reload";
        case PerformanceNavigation.TYPE_BACK_FORWARD:
          return "back_forward";
        default:
          return `unknown: ${rawType}`;
      }
    }
  } catch (err) {
  }
  return void 0;
}
function getNavigationType() {
  try {
    let navApi = "PerformanceNavigationTiming";
    let navType = getNavigationTypeExperimental();
    if (!navType) {
      navType = getNavigationTypeLegacy();
      navApi = "performance.navigation";
    }
    if (navType) {
      return [navType, navApi];
    } else {
      return ["unknown", "unknown"];
    }
  } catch (err) {
  }
  return ["error", "error"];
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/BuyNowButton.mjs
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react15 = __toESM(require_react(), 1);
function BuyNowButton(props) {
  const { cartCreate, checkoutUrl } = useCart();
  const [loading, setLoading] = (0, import_react15.useState)(false);
  const {
    quantity,
    variantId,
    sellingPlanId,
    onClick,
    attributes,
    children,
    ...passthroughProps
  } = props;
  (0, import_react15.useEffect)(() => {
    if (loading && checkoutUrl) {
      window.location.href = checkoutUrl;
    }
  }, [loading, checkoutUrl]);
  const handleBuyNow = (0, import_react15.useCallback)(() => {
    setLoading(true);
    cartCreate({
      lines: [
        {
          quantity: quantity ?? 1,
          merchandiseId: variantId,
          attributes,
          sellingPlanId
        }
      ]
    });
  }, [cartCreate, quantity, variantId, attributes, sellingPlanId]);
  return (0, import_jsx_runtime6.jsx)(
    BaseButton,
    {
      disabled: loading ?? passthroughProps.disabled,
      ...passthroughProps,
      onClick,
      defaultOnClick: handleBuyNow,
      children
    }
  );
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/CartCheckoutButton.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react16 = __toESM(require_react(), 1);
function CartCheckoutButton(props) {
  const [requestedCheckout, setRequestedCheckout] = (0, import_react16.useState)(false);
  const { status, checkoutUrl } = useCart();
  const { children, ...passthroughProps } = props;
  (0, import_react16.useEffect)(() => {
    if (requestedCheckout && checkoutUrl && status === "idle") {
      window.location.href = checkoutUrl;
    }
  }, [requestedCheckout, status, checkoutUrl]);
  return (0, import_jsx_runtime7.jsx)(
    BaseButton,
    {
      ...passthroughProps,
      disabled: requestedCheckout || passthroughProps.disabled,
      onClick: () => setRequestedCheckout(true),
      children
    }
  );
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/CartCost.mjs
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/Money.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/useMoney.mjs
var import_react17 = __toESM(require_react(), 1);
function useMoney(money) {
  const { countryIsoCode, languageIsoCode } = useShop();
  const locale = languageIsoCode.includes("_") ? languageIsoCode.replace("_", "-") : `${languageIsoCode}-${countryIsoCode}`;
  if (!locale) {
    throw new Error(
      `useMoney(): Unable to get 'locale' from 'useShop()', which means that 'locale' was not passed to '<ShopifyProvider/>'. 'locale' is required for 'useMoney()' to work`
    );
  }
  const amount = parseFloat(money.amount);
  let isCurrencySupported = true;
  try {
    new Intl.NumberFormat(locale, {
      style: "currency",
      currency: money.currencyCode
    });
  } catch (e2) {
    if (e2 instanceof RangeError && e2.message.includes("currency")) {
      isCurrencySupported = false;
    }
  }
  const {
    defaultFormatter,
    nameFormatter,
    narrowSymbolFormatter,
    withoutTrailingZerosFormatter,
    withoutCurrencyFormatter,
    withoutTrailingZerosOrCurrencyFormatter
  } = (0, import_react17.useMemo)(() => {
    const options = isCurrencySupported ? {
      style: "currency",
      currency: money.currencyCode
    } : {
      style: "decimal",
      minimumFractionDigits: 2,
      maximumFractionDigits: 2
    };
    return {
      defaultFormatter: getLazyFormatter(locale, options),
      nameFormatter: getLazyFormatter(locale, {
        ...options,
        currencyDisplay: "name"
      }),
      narrowSymbolFormatter: getLazyFormatter(locale, {
        ...options,
        currencyDisplay: "narrowSymbol"
      }),
      withoutTrailingZerosFormatter: getLazyFormatter(locale, {
        ...options,
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
      }),
      withoutCurrencyFormatter: getLazyFormatter(locale, {
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      }),
      withoutTrailingZerosOrCurrencyFormatter: getLazyFormatter(locale, {
        minimumFractionDigits: 0,
        maximumFractionDigits: 0
      })
    };
  }, [money.currencyCode, locale, isCurrencySupported]);
  const isPartCurrency = (part) => part.type === "currency";
  const lazyFormatters = (0, import_react17.useMemo)(
    () => ({
      original: () => money,
      currencyCode: () => money.currencyCode,
      localizedString: () => {
        const formatted = defaultFormatter().format(amount);
        return isCurrencySupported ? formatted : `${formatted} ${money.currencyCode}`;
      },
      parts: () => {
        const parts = defaultFormatter().formatToParts(amount);
        if (!isCurrencySupported) {
          parts.push(
            { type: "literal", value: " " },
            { type: "currency", value: money.currencyCode }
          );
        }
        return parts;
      },
      withoutTrailingZeros: () => {
        const formatted = amount % 1 === 0 ? withoutTrailingZerosFormatter().format(amount) : defaultFormatter().format(amount);
        return isCurrencySupported ? formatted : `${formatted} ${money.currencyCode}`;
      },
      withoutTrailingZerosAndCurrency: () => amount % 1 === 0 ? withoutTrailingZerosOrCurrencyFormatter().format(amount) : withoutCurrencyFormatter().format(amount),
      currencyName: () => {
        var _a;
        return ((_a = nameFormatter().formatToParts(amount).find(isPartCurrency)) == null ? void 0 : _a.value) ?? money.currencyCode;
      },
      // e.g. "US dollars"
      currencySymbol: () => {
        var _a;
        return ((_a = defaultFormatter().formatToParts(amount).find(isPartCurrency)) == null ? void 0 : _a.value) ?? money.currencyCode;
      },
      // e.g. "USD"
      currencyNarrowSymbol: () => {
        var _a;
        return ((_a = narrowSymbolFormatter().formatToParts(amount).find(isPartCurrency)) == null ? void 0 : _a.value) ?? "";
      },
      // e.g. "$"
      amount: () => defaultFormatter().formatToParts(amount).filter(
        (part) => ["decimal", "fraction", "group", "integer", "literal"].includes(
          part.type
        )
      ).map((part) => part.value).join("")
    }),
    [
      money,
      amount,
      isCurrencySupported,
      nameFormatter,
      defaultFormatter,
      narrowSymbolFormatter,
      withoutCurrencyFormatter,
      withoutTrailingZerosFormatter,
      withoutTrailingZerosOrCurrencyFormatter
    ]
  );
  return (0, import_react17.useMemo)(
    () => new Proxy(lazyFormatters, {
      // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
      get: (target, key) => {
        var _a;
        return (_a = Reflect.get(target, key)) == null ? void 0 : _a.call(null);
      }
    }),
    [lazyFormatters]
  );
}
var formatterCache = /* @__PURE__ */ new Map();
function getLazyFormatter(locale, options) {
  const key = JSON.stringify([locale, options]);
  return function() {
    let formatter = formatterCache.get(key);
    if (!formatter) {
      try {
        formatter = new Intl.NumberFormat(locale, options);
      } catch (error) {
        if (error instanceof RangeError && error.message.includes("currency")) {
          const fallbackOptions = { ...options };
          delete fallbackOptions.currency;
          delete fallbackOptions.currencyDisplay;
          delete fallbackOptions.currencySign;
          formatter = new Intl.NumberFormat(locale, fallbackOptions);
        } else {
          throw error;
        }
      }
      formatterCache.set(key, formatter);
    }
    return formatter;
  };
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/Money.mjs
function Money({
  data,
  as,
  withoutCurrency,
  withoutTrailingZeros,
  measurement,
  measurementSeparator = "/",
  ...passthroughProps
}) {
  if (!isMoney(data)) {
    throw new Error(
      `<Money/> needs a valid 'data' prop that has 'amount' and 'currencyCode'`
    );
  }
  const moneyObject = useMoney(data);
  const Wrapper = as ?? "div";
  let output = moneyObject.localizedString;
  if (withoutCurrency || withoutTrailingZeros) {
    if (withoutCurrency && !withoutTrailingZeros) {
      output = moneyObject.amount;
    } else if (!withoutCurrency && withoutTrailingZeros) {
      output = moneyObject.withoutTrailingZeros;
    } else {
      output = moneyObject.withoutTrailingZerosAndCurrency;
    }
  }
  return (0, import_jsx_runtime8.jsxs)(Wrapper, { ...passthroughProps, children: [
    output,
    measurement && measurement.referenceUnit && (0, import_jsx_runtime8.jsxs)(import_jsx_runtime8.Fragment, { children: [
      measurementSeparator,
      measurement.referenceUnit
    ] })
  ] });
}
function isMoney(maybeMoney) {
  return typeof maybeMoney.amount === "string" && !!maybeMoney.amount && typeof maybeMoney.currencyCode === "string" && !!maybeMoney.currencyCode;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/CartCost.mjs
function CartCost(props) {
  const { cost } = useCart();
  const { amountType = "total", children, ...passthroughProps } = props;
  let amount;
  if (amountType == "total") {
    amount = cost == null ? void 0 : cost.totalAmount;
  } else if (amountType == "subtotal") {
    amount = cost == null ? void 0 : cost.subtotalAmount;
  } else if (amountType == "tax") {
    amount = cost == null ? void 0 : cost.totalTaxAmount;
  } else if (amountType == "duty") {
    amount = cost == null ? void 0 : cost.totalDutyAmount;
  }
  if (amount == null) {
    return null;
  }
  return (0, import_jsx_runtime9.jsx)(Money, { ...passthroughProps, data: amount, children });
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/CartLineProvider.mjs
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react18 = __toESM(require_react(), 1);
var CartLineContext = (0, import_react18.createContext)(null);
function useCartLine() {
  const context = (0, import_react18.useContext)(CartLineContext);
  if (context == null) {
    throw new Error("Expected a cart line context but none was found");
  }
  return context;
}
function CartLineProvider({
  children,
  line
}) {
  return (0, import_jsx_runtime10.jsx)(CartLineContext.Provider, { value: line, children });
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/CartLineQuantity.mjs
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
function CartLineQuantity(props) {
  const cartLine = useCartLine();
  const { as, ...passthroughProps } = props;
  const Wrapper = as ? as : "span";
  return (0, import_jsx_runtime11.jsx)(Wrapper, { ...passthroughProps, children: cartLine.quantity });
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/CartLineQuantityAdjustButton.mjs
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react19 = __toESM(require_react(), 1);
function CartLineQuantityAdjustButton(props) {
  const { status, linesRemove, linesUpdate } = useCart();
  const cartLine = useCartLine();
  const { children, adjust, onClick, ...passthroughProps } = props;
  const handleAdjust = (0, import_react19.useCallback)(() => {
    if (adjust === "remove") {
      linesRemove([(cartLine == null ? void 0 : cartLine.id) ?? ""]);
      return;
    }
    const quantity = adjust === "decrease" ? ((cartLine == null ? void 0 : cartLine.quantity) ?? 0) - 1 : ((cartLine == null ? void 0 : cartLine.quantity) ?? 0) + 1;
    if (quantity <= 0) {
      linesRemove([(cartLine == null ? void 0 : cartLine.id) ?? ""]);
      return;
    }
    const lineUpdate = {
      id: (cartLine == null ? void 0 : cartLine.id) ?? "",
      quantity,
      attributes: (cartLine == null ? void 0 : cartLine.attributes) ?? []
    };
    linesUpdate([lineUpdate]);
  }, [
    adjust,
    cartLine == null ? void 0 : cartLine.attributes,
    cartLine == null ? void 0 : cartLine.id,
    cartLine == null ? void 0 : cartLine.quantity,
    linesRemove,
    linesUpdate
  ]);
  const disabledAttr = passthroughProps.disabled;
  return (0, import_jsx_runtime12.jsx)(
    BaseButton,
    {
      ...passthroughProps,
      onClick,
      defaultOnClick: handleAdjust,
      disabled: typeof disabledAttr !== "undefined" ? disabledAttr : status !== "idle",
      children
    }
  );
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/codegen.helpers.mjs
var storefrontApiCustomScalars = {
  // Keep in sync with the definitions in the app/nextjs/codegen.ts!
  DateTime: "string",
  Decimal: "string",
  HTML: "string",
  URL: "string",
  Color: "string",
  UnsignedInt64: "string"
};
var customerAccountApiCustomScalars = {
  DateTime: "string",
  Decimal: "string",
  HTML: "string",
  ISO8601DateTime: "string",
  URL: "string",
  UnsignedInt64: "string"
};

// node_modules/@shopify/hydrogen-react/dist/browser-dev/ExternalVideo.mjs
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react20 = __toESM(require_react(), 1);
var ExternalVideo = (0, import_react20.forwardRef)(
  (props, ref) => {
    const {
      data,
      options,
      id = data.id,
      frameBorder = "0",
      allow = "accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture",
      allowFullScreen = true,
      loading = "lazy",
      ...passthroughProps
    } = props;
    if (!data.embedUrl) {
      throw new Error(`<ExternalVideo/> requires the 'embedUrl' property`);
    }
    let finalUrl = data.embedUrl;
    if (options) {
      const urlObject = new URL(data.embedUrl);
      for (const [key, value] of Object.entries(options)) {
        if (typeof value === "undefined") {
          continue;
        }
        urlObject.searchParams.set(key, value.toString());
      }
      finalUrl = urlObject.toString();
    }
    return (0, import_jsx_runtime13.jsx)(
      "iframe",
      {
        ...passthroughProps,
        id: id ?? data.embedUrl,
        title: data.alt ?? data.id ?? "external video",
        frameBorder,
        allow,
        allowFullScreen,
        src: finalUrl,
        loading,
        ref
      }
    );
  }
);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/optionValueDecoder.mjs
var OPTION_VALUE_SEPARATOR = ",";
var V1_CONTROL_CHARS = {
  OPTION: ":",
  END_OF_PREFIX: ",",
  SEQUENCE_GAP: " ",
  RANGE: "-"
};
var isOptionValueCombinationInEncodedVariant = /* @__PURE__ */ (() => {
  const decodedOptionValues = /* @__PURE__ */ new Map();
  return function(targetOptionValueCombination, encodedVariantField) {
    var _a;
    if (targetOptionValueCombination.length === 0) {
      return false;
    }
    if (!decodedOptionValues.has(encodedVariantField)) {
      const decodedOptionValuesSet = /* @__PURE__ */ new Set();
      for (const optionValue of decodeEncodedVariant(encodedVariantField)) {
        decodedOptionValuesSet.add(optionValue.join(OPTION_VALUE_SEPARATOR));
        for (let i2 = 0; i2 < optionValue.length; i2++) {
          decodedOptionValuesSet.add(
            optionValue.slice(0, i2 + 1).join(OPTION_VALUE_SEPARATOR)
          );
        }
      }
      decodedOptionValues.set(encodedVariantField, decodedOptionValuesSet);
    }
    return Boolean(
      (_a = decodedOptionValues.get(encodedVariantField)) == null ? void 0 : _a.has(targetOptionValueCombination.join(OPTION_VALUE_SEPARATOR))
    );
  };
})();
function decodeEncodedVariant(encodedVariantField) {
  if (!encodedVariantField) return [];
  if (encodedVariantField.startsWith("v1_")) {
    return v1Decoder(stripVersion(encodedVariantField));
  }
  throw new Error("Unsupported option value encoding");
}
var stripVersion = (encodedVariantField) => encodedVariantField.replace(/^v1_/, "");
function v1Decoder(encodedVariantField) {
  const tokenizer = /[ :,-]/g;
  let index2 = 0;
  let token;
  const options = [];
  const currentOptionValue = [];
  let depth = 0;
  let rangeStart = null;
  while (token = tokenizer.exec(encodedVariantField)) {
    const operation = token[0];
    const optionValueIndex = Number.parseInt(encodedVariantField.slice(index2, token.index)) || 0;
    if (rangeStart !== null) {
      for (; rangeStart < optionValueIndex; rangeStart++) {
        currentOptionValue[depth] = rangeStart;
        options.push([...currentOptionValue]);
      }
      rangeStart = null;
    }
    currentOptionValue[depth] = optionValueIndex;
    if (operation === V1_CONTROL_CHARS.RANGE) {
      rangeStart = optionValueIndex;
    } else if (operation === V1_CONTROL_CHARS.OPTION) {
      depth++;
    } else {
      if (operation === V1_CONTROL_CHARS.SEQUENCE_GAP || operation === V1_CONTROL_CHARS.END_OF_PREFIX && encodedVariantField[token.index - 1] !== V1_CONTROL_CHARS.END_OF_PREFIX) {
        options.push([...currentOptionValue]);
      }
      if (operation === V1_CONTROL_CHARS.END_OF_PREFIX) {
        currentOptionValue.pop();
        depth--;
      }
    }
    index2 = tokenizer.lastIndex;
  }
  const encodingEndsWithIndex = encodedVariantField.match(/\d+$/g);
  if (encodingEndsWithIndex) {
    const finalValueIndex = parseInt(encodingEndsWithIndex[0]);
    if (rangeStart != null) {
      for (; rangeStart <= finalValueIndex; rangeStart++) {
        currentOptionValue[depth] = rangeStart;
        options.push([...currentOptionValue]);
      }
    } else {
      options.push([finalValueIndex]);
    }
  }
  return options;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/getProductOptions.mjs
function mapProductOptions(options) {
  return Object.assign(
    {},
    ...options.map((option) => {
      return {
        [option.name]: Object.assign(
          {},
          ...(option == null ? void 0 : option.optionValues) ? option.optionValues.map((value, index2) => {
            return { [value.name]: index2 };
          }) : []
        )
      };
    })
  );
}
function mapSelectedProductOptionToObject(options) {
  return Object.assign(
    {},
    ...options.map((key) => {
      return { [key.name]: key.value };
    })
  );
}
function mapSelectedProductOptionToObjectAsString(options) {
  return JSON.stringify(mapSelectedProductOptionToObject(options));
}
function encodeSelectedProductOptionAsKey(selectedOption) {
  if (Array.isArray(selectedOption)) {
    return JSON.stringify(
      Object.assign(
        {},
        ...selectedOption.map((option) => ({ [option.name]: option.value }))
      )
    );
  } else {
    return JSON.stringify(selectedOption);
  }
}
function buildEncodingArrayFromSelectedOptions(selectedOption, productOptionMappings) {
  const encoding = Object.keys(selectedOption).map((key) => {
    return productOptionMappings[key] ? productOptionMappings[key][selectedOption[key]] : null;
  });
  return encoding.filter((code) => code !== null);
}
function mapVariants(variants) {
  return Object.assign(
    {},
    ...variants.map((variant) => {
      const variantKey = encodeSelectedProductOptionAsKey(
        variant.selectedOptions || []
      );
      return { [variantKey]: variant };
    })
  );
}
var PRODUCT_INPUTS = [
  "options",
  "selectedOrFirstAvailableVariant",
  "adjacentVariants"
];
var PRODUCT_INPUTS_EXTRA = [
  "handle",
  "encodedVariantExistence",
  "encodedVariantAvailability"
];
function logErrorAndReturnFalse(key) {
  console.error(
    `[h2:error:getProductOptions] product.${key} is missing. Make sure you query for this field from the Storefront API.`
  );
  return false;
}
function checkProductParam(product, checkAll = false) {
  var _a;
  let validParam = true;
  const productKeys = Object.keys(product);
  (checkAll ? [...PRODUCT_INPUTS, ...PRODUCT_INPUTS_EXTRA] : PRODUCT_INPUTS).forEach((key) => {
    if (!productKeys.includes(key)) {
      validParam = logErrorAndReturnFalse(key);
    }
  });
  if (product.options) {
    const firstOption = product == null ? void 0 : product.options[0];
    if (checkAll && !(firstOption == null ? void 0 : firstOption.name)) {
      validParam = logErrorAndReturnFalse("options.name");
    }
    if ((_a = product == null ? void 0 : product.options[0]) == null ? void 0 : _a.optionValues) {
      let firstOptionValues = product.options[0].optionValues[0];
      if (checkAll && !(firstOptionValues == null ? void 0 : firstOptionValues.name)) {
        validParam = logErrorAndReturnFalse("options.optionValues.name");
      }
      firstOptionValues = product.options[0].optionValues.filter(
        (value) => !!(value == null ? void 0 : value.firstSelectableVariant)
      )[0];
      if (firstOptionValues == null ? void 0 : firstOptionValues.firstSelectableVariant) {
        validParam = checkProductVariantParam(
          firstOptionValues.firstSelectableVariant,
          "options.optionValues.firstSelectableVariant",
          validParam,
          checkAll
        );
      }
    } else {
      validParam = logErrorAndReturnFalse("options.optionValues");
    }
  }
  if (product.selectedOrFirstAvailableVariant) {
    validParam = checkProductVariantParam(
      product.selectedOrFirstAvailableVariant,
      "selectedOrFirstAvailableVariant",
      validParam,
      checkAll
    );
  }
  if (!!product.adjacentVariants && product.adjacentVariants[0]) {
    validParam = checkProductVariantParam(
      product.adjacentVariants[0],
      "adjacentVariants",
      validParam,
      checkAll
    );
  }
  return validParam ? product : {};
}
function checkProductVariantParam(variant, key, currentValidParamState, checkAll) {
  var _a;
  let validParam = currentValidParamState;
  if (checkAll && !((_a = variant.product) == null ? void 0 : _a.handle)) {
    validParam = logErrorAndReturnFalse(`${key}.product.handle`);
  }
  if (variant.selectedOptions) {
    const firstSelectedOption = variant.selectedOptions[0];
    if (!(firstSelectedOption == null ? void 0 : firstSelectedOption.name)) {
      validParam = logErrorAndReturnFalse(`${key}.selectedOptions.name`);
    }
    if (!(firstSelectedOption == null ? void 0 : firstSelectedOption.value)) {
      validParam = logErrorAndReturnFalse(`${key}.selectedOptions.value`);
    }
  } else {
    validParam = logErrorAndReturnFalse(`${key}.selectedOptions`);
  }
  return validParam;
}
function getAdjacentAndFirstAvailableVariants(product) {
  const checkedProduct = checkProductParam(product);
  if (!checkedProduct.options) return [];
  const availableVariants = {};
  checkedProduct.options.map((option) => {
    var _a;
    (_a = option.optionValues) == null ? void 0 : _a.map((value) => {
      if (value.firstSelectableVariant) {
        const variantKey = mapSelectedProductOptionToObjectAsString(
          value.firstSelectableVariant.selectedOptions
        );
        availableVariants[variantKey] = value.firstSelectableVariant;
      }
    });
  });
  checkedProduct.adjacentVariants.map((variant) => {
    const variantKey = mapSelectedProductOptionToObjectAsString(
      variant.selectedOptions
    );
    availableVariants[variantKey] = variant;
  });
  const selectedVariant = checkedProduct.selectedOrFirstAvailableVariant;
  if (selectedVariant) {
    const variantKey = mapSelectedProductOptionToObjectAsString(
      selectedVariant.selectedOptions
    );
    availableVariants[variantKey] = selectedVariant;
  }
  return Object.values(availableVariants);
}
function getProductOptions(product) {
  const checkedProduct = checkProductParam(product, true);
  if (!checkedProduct.options) return [];
  const {
    options,
    selectedOrFirstAvailableVariant: selectedVariant,
    adjacentVariants,
    encodedVariantExistence,
    encodedVariantAvailability,
    handle: productHandle
  } = checkedProduct;
  const selectedOptionKeys = selectedVariant == null ? void 0 : selectedVariant.selectedOptions.map(
    (option) => option.name
  );
  const filteredOptions = options.filter((option) => {
    return selectedOptionKeys && selectedOptionKeys.indexOf(option.name) >= 0;
  });
  const productOptionMappings = mapProductOptions(options);
  const variants = mapVariants(
    selectedVariant ? [selectedVariant, ...adjacentVariants] : adjacentVariants
  );
  const selectedOptions = mapSelectedProductOptionToObject(
    selectedVariant ? selectedVariant.selectedOptions : []
  );
  const productOptions = filteredOptions.map((option, optionIndex) => {
    return {
      ...option,
      optionValues: option.optionValues.map((value) => {
        var _a;
        const targetOptionParams = { ...selectedOptions };
        targetOptionParams[option.name] = value.name;
        const targetKey = encodeSelectedProductOptionAsKey(
          targetOptionParams || []
        );
        const encodingKey = buildEncodingArrayFromSelectedOptions(
          targetOptionParams || [],
          productOptionMappings
        );
        const topDownKey = encodingKey.slice(0, optionIndex + 1);
        const exists = isOptionValueCombinationInEncodedVariant(
          topDownKey,
          encodedVariantExistence || ""
        );
        const available = isOptionValueCombinationInEncodedVariant(
          topDownKey,
          encodedVariantAvailability || ""
        );
        const variant = variants[targetKey] || value.firstSelectableVariant;
        let variantOptionParam = {};
        if (variant) {
          variantOptionParam = mapSelectedProductOptionToObject(
            variant.selectedOptions || []
          );
        }
        const searchParams = new URLSearchParams(variantOptionParam);
        const handle = ((_a = variant == null ? void 0 : variant.product) == null ? void 0 : _a.handle) || productHandle;
        return {
          ...value,
          variant,
          handle,
          variantUriQuery: searchParams.toString(),
          selected: selectedOptions[option.name] === value.name,
          exists,
          available,
          isDifferentProduct: handle !== productHandle
        };
      })
    };
  });
  return productOptions;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/Image.mjs
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);
var React2 = __toESM(require_react(), 1);
var IMAGE_FRAGMENT = `#graphql
  fragment Image on Image {
    altText
    url
    width
    height
  }
`;
var Image = React2.forwardRef(
  ({
    alt,
    aspectRatio,
    crop = "center",
    data,
    decoding = "async",
    height = "auto",
    loader = shopifyLoader,
    loading = "lazy",
    sizes,
    src,
    srcSetOptions = {
      intervals: 15,
      startingWidth: 200,
      incrementSize: 200,
      placeholderWidth: 100
    },
    width = "100%",
    ...passthroughProps
  }, ref) => {
    const normalizedData = React2.useMemo(() => {
      const dataWidth = (data == null ? void 0 : data.width) && (data == null ? void 0 : data.height) ? data == null ? void 0 : data.width : void 0;
      const dataHeight = (data == null ? void 0 : data.width) && (data == null ? void 0 : data.height) ? data == null ? void 0 : data.height : void 0;
      return {
        width: dataWidth,
        height: dataHeight,
        unitsMatch: Boolean(unitsMatch(dataWidth, dataHeight))
      };
    }, [data]);
    const normalizedProps = React2.useMemo(() => {
      const nWidthProp = width || "100%";
      const widthParts = getUnitValueParts(nWidthProp.toString());
      const nWidth = `${widthParts.number}${widthParts.unit}`;
      const autoHeight = height === void 0 || height === null;
      const heightParts = autoHeight ? null : getUnitValueParts(height.toString());
      const fixedHeight = heightParts ? `${heightParts.number}${heightParts.unit}` : "";
      const nHeight = autoHeight ? "auto" : fixedHeight;
      const nSrc = src || (data == null ? void 0 : data.url);
      if (!nSrc) {
        console.warn(
          `No src or data.url provided to Image component.`,
          (passthroughProps == null ? void 0 : passthroughProps.key) || ""
        );
      }
      const nAlt = (data == null ? void 0 : data.altText) && !alt ? data == null ? void 0 : data.altText : alt || "";
      const nAspectRatio = aspectRatio ? aspectRatio : normalizedData.unitsMatch ? [
        getNormalizedFixedUnit(normalizedData.width),
        getNormalizedFixedUnit(normalizedData.height)
      ].join("/") : void 0;
      return {
        width: nWidth,
        height: nHeight,
        src: nSrc,
        alt: nAlt,
        aspectRatio: nAspectRatio
      };
    }, [
      width,
      height,
      src,
      data,
      alt,
      aspectRatio,
      normalizedData,
      passthroughProps == null ? void 0 : passthroughProps.key
    ]);
    const { intervals, startingWidth, incrementSize, placeholderWidth } = srcSetOptions;
    const imageWidths = React2.useMemo(() => {
      return generateImageWidths(
        width,
        intervals,
        startingWidth,
        incrementSize
      );
    }, [width, intervals, startingWidth, incrementSize]);
    const fixedWidth = isFixedWidth(normalizedProps.width);
    if (!sizes && !fixedWidth) {
      console.warn(
        [
          "No sizes prop provided to Image component,",
          "you may be loading unnecessarily large images.",
          `Image used is ${src || (data == null ? void 0 : data.url) || (passthroughProps == null ? void 0 : passthroughProps.key) || "unknown"}`
        ].join(" ")
      );
    }
    if (fixedWidth) {
      return (0, import_jsx_runtime14.jsx)(
        FixedWidthImage,
        {
          aspectRatio,
          crop,
          decoding,
          height,
          imageWidths,
          loader,
          loading,
          normalizedProps,
          passthroughProps,
          ref,
          width,
          data
        }
      );
    } else {
      return (0, import_jsx_runtime14.jsx)(
        FluidImage,
        {
          aspectRatio,
          crop,
          decoding,
          imageWidths,
          loader,
          loading,
          normalizedProps,
          passthroughProps,
          placeholderWidth,
          ref,
          sizes,
          data
        }
      );
    }
  }
);
var FixedWidthImage = React2.forwardRef(
  ({
    aspectRatio,
    crop,
    decoding,
    height,
    imageWidths,
    loader = shopifyLoader,
    loading,
    normalizedProps,
    passthroughProps,
    width,
    data
  }, ref) => {
    const fixed = React2.useMemo(() => {
      const intWidth = getNormalizedFixedUnit(width);
      const intHeight = getNormalizedFixedUnit(height);
      const fixedAspectRatio = aspectRatio ? aspectRatio : unitsMatch(normalizedProps.width, normalizedProps.height) ? [intWidth, intHeight].join("/") : normalizedProps.aspectRatio ? normalizedProps.aspectRatio : void 0;
      const sizesArray = imageWidths === void 0 ? void 0 : generateSizes(imageWidths, fixedAspectRatio, crop, {
        width: (data == null ? void 0 : data.width) ?? void 0,
        height: (data == null ? void 0 : data.height) ?? void 0
      });
      const fixedHeight = intHeight ? intHeight : fixedAspectRatio && intWidth ? intWidth * (parseAspectRatio(fixedAspectRatio) ?? 1) : void 0;
      const srcSet = generateSrcSet(normalizedProps.src, sizesArray, loader);
      const src = loader({
        src: normalizedProps.src,
        width: intWidth,
        height: fixedHeight,
        crop: normalizedProps.height === "auto" ? void 0 : crop
      });
      return {
        width: intWidth,
        aspectRatio: fixedAspectRatio,
        height: fixedHeight,
        srcSet,
        src
      };
    }, [
      aspectRatio,
      crop,
      data,
      height,
      imageWidths,
      loader,
      normalizedProps,
      width
    ]);
    return (0, import_jsx_runtime14.jsx)(
      "img",
      {
        ref,
        alt: normalizedProps.alt,
        decoding,
        height: fixed.height,
        loading,
        src: fixed.src,
        srcSet: fixed.srcSet,
        width: fixed.width,
        style: {
          aspectRatio: fixed.aspectRatio,
          ...passthroughProps.style
        },
        ...passthroughProps
      }
    );
  }
);
var FluidImage = React2.forwardRef(
  ({
    crop,
    decoding,
    imageWidths,
    loader = shopifyLoader,
    loading,
    normalizedProps,
    passthroughProps,
    placeholderWidth,
    sizes,
    data
  }, ref) => {
    const fluid = React2.useMemo(() => {
      const sizesArray = imageWidths === void 0 ? void 0 : generateSizes(imageWidths, normalizedProps.aspectRatio, crop, {
        width: (data == null ? void 0 : data.width) ?? void 0,
        height: (data == null ? void 0 : data.height) ?? void 0
      });
      const placeholderHeight = normalizedProps.aspectRatio && placeholderWidth ? placeholderWidth * (parseAspectRatio(normalizedProps.aspectRatio) ?? 1) : void 0;
      const srcSet = generateSrcSet(normalizedProps.src, sizesArray, loader);
      const src = loader({
        src: normalizedProps.src,
        width: placeholderWidth,
        height: placeholderHeight,
        crop
      });
      return {
        placeholderHeight,
        srcSet,
        src
      };
    }, [crop, data, imageWidths, loader, normalizedProps, placeholderWidth]);
    return (0, import_jsx_runtime14.jsx)(
      "img",
      {
        ref,
        alt: normalizedProps.alt,
        decoding,
        height: fluid.placeholderHeight,
        loading,
        sizes,
        src: fluid.src,
        srcSet: fluid.srcSet,
        width: placeholderWidth,
        ...passthroughProps,
        style: {
          width: normalizedProps.width,
          aspectRatio: normalizedProps.aspectRatio,
          ...passthroughProps.style
        }
      }
    );
  }
);
var PLACEHOLDER_DOMAIN = "https://placeholder.shopify.com";
function shopifyLoader({ src, width, height, crop }) {
  if (!src) {
    return "";
  }
  const url = new URL(src, PLACEHOLDER_DOMAIN);
  if (width) {
    url.searchParams.append("width", Math.round(width).toString());
  }
  if (height) {
    url.searchParams.append("height", Math.round(height).toString());
  }
  if (crop) {
    url.searchParams.append("crop", crop);
  }
  return url.href.replace(PLACEHOLDER_DOMAIN, "");
}
function unitsMatch(width = "100%", height = "auto") {
  return getUnitValueParts(width.toString()).unit === getUnitValueParts(height.toString()).unit;
}
function getUnitValueParts(value) {
  const unit = value.replace(/[0-9.]/g, "");
  const number = parseFloat(value.replace(unit, ""));
  return {
    unit: unit === "" ? number === void 0 ? "auto" : "px" : unit,
    number
  };
}
function getNormalizedFixedUnit(value) {
  if (value === void 0) {
    return;
  }
  const { unit, number } = getUnitValueParts(value.toString());
  switch (unit) {
    case "em":
      return number * 16;
    case "rem":
      return number * 16;
    case "px":
      return number;
    case "":
      return number;
    default:
      return;
  }
}
function isFixedWidth(width) {
  const fixedEndings = /\d(px|em|rem)$/;
  return typeof width === "number" || fixedEndings.test(width);
}
function generateSrcSet(src, sizesArray, loader = shopifyLoader) {
  if (!src) {
    return "";
  }
  if ((sizesArray == null ? void 0 : sizesArray.length) === 0 || !sizesArray) {
    return src;
  }
  return sizesArray.map(
    (size, i2) => `${loader({
      src,
      width: size.width,
      height: size.height,
      crop: size.crop
    })} ${sizesArray.length === 3 ? `${i2 + 1}x` : `${size.width ?? 0}w`}`
  ).join(`, `);
}
function generateImageWidths(width = "100%", intervals, startingWidth, incrementSize) {
  const responsive = Array.from(
    { length: intervals },
    (_, i2) => i2 * incrementSize + startingWidth
  );
  const fixed = Array.from(
    { length: 3 },
    (_, i2) => (i2 + 1) * (getNormalizedFixedUnit(width) ?? 0)
  );
  return isFixedWidth(width) ? fixed : responsive;
}
function parseAspectRatio(aspectRatio) {
  if (!aspectRatio) return;
  const [width, height] = aspectRatio.split("/");
  return 1 / (Number(width) / Number(height));
}
function generateSizes(imageWidths, aspectRatio, crop = "center", sourceDimensions) {
  if (!imageWidths) return;
  return imageWidths.map((width) => {
    return {
      width,
      height: aspectRatio ? width * (parseAspectRatio(aspectRatio) ?? 1) : void 0,
      crop
    };
  }).filter(({ width, height }) => {
    if ((sourceDimensions == null ? void 0 : sourceDimensions.width) && width > sourceDimensions.width) {
      return false;
    }
    if ((sourceDimensions == null ? void 0 : sourceDimensions.height) && height && height > sourceDimensions.height) {
      return false;
    }
    return true;
  });
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/load-script.mjs
var import_react21 = __toESM(require_react(), 1);
var SCRIPTS_LOADED = {};
function loadScript(src, options) {
  const isScriptLoaded = SCRIPTS_LOADED[src];
  if (isScriptLoaded) {
    return isScriptLoaded;
  }
  const promise = new Promise((resolve, reject) => {
    const script = document.createElement("script");
    if (options == null ? void 0 : options.module) {
      script.type = "module";
    } else {
      script.type = "text/javascript";
    }
    script.src = src;
    script.onload = () => {
      resolve(true);
    };
    script.onerror = () => {
      reject(false);
    };
    if ((options == null ? void 0 : options.in) === "head") {
      document.head.appendChild(script);
    } else {
      document.body.appendChild(script);
    }
    const attributes = options == null ? void 0 : options.attributes;
    if (attributes) {
      Object.keys(attributes).forEach((key) => {
        script.setAttribute(key, attributes[key]);
      });
    }
  });
  SCRIPTS_LOADED[src] = promise;
  return promise;
}
function useLoadScript(url, options) {
  const [status, setStatus] = (0, import_react21.useState)("loading");
  (0, import_react21.useEffect)(
    () => {
      loadScript(url, options).then(() => setStatus("done")).catch(() => setStatus("error"));
    },
    // Ignore options changes since it won't trigger a new load.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [url]
  );
  return status;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/MediaFile.mjs
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/Video.mjs
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react22 = __toESM(require_react(), 1);
var Video = (0, import_react22.forwardRef)((props, ref) => {
  var _a;
  const {
    data,
    previewImageOptions,
    id = data.id,
    playsInline = true,
    controls = true,
    sourceProps = {},
    ...passthroughProps
  } = props;
  const posterUrl = shopifyLoader({
    src: ((_a = data.previewImage) == null ? void 0 : _a.url) ?? "",
    ...previewImageOptions
  });
  if (!data.sources) {
    throw new Error(`<Video/> requires a 'data.sources' array`);
  }
  return (
    // eslint-disable-next-line jsx-a11y/media-has-caption
    (0, import_jsx_runtime15.jsx)(
      "video",
      {
        ...passthroughProps,
        id,
        playsInline,
        controls,
        poster: posterUrl,
        ref,
        children: data.sources.map((source) => {
          if (!((source == null ? void 0 : source.url) && (source == null ? void 0 : source.mimeType))) {
            throw new Error(`<Video/> needs 'source.url' and 'source.mimeType'`);
          }
          return (0, import_react22.createElement)(
            "source",
            {
              ...sourceProps,
              key: source.url,
              src: source.url,
              type: source.mimeType
            }
          );
        })
      }
    )
  );
});

// node_modules/@shopify/hydrogen-react/dist/browser-dev/ModelViewer.mjs
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react23 = __toESM(require_react(), 1);
function ModelViewer(props) {
  var _a, _b, _c;
  const [modelViewer, setModelViewer] = (0, import_react23.useState)(
    void 0
  );
  const callbackRef = (0, import_react23.useCallback)((node) => {
    setModelViewer(node);
  }, []);
  const { data, children, className, ...passthroughProps } = props;
  const modelViewerLoadedStatus = useLoadScript(
    "https://unpkg.com/@google/model-viewer@v1.12.1/dist/model-viewer.min.js",
    {
      module: true
    }
  );
  (0, import_react23.useEffect)(() => {
    const hydrogenEventListener = {
      error: passthroughProps.onError,
      load: passthroughProps.onLoad,
      preload: passthroughProps.onPreload,
      "model-visibility": passthroughProps.onModelVisibility,
      progress: passthroughProps.onProgress,
      "ar-status": passthroughProps.onArStatus,
      "ar-tracking": passthroughProps.onArTracking,
      "quick-look-button-tapped": passthroughProps.onQuickLookButtonTapped,
      "camera-change": passthroughProps.onCameraChange,
      "environment-change": passthroughProps.onEnvironmentChange,
      play: passthroughProps.onPlay,
      pause: passthroughProps.onPause,
      "scene-graph-ready": passthroughProps.onSceneGraphReady
    };
    if (!modelViewer) {
      return;
    }
    Object.entries(hydrogenEventListener).forEach(
      ([eventName, callbackFunc]) => {
        if (callbackFunc) {
          modelViewer.addEventListener(eventName, callbackFunc);
        }
      }
    );
    return () => {
      if (modelViewer == null) {
        return;
      }
      Object.entries(hydrogenEventListener).forEach(
        ([eventName, callbackFunc]) => {
          if (callbackFunc) {
            modelViewer.removeEventListener(eventName, callbackFunc);
          }
        }
      );
    };
  }, [
    modelViewer,
    passthroughProps.onArStatus,
    passthroughProps.onArTracking,
    passthroughProps.onCameraChange,
    passthroughProps.onEnvironmentChange,
    passthroughProps.onError,
    passthroughProps.onLoad,
    passthroughProps.onModelVisibility,
    passthroughProps.onPause,
    passthroughProps.onPlay,
    passthroughProps.onPreload,
    passthroughProps.onProgress,
    passthroughProps.onQuickLookButtonTapped,
    passthroughProps.onSceneGraphReady
  ]);
  if (modelViewerLoadedStatus !== "done") {
    return null;
  }
  if (!((_b = (_a = data.sources) == null ? void 0 : _a[0]) == null ? void 0 : _b.url)) {
    const sourcesUrlError = `<ModelViewer/> requires 'data.sources' prop to be an array, with an object that has a property 'url' on it. Rendering 'null'`;
    {
      throw new Error(sourcesUrlError);
    }
  }
  if (!data.alt) {
    console.warn(
      `<ModelViewer/> requires the 'data.alt' prop for accessibility`
    );
  }
  return (0, import_jsx_runtime16.jsx)(
    "model-viewer",
    {
      ref: callbackRef,
      ...passthroughProps,
      class: className,
      id: passthroughProps.id ?? data.id,
      src: data.sources[0].url,
      alt: data.alt ?? null,
      "camera-controls": passthroughProps.cameraControls ?? true,
      poster: (passthroughProps.poster || ((_c = data.previewImage) == null ? void 0 : _c.url)) ?? null,
      autoplay: passthroughProps.autoplay ?? true,
      loading: passthroughProps.loading,
      reveal: passthroughProps.reveal,
      ar: passthroughProps.ar,
      "ar-modes": passthroughProps.arModes,
      "ar-scale": passthroughProps.arScale,
      "ar-placement": passthroughProps.arPlacement,
      "ios-src": passthroughProps.iosSrc,
      "touch-action": passthroughProps.touchAction,
      "disable-zoom": passthroughProps.disableZoom,
      "orbit-sensitivity": passthroughProps.orbitSensitivity,
      "auto-rotate": passthroughProps.autoRotate,
      "auto-rotate-delay": passthroughProps.autoRotateDelay,
      "rotation-per-second": passthroughProps.rotationPerSecond,
      "interaction-policy": passthroughProps.interactionPolicy,
      "interaction-prompt": passthroughProps.interactionPrompt,
      "interaction-prompt-style": passthroughProps.interactionPromptStyle,
      "interaction-prompt-threshold": passthroughProps.interactionPromptThreshold,
      "camera-orbit": passthroughProps.cameraOrbit,
      "camera-target": passthroughProps.cameraTarget,
      "field-of-view": passthroughProps.fieldOfView,
      "max-camera-orbit": passthroughProps.maxCameraOrbit,
      "min-camera-orbit": passthroughProps.minCameraOrbit,
      "max-field-of-view": passthroughProps.maxFieldOfView,
      "min-field-of-view": passthroughProps.minFieldOfView,
      bounds: passthroughProps.bounds,
      "interpolation-decay": passthroughProps.interpolationDecay ?? 100,
      "skybox-image": passthroughProps.skyboxImage,
      "environment-image": passthroughProps.environmentImage,
      exposure: passthroughProps.exposure,
      "shadow-intensity": passthroughProps.shadowIntensity ?? 0,
      "shadow-softness": passthroughProps.shadowSoftness ?? 0,
      "animation-name": passthroughProps.animationName,
      "animation-crossfade-duration": passthroughProps.animationCrossfadeDuration,
      "variant-name": passthroughProps.variantName,
      orientation: passthroughProps.orientation,
      scale: passthroughProps.scale,
      children
    }
  );
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/MediaFile.mjs
function MediaFile({
  data,
  mediaOptions,
  ...passthroughProps
}) {
  switch (data.__typename) {
    case "MediaImage": {
      if (!data.image) {
        const noDataImage = `<MediaFile/>: 'data.image' does not exist for __typename of 'MediaImage'; rendering 'null' by default.`;
        {
          throw new Error(noDataImage);
        }
      }
      return (0, import_jsx_runtime17.jsx)(
        Image,
        {
          ...passthroughProps,
          ...mediaOptions == null ? void 0 : mediaOptions.image,
          data: data.image
        }
      );
    }
    case "Video": {
      return (0, import_jsx_runtime17.jsx)(Video, { ...passthroughProps, ...mediaOptions == null ? void 0 : mediaOptions.video, data });
    }
    case "ExternalVideo": {
      return (0, import_jsx_runtime17.jsx)(
        ExternalVideo,
        {
          ...passthroughProps,
          ...mediaOptions == null ? void 0 : mediaOptions.externalVideo,
          data
        }
      );
    }
    case "Model3d": {
      return (
        // @ts-expect-error There are issues with the inferred HTML attribute types here for ModelViewer (and contentEditable), but I think that's a little bit beyond me at the moment
        (0, import_jsx_runtime17.jsx)(
          ModelViewer,
          {
            ...passthroughProps,
            ...mediaOptions == null ? void 0 : mediaOptions.modelViewer,
            data
          }
        )
      );
    }
    default: {
      const typenameMissingMessage = `<MediaFile /> requires the '__typename' property to exist on the 'data' prop in order to render the matching sub-component for this type of media.`;
      {
        throw new Error(typenameMissingMessage);
      }
    }
  }
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/parse-metafield.mjs
function parseMetafield(metafield) {
  if (!metafield.type) {
    const noTypeError = `parseMetafield(): The 'type' field is required in order to parse the Metafield.`;
    {
      throw new Error(noTypeError);
    }
  }
  switch (metafield.type) {
    case "boolean":
      return {
        ...metafield,
        parsedValue: metafield.value === "true"
      };
    case "collection_reference":
    case "file_reference":
    case "page_reference":
    case "product_reference":
    case "variant_reference":
      return {
        ...metafield,
        parsedValue: metafield.reference
      };
    case "color":
    case "multi_line_text_field":
    case "single_line_text_field":
    case "url":
      return {
        ...metafield,
        parsedValue: metafield.value
      };
    // TODO: 'money' should probably be parsed even further to like `useMoney()`, but that logic needs to be extracted first so it's not a hook
    case "money": {
      let parsedValue = null;
      try {
        const parsed = parseJSON(metafield.value ?? "");
        if (parsed && typeof parsed === "object" && "currency_code" in parsed) {
          const moneyData = parsed;
          parsedValue = {
            amount: moneyData.amount,
            currencyCode: moneyData.currency_code
          };
        } else if (parsed && typeof parsed === "object" && "currencyCode" in parsed) {
          parsedValue = parsed;
        } else {
          parsedValue = parsed;
        }
      } catch (err) {
        const parseError = `parseMetafield(): attempted to JSON.parse the 'metafield.value' property, but failed.`;
        {
          throw new Error(parseError);
        }
      }
      return {
        ...metafield,
        parsedValue
      };
    }
    case "dimension":
    case "json":
    case "rating":
    case "volume":
    case "weight":
    case "rich_text_field":
    case "list.color":
    case "list.dimension":
    case "list.number_integer":
    case "list.number_decimal":
    case "list.rating":
    case "list.single_line_text_field":
    case "list.url":
    case "list.volume":
    case "list.weight": {
      let parsedValue = null;
      try {
        parsedValue = parseJSON(metafield.value ?? "");
      } catch (err) {
        const parseError = `parseMetafield(): attempted to JSON.parse the 'metafield.value' property, but failed.`;
        {
          throw new Error(parseError);
        }
      }
      return {
        ...metafield,
        parsedValue
      };
    }
    case "date":
    case "date_time":
      return {
        ...metafield,
        parsedValue: new Date(metafield.value ?? "")
      };
    case "list.date":
    case "list.date_time": {
      const jsonParseValue = parseJSON((metafield == null ? void 0 : metafield.value) ?? "");
      return {
        ...metafield,
        parsedValue: jsonParseValue.map((dateString) => new Date(dateString))
      };
    }
    case "number_decimal":
    case "number_integer":
      return {
        ...metafield,
        parsedValue: Number(metafield.value)
      };
    case "list.collection_reference":
    case "list.file_reference":
    case "list.page_reference":
    case "list.product_reference":
    case "list.variant_reference":
      return {
        ...metafield,
        parsedValue: flattenConnection(metafield.references ?? void 0)
      };
    default: {
      const typeNotFoundError = `parseMetafield(): the 'metafield.type' you passed in is not supported. Your type: "${metafield.type}". If you believe this is an error, please open an issue on GitHub.`;
      {
        throw new Error(typeNotFoundError);
      }
    }
  }
}
function parseJSON(json) {
  if (String(json).includes("__proto__")) {
    return JSON.parse(json, (k, v2) => {
      if (k !== "__proto__") return v2;
    });
  }
  return JSON.parse(json);
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/ProductPrice.mjs
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
function ProductPrice(props) {
  var _a, _b, _c, _d, _e, _f;
  const {
    priceType = "regular",
    variantId,
    valueType = "min",
    data: product,
    ...passthroughProps
  } = props;
  if (product == null) {
    throw new Error(`<ProductPrice/> requires a product as the 'data' prop`);
  }
  let price;
  let measurement;
  const variant = variantId ? flattenConnection((product == null ? void 0 : product.variants) ?? {}).find(
    (variant2) => (variant2 == null ? void 0 : variant2.id) === variantId
  ) ?? null : null;
  const variantPriceProperty = valueType === "max" ? "maxVariantPrice" : "minVariantPrice";
  if (priceType === "compareAt") {
    if (variantId && variant) {
      price = variant.compareAtPrice;
    } else {
      price = (_a = product == null ? void 0 : product.compareAtPriceRange) == null ? void 0 : _a[variantPriceProperty];
    }
    let priceAsNumber;
    if (variantId && variant) {
      priceAsNumber = parseFloat(((_b = variant.price) == null ? void 0 : _b.amount) ?? "0");
    } else {
      priceAsNumber = parseFloat(
        ((_d = (_c = product == null ? void 0 : product.priceRange) == null ? void 0 : _c[variantPriceProperty]) == null ? void 0 : _d.amount) ?? "0"
      );
    }
    const compareAtPriceAsNumber = parseFloat((price == null ? void 0 : price.amount) ?? "0");
    if (priceAsNumber >= compareAtPriceAsNumber) {
      return null;
    }
  } else {
    if (variantId && variant) {
      price = variant.price;
      if (valueType === "unit") {
        price = variant.unitPrice;
        measurement = variant.unitPriceMeasurement;
      }
    } else if (valueType === "max") {
      price = (_e = product.priceRange) == null ? void 0 : _e.maxVariantPrice;
    } else {
      price = (_f = product.priceRange) == null ? void 0 : _f.minVariantPrice;
    }
  }
  if (!price) {
    return null;
  }
  if (measurement) {
    return (0, import_jsx_runtime18.jsx)(Money, { ...passthroughProps, data: price, measurement });
  }
  return (0, import_jsx_runtime18.jsx)(Money, { ...passthroughProps, data: price });
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/RichText.mjs
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_react25 = __toESM(require_react(), 1);

// node_modules/@shopify/hydrogen-react/dist/browser-dev/RichText.components.mjs
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react24 = __toESM(require_react(), 1);
var RichTextComponents = {
  root: Root,
  heading: Heading,
  paragraph: Paragraph,
  text: Text,
  link: RichTextLink,
  list: List,
  "list-item": ListItem
};
function Root({
  node
}) {
  return (0, import_jsx_runtime19.jsx)("div", { children: node.children });
}
function Heading({
  node
}) {
  return (0, import_react24.createElement)(`h${node.level ?? "1"}`, null, node.children);
}
function Paragraph({
  node
}) {
  return (0, import_jsx_runtime19.jsx)("p", { children: node.children });
}
function Text({
  node
}) {
  if (node.bold && node.italic)
    return (0, import_jsx_runtime19.jsx)("em", { children: (0, import_jsx_runtime19.jsx)("strong", { children: node.value }) });
  if (node.bold) return (0, import_jsx_runtime19.jsx)("strong", { children: node.value });
  if (node.italic) return (0, import_jsx_runtime19.jsx)("em", { children: node.value });
  return node.value;
}
function RichTextLink({
  node
}) {
  return (0, import_jsx_runtime19.jsx)("a", { href: node.url, title: node.title, target: node.target, children: node.children });
}
function List({
  node
}) {
  const List2 = node.listType === "unordered" ? "ul" : "ol";
  return (0, import_jsx_runtime19.jsx)(List2, { children: node.children });
}
function ListItem({
  node
}) {
  return (0, import_jsx_runtime19.jsx)("li", { children: node.children });
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/RichText.mjs
function RichText({
  as,
  data,
  plain,
  components,
  ...passthroughProps
}) {
  try {
    const Wrapper = as ?? "div";
    const parsedData = (0, import_react25.useMemo)(
      () => JSON.parse(data),
      [data]
    );
    return (0, import_jsx_runtime20.jsx)(Wrapper, { ...passthroughProps, children: plain ? richTextToString(parsedData) : serializeRichTextASTNode(components, parsedData) });
  } catch (e2) {
    throw new Error(
      "[h2:error:RichText] Parsing error. Make sure to pass a JSON string of rich text metafield",
      {
        cause: e2
      }
    );
  }
}
function serializeRichTextASTNode(components = {}, node, index2 = 0) {
  let children;
  if ("children" in node) {
    children = node.children.map(
      (child, childIndex) => serializeRichTextASTNode(components, child, childIndex)
    );
  }
  const Component = components[node.type === "list-item" ? "listItem" : node.type] ?? RichTextComponents[node.type];
  switch (node.type) {
    case "root":
      return (0, import_react25.createElement)(
        Component,
        {
          key: index2,
          node: {
            type: "root",
            children
          }
        }
      );
    case "heading":
      return (0, import_react25.createElement)(
        Component,
        {
          key: index2,
          node: {
            type: "heading",
            level: node.level,
            children
          }
        }
      );
    case "paragraph":
      return (0, import_react25.createElement)(
        Component,
        {
          key: index2,
          node: {
            type: "paragraph",
            children
          }
        }
      );
    case "text": {
      const elements = (node.value ?? "").split("\n").flatMap((value, subindex) => {
        const key = `${index2}-${value}-${subindex}`;
        const textElement = (0, import_react25.createElement)(
          Component,
          {
            key,
            node: {
              type: "text",
              italic: node.italic,
              bold: node.bold,
              value
            }
          }
        );
        return subindex === 0 ? textElement : [(0, import_react25.createElement)("br", { key: `${key}-br` }), textElement];
      });
      return elements.length > 1 ? (0, import_react25.createElement)(import_react25.Fragment, { key: index2 }, elements) : elements[0];
    }
    case "link":
      return (0, import_react25.createElement)(
        Component,
        {
          key: index2,
          node: {
            type: "link",
            url: node.url,
            title: node.title,
            target: node.target,
            children
          }
        }
      );
    case "list":
      return (0, import_react25.createElement)(
        Component,
        {
          key: index2,
          node: {
            type: "list",
            listType: node.listType,
            children
          }
        }
      );
    case "list-item":
      return (0, import_react25.createElement)(
        Component,
        {
          key: index2,
          node: {
            type: "list-item",
            children
          }
        }
      );
  }
}
function richTextToString(node, result = []) {
  switch (node.type) {
    case "root":
      node.children.forEach((child) => richTextToString(child, result));
      break;
    case "heading":
    case "paragraph":
      node.children.forEach((child) => richTextToString(child, result));
      result.push(" ");
      break;
    case "text":
      result.push(node.value || "");
      break;
    case "link":
      node.children.forEach((child) => richTextToString(child, result));
      break;
    case "list":
      node.children.forEach((item) => {
        if (item.children) {
          item.children.forEach((child) => richTextToString(child, result));
        }
        result.push(" ");
      });
      break;
    default:
      throw new Error(`Unknown node encountered ${node.type}`);
  }
  return result.join("").trim();
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/ShopPayButton.mjs
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var SHOPJS_URL = "https://cdn.shopify.com/shopifycloud/shop-js/v1.0/client.js";
function isChannel(channel) {
  return channel === "headless" || channel === "hydrogen";
}
function ShopPayButton({
  channel,
  variantIds,
  className,
  variantIdsAndQuantities,
  width,
  storeDomain: _storeDomain
}) {
  const shop = useShop();
  const storeDomain = _storeDomain || (shop == null ? void 0 : shop.storeDomain);
  const shopPayLoadedStatus = useLoadScript(SHOPJS_URL);
  let ids = [];
  let channelAttribution;
  if (!storeDomain || storeDomain === defaultShopifyContext.storeDomain) {
    throw new Error(MissingStoreDomainErrorMessage);
  }
  if (variantIds && variantIdsAndQuantities) {
    throw new Error(DoublePropsErrorMessage);
  }
  if (!variantIds && !variantIdsAndQuantities) {
    throw new Error(MissingPropsErrorMessage);
  }
  if (channel) {
    if (isChannel(channel)) {
      channelAttribution = channel;
    } else {
      throw new Error(InvalidChannelErrorMessage);
    }
  }
  if (variantIds) {
    ids = variantIds.reduce((prev, curr) => {
      const bareId = parseGid(curr).id;
      if (bareId) {
        prev.push(bareId);
      }
      return prev;
    }, []);
  } else if (variantIdsAndQuantities) {
    ids = variantIdsAndQuantities.reduce((prev, curr) => {
      const bareId = parseGid(curr == null ? void 0 : curr.id).id;
      if (bareId) {
        prev.push(`${bareId}:${(curr == null ? void 0 : curr.quantity) ?? 1}`);
      }
      return prev;
    }, []);
  } else {
    throw new Error(MissingPropsErrorMessage);
  }
  if (ids.length === 0) {
    throw new Error(InvalidPropsErrorMessage);
  }
  const style = width ? {
    "--shop-pay-button-width": width
  } : void 0;
  return (0, import_jsx_runtime21.jsx)("div", { className, style, children: shopPayLoadedStatus === "done" && (0, import_jsx_runtime21.jsx)(
    "shop-pay-button",
    {
      ...channelAttribution ? { channel: channelAttribution } : {},
      "store-url": storeDomain,
      variants: ids.join(",")
    }
  ) });
}
var MissingStoreDomainErrorMessage = 'You must pass a "storeDomain" prop to the "ShopPayButton" component, or wrap it in a "ShopifyProvider" component.';
var InvalidPropsErrorMessage = `You must pass in "variantIds" in the form of ["gid://shopify/ProductVariant/1"]`;
var MissingPropsErrorMessage = `You must pass in either "variantIds" or "variantIdsAndQuantities" to ShopPayButton`;
var DoublePropsErrorMessage = `You must provide either a variantIds or variantIdsAndQuantities prop, but not both in the ShopPayButton component`;
var InvalidChannelErrorMessage = `Invalid channel attribution value. Must be either "headless" or "hydrogen"`;

// node_modules/@shopify/hydrogen-react/dist/browser-dev/useSelectedOptionInUrlParam.mjs
var import_react26 = __toESM(require_react(), 1);
function useSelectedOptionInUrlParam(selectedOptions) {
  (0, import_react26.useEffect)(() => {
    const optionsSearchParams = new URLSearchParams(
      mapSelectedProductOptionToObject(selectedOptions || [])
    );
    const currentSearchParams = new URLSearchParams(window.location.search);
    const combinedSearchParams = new URLSearchParams({
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      ...Object.fromEntries(currentSearchParams),
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      ...Object.fromEntries(optionsSearchParams)
    });
    if (combinedSearchParams.size > 0) {
      window.history.replaceState(
        {},
        "",
        `${window.location.pathname}?${combinedSearchParams.toString()}`
      );
    }
  }, [JSON.stringify(selectedOptions)]);
  return null;
}

// node_modules/@shopify/hydrogen-react/dist/browser-dev/useShopifyCookies.mjs
var import_react27 = __toESM(require_react(), 1);
var longTermLength = 60 * 60 * 24 * 360 * 1;
var shortTermLength = 60 * 30;
function useShopifyCookies(options) {
  const {
    hasUserConsent = false,
    domain = "",
    checkoutDomain = ""
  } = options || {};
  (0, import_react27.useEffect)(() => {
    const cookies = getShopifyCookies(document.cookie);
    let currentDomain = domain || window.document.location.host;
    if (checkoutDomain) {
      const checkoutDomainParts = checkoutDomain.split(".").reverse();
      const currentDomainParts = currentDomain.split(".").reverse();
      const sameDomainParts = [];
      checkoutDomainParts.forEach((part, index2) => {
        if (part === currentDomainParts[index2]) {
          sameDomainParts.push(part);
        }
      });
      currentDomain = sameDomainParts.reverse().join(".");
    }
    if (/^localhost/.test(currentDomain)) currentDomain = "";
    const domainWithLeadingDot = currentDomain ? /^\./.test(currentDomain) ? currentDomain : `.${currentDomain}` : "";
    if (hasUserConsent) {
      setCookie(
        SHOPIFY_Y,
        cookies[SHOPIFY_Y] || buildUUID(),
        longTermLength,
        domainWithLeadingDot
      );
      setCookie(
        SHOPIFY_S,
        cookies[SHOPIFY_S] || buildUUID(),
        shortTermLength,
        domainWithLeadingDot
      );
    } else {
      setCookie(SHOPIFY_Y, "", 0, domainWithLeadingDot);
      setCookie(SHOPIFY_S, "", 0, domainWithLeadingDot);
    }
  }, [options, hasUserConsent, domain, checkoutDomain]);
}
function setCookie(name, value, maxage, domain) {
  document.cookie = l2(name, value, {
    maxage,
    domain,
    samesite: "Lax",
    path: "/"
  });
}

export {
  flattenConnection,
  createStorefrontClient,
  ShopifyProvider,
  useShop,
  SHOPIFY_STOREFRONT_ID_HEADER,
  SHOPIFY_STOREFRONT_Y_HEADER,
  SHOPIFY_STOREFRONT_S_HEADER,
  SHOPIFY_Y,
  SHOPIFY_S,
  u2 as u,
  l2 as l,
  getShopifyCookies,
  useCart,
  CartProvider,
  ProductProvider,
  useProduct,
  AddToCartButton,
  AnalyticsEventName,
  AnalyticsPageType,
  ShopifySalesChannel,
  parseGid,
  sendShopifyAnalytics,
  getClientBrowserParameters,
  BuyNowButton,
  CartCheckoutButton,
  useMoney,
  Money,
  CartCost,
  useCartLine,
  CartLineProvider,
  CartLineQuantity,
  CartLineQuantityAdjustButton,
  storefrontApiCustomScalars,
  customerAccountApiCustomScalars,
  ExternalVideo,
  isOptionValueCombinationInEncodedVariant,
  decodeEncodedVariant,
  mapSelectedProductOptionToObject,
  getAdjacentAndFirstAvailableVariants,
  getProductOptions,
  IMAGE_FRAGMENT,
  Image,
  useLoadScript,
  Video,
  ModelViewer,
  MediaFile,
  parseMetafield,
  ProductPrice,
  RichText,
  ShopPayButton,
  useSelectedOptionInUrlParam,
  useShopifyCookies
};
/*! Bundled license information:

@xstate/fsm/es/index.mjs:
  (*! *****************************************************************************
  Copyright (c) Microsoft Corporation.
  
  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.
  
  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** *)

use-sync-external-store/cjs/use-sync-external-store-shim.production.min.mjs:
  (**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim.development.mjs:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.production.min.mjs:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.mjs:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-KPM2TY7I.js.map
