import {
  BREAK,
  Kind,
  OperationTypeNode,
  print,
  visit
} from "./chunk-E2WS5KGY.js";
import {
  require_cjs
} from "./chunk-PN6YRIKN.js";
import {
  __publicField,
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/@apollo/client/core/ApolloClient.js
var import_rxjs8 = __toESM(require_cjs(), 1);

// node_modules/@apollo/client/invariantErrorCodes.js
var errorCodes = {
  1: {
    file: "@apollo/client/utilities/internal/checkDocument.js",
    condition: 'doc && doc.kind === "Document"',
    message: `Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql`
  },
  2: {
    file: "@apollo/client/utilities/internal/checkDocument.js",
    message: `Schema type definitions not allowed in queries. Found: "%s"`
  },
  3: {
    file: "@apollo/client/utilities/internal/checkDocument.js",
    condition: "operations.length <= 1",
    message: `Ambiguous GraphQL document: contains %s operations`
  },
  4: {
    file: "@apollo/client/utilities/internal/checkDocument.js",
    condition: "operations.length == 1 && operations[0].operation === expectedType",
    message: `Running a %s requires a graphql %s, but a %s was used instead.`
  },
  5: {
    file: "@apollo/client/utilities/internal/checkDocument.js",
    message: '`%s` is a forbidden field alias name in the selection set for field `%s` in %s "%s".'
  },
  6: {
    file: "@apollo/client/utilities/internal/getFragmentDefinition.js",
    condition: 'doc.kind === "Document"',
    message: `Expecting a parsed GraphQL document. Perhaps you need to wrap the query string in a "gql" tag? http://docs.apollostack.com/apollo-client/core.html#gql`
  },
  7: {
    file: "@apollo/client/utilities/internal/getFragmentDefinition.js",
    condition: "doc.definitions.length <= 1",
    message: "Fragment must have exactly one definition."
  },
  8: {
    file: "@apollo/client/utilities/internal/getFragmentDefinition.js",
    condition: 'fragmentDef.kind === "FragmentDefinition"',
    message: "Must be a fragment definition."
  },
  9: {
    file: "@apollo/client/utilities/internal/getFragmentFromSelection.js",
    condition: "fragment",
    message: `No fragment named %s`
  },
  10: {
    file: "@apollo/client/utilities/internal/getFragmentQueryDocument.js",
    message: `Found a %s operation%s. No operations are allowed when using a fragment as a query. Only fragments are allowed.`
  },
  11: {
    file: "@apollo/client/utilities/internal/getFragmentQueryDocument.js",
    condition: "fragments.length === 1",
    message: `Found %s fragments. \`fragmentName\` must be provided when there is not exactly 1 fragment.`
  },
  12: {
    file: "@apollo/client/utilities/internal/getMainDefinition.js",
    message: "Expected a parsed GraphQL query with a query, mutation, subscription, or a fragment."
  },
  13: {
    file: "@apollo/client/utilities/internal/getQueryDefinition.js",
    condition: 'queryDef && queryDef.operation === "query"',
    message: "Must contain a query definition."
  },
  15: {
    file: "@apollo/client/utilities/internal/shouldInclude.js",
    condition: "evaledValue !== void 0",
    message: `Invalid variable referenced in @%s directive.`
  },
  16: {
    file: "@apollo/client/utilities/internal/shouldInclude.js",
    condition: "directiveArguments && directiveArguments.length === 1",
    message: `Incorrect number of arguments for the @%s directive.`
  },
  17: {
    file: "@apollo/client/utilities/internal/shouldInclude.js",
    condition: 'ifArgument.name && ifArgument.name.value === "if"',
    message: `Invalid argument for the @%s directive.`
  },
  18: {
    file: "@apollo/client/utilities/internal/shouldInclude.js",
    condition: 'ifValue &&\n    (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue")',
    message: `Argument for the @%s directive must be a variable or a boolean value.`
  },
  19: {
    file: "@apollo/client/utilities/internal/valueToObjectRepresentation.js",
    message: `The inline argument "%s" of kind "%s"is not supported. Use variables instead of inline arguments to overcome this limitation.`
  },
  20: {
    file: "@apollo/client/utilities/graphql/DocumentTransform.js",
    condition: "Array.isArray(cacheKeys)",
    message: "`getCacheKey` must return an array or undefined"
  },
  21: {
    file: "@apollo/client/testing/core/mocking/mockLink.js",
    condition: "max > min",
    message: "realisticDelay: `min` must be less than `max`"
  },
  22: {
    file: "@apollo/client/testing/core/mocking/mockLink.js",
    condition: "queryWithoutClientOnlyDirectives",
    message: "query is required"
  },
  23: {
    file: "@apollo/client/testing/core/mocking/mockLink.js",
    condition: "serverQuery",
    message: "Cannot mock a client-only query. Mocked responses should contain at least one non-client field."
  },
  24: {
    file: "@apollo/client/testing/core/mocking/mockLink.js",
    condition: "(mock.maxUsageCount ?? 1) > 0",
    message: "Mocked response `maxUsageCount` must be greater than 0. Given %s"
  },
  25: {
    file: "@apollo/client/react/ssr/prerenderStatic.js",
    condition: "renderCount <= maxRerenders",
    message: `Exceeded maximum rerender count of %d.
This either means you have very deep \`useQuery\` waterfalls in your application
and need to increase the \`maxRerender\` option to \`prerenderStatic\`, or that
you have an infinite render loop in your application.`
  },
  26: {
    file: "@apollo/client/react/ssr/prerenderStatic.js",
    condition: "!signal?.aborted",
    message: "The operation was aborted before it could be attempted."
  },
  27: {
    file: "@apollo/client/react/internal/cache/QueryReference.js",
    condition: "!queryRef || QUERY_REFERENCE_SYMBOL in queryRef",
    message: "Expected a QueryRef object, but got something else instead."
  },
  28: {
    file: "@apollo/client/react/hooks/useApolloClient.js",
    condition: "!!client",
    message: 'Could not find "client" in the context or passed in as an option. Wrap the root component in an <ApolloProvider>, or pass an ApolloClient instance in via options.'
  },
  29: {
    file: "@apollo/client/react/hooks/useLazyQuery.js",
    condition: "resultRef.current",
    message: "useLazyQuery: '%s' cannot be called before executing the query."
  },
  30: {
    file: "@apollo/client/react/hooks/useLazyQuery.js",
    condition: "!calledDuringRender()",
    message: "useLazyQuery: 'execute' should not be called during render. To start a query during render, use the 'useQuery' hook."
  },
  31: {
    file: "@apollo/client/react/hooks/useLoadableQuery.js",
    condition: "!calledDuringRender()",
    message: "useLoadableQuery: 'loadQuery' should not be called during render. To start a query during render, use the 'useBackgroundQuery' hook."
  },
  32: {
    file: "@apollo/client/react/hooks/useLoadableQuery.js",
    condition: "internalQueryRef",
    message: "The query has not been loaded. Please load the query."
  },
  33: {
    file: "@apollo/client/react/hooks/useSubscription.js",
    condition: "!optionsRef.current.skip",
    message: "A subscription that is skipped cannot be restarted."
  },
  35: {
    file: "@apollo/client/react/hooks/internal/validateSuspenseHookOptions.js",
    condition: "supportedFetchPolicies.includes(fetchPolicy)",
    message: `The fetch policy \`%s\` is not supported with suspense.`
  },
  37: {
    file: "@apollo/client/react/context/ApolloContext.js",
    condition: '"createContext" in React',
    message: 'Invoking `getApolloContext` in an environment where `React.createContext` is not available.\nThe Apollo Client functionality you are trying to use is only available in React Client Components.\nPlease make sure to add "use client" at the top of your file.\nFor more information, see https://nextjs.org/docs/getting-started/react-essentials#client-components'
  },
  38: {
    file: "@apollo/client/react/context/ApolloProvider.js",
    condition: "context.client",
    message: 'ApolloProvider was not passed a client instance. Make sure you pass in your client via the "client" prop.'
  },
  39: {
    file: "@apollo/client/masking/maskDefinition.js",
    condition: "fragment",
    message: "Could not find fragment with name '%s'."
  },
  41: {
    file: "@apollo/client/masking/maskFragment.js",
    condition: "fragments.length === 1",
    message: `Found %s fragments. \`fragmentName\` must be provided when there is not exactly 1 fragment.`
  },
  42: {
    file: "@apollo/client/masking/maskFragment.js",
    condition: "!!fragment",
    message: `Could not find fragment with name "%s".`
  },
  43: {
    file: "@apollo/client/masking/maskOperation.js",
    condition: "definition",
    message: "Expected a parsed GraphQL document with a query, mutation, or subscription."
  },
  47: {
    file: "@apollo/client/local-state/LocalState.js",
    condition: 'hasDirectives(["client"], document)',
    message: "Expected document to contain `@client` fields."
  },
  48: {
    file: "@apollo/client/local-state/LocalState.js",
    condition: 'hasDirectives(["client"], document)',
    message: "Expected document to contain `@client` fields."
  },
  49: {
    file: "@apollo/client/local-state/LocalState.js",
    condition: "fragment",
    message: "No fragment named %s"
  },
  53: {
    file: "@apollo/client/local-state/LocalState.js",
    message: "Could not resolve __typename on object %o returned from resolver '%s'. '__typename' needs to be returned to properly resolve child fields."
  },
  54: {
    file: "@apollo/client/local-state/LocalState.js",
    condition: "fragment",
    message: `No fragment named %s`
  },
  55: {
    file: "@apollo/client/local-state/LocalState.js",
    condition: "cache.fragmentMatches",
    message: "The configured cache does not support fragment matching which will lead to incorrect results when executing local resolvers. Please use a cache that implements `fragmetMatches`."
  },
  57: {
    file: "@apollo/client/link/persisted-queries/index.js",
    condition: 'options &&\n    (typeof options.sha256 === "function" ||\n        typeof options.generateHash === "function")',
    message: 'Missing/invalid "sha256" or "generateHash" function. Please configure one using the "createPersistedQueryLink(options)" options parameter.'
  },
  58: {
    file: "@apollo/client/link/persisted-queries/index.js",
    condition: "forward",
    message: "PersistedQueryLink cannot be the last link in the chain."
  },
  59: {
    file: "@apollo/client/link/http/checkFetcher.js",
    condition: 'fetcher || typeof fetch !== "undefined"',
    message: `
"fetch" has not been found globally and no fetcher has been configured. To fix this, install a fetch package (like https://www.npmjs.com/package/cross-fetch), instantiate the fetcher, and pass it into your HttpLink constructor. For example:

import fetch from 'cross-fetch';
import { ApolloClient, HttpLink } from '@apollo/client';
const client = new ApolloClient({
  link: new HttpLink({ uri: '/graphql', fetch })
});
    `
  },
  60: {
    file: "@apollo/client/link/http/parseAndCheckHttpResponse.js",
    condition: 'response.body && typeof response.body.getReader === "function"',
    message: "Unknown type for `response.body`. Please use a `fetch` implementation that is WhatWG-compliant and that uses WhatWG ReadableStreams for `body`."
  },
  63: {
    file: "@apollo/client/link/core/ApolloLink.js",
    message: "request is not implemented"
  },
  64: {
    file: "@apollo/client/incremental/handlers/notImplemented.js",
    condition: '!hasDirectives(["defer"], request.query)',
    message: "`@defer` is not supported without specifying an incremental handler. Please pass a handler as the `incrementalHandler` option to the `ApolloClient` constructor."
  },
  65: {
    file: "@apollo/client/core/ApolloClient.js",
    condition: "options.cache",
    message: "To initialize Apollo Client, you must specify a 'cache' property in the options object. \nFor more information, please visit: https://go.apollo.dev/c/docs"
  },
  66: {
    file: "@apollo/client/core/ApolloClient.js",
    condition: "options.link",
    message: "To initialize Apollo Client, you must specify a 'link' property in the options object. \nFor more information, please visit: https://go.apollo.dev/c/docs"
  },
  67: {
    file: "@apollo/client/core/ApolloClient.js",
    condition: 'options.fetchPolicy !== "cache-and-network"',
    message: "The cache-and-network fetchPolicy does not work with client.query, because client.query can only return a single result. Please use client.watchQuery to receive multiple results from the cache and the network, or consider using a different fetchPolicy, such as cache-first or network-only."
  },
  68: {
    file: "@apollo/client/core/ApolloClient.js",
    condition: 'options.fetchPolicy !== "standby"',
    message: "The standby fetchPolicy does not work with client.query, because standby does not fetch. Consider using a different fetchPolicy, such as cache-first or network-only."
  },
  69: {
    file: "@apollo/client/core/ApolloClient.js",
    condition: "options.query",
    message: "query option is required. You must specify your GraphQL document in the query option."
  },
  70: {
    file: "@apollo/client/core/ApolloClient.js",
    condition: 'options.query.kind === "Document"',
    message: 'You must wrap the query string in a "gql" tag.'
  },
  71: {
    file: "@apollo/client/core/ApolloClient.js",
    condition: "!options.returnPartialData",
    message: "returnPartialData option only supported on watchQuery."
  },
  72: {
    file: "@apollo/client/core/ApolloClient.js",
    condition: "!options.pollInterval",
    message: "pollInterval option only supported on watchQuery."
  },
  73: {
    file: "@apollo/client/core/ApolloClient.js",
    condition: "!options.notifyOnNetworkStatusChange",
    message: "notifyOnNetworkStatusChange option only supported on watchQuery."
  },
  74: {
    file: "@apollo/client/core/ApolloClient.js",
    condition: "optionsWithDefaults.mutation",
    message: "The `mutation` option is required. Please provide a GraphQL document in the `mutation` option."
  },
  75: {
    file: "@apollo/client/core/ApolloClient.js",
    condition: 'optionsWithDefaults.fetchPolicy === "network-only" ||\n    optionsWithDefaults.fetchPolicy === "no-cache"',
    message: "Mutations only support 'network-only' or 'no-cache' fetch policies. The default 'network-only' behavior automatically writes mutation results to the cache. Passing 'no-cache' skips the cache write."
  },
  78: {
    file: "@apollo/client/core/ObservableQuery.js",
    condition: 'this.options.fetchPolicy !== "cache-only"',
    message: "Cannot execute `fetchMore` for 'cache-only' query '%s'. Please use a different fetch policy."
  },
  79: {
    file: "@apollo/client/core/ObservableQuery.js",
    condition: "updateQuery",
    message: "You must provide an `updateQuery` function when using `fetchMore` with a `no-cache` fetch policy."
  },
  83: {
    file: "@apollo/client/core/QueryManager.js",
    message: "QueryManager stopped while query was in flight"
  },
  84: {
    file: "@apollo/client/core/QueryManager.js",
    condition: "this.localState",
    message: "Mutation '%s' contains `@client` fields with variables provided by `@export` but local state has not been configured."
  },
  85: {
    file: "@apollo/client/core/QueryManager.js",
    message: "Store reset while query was in flight (not completed in link chain)"
  },
  88: {
    file: "@apollo/client/core/QueryManager.js",
    condition: "!this.getDocumentInfo(query).hasClientExports || this.localState",
    message: "Subscription '%s' contains `@client` fields with variables provided by `@export` but local state has not been configured."
  },
  89: {
    file: "@apollo/client/core/QueryManager.js",
    condition: "this.localState",
    message: "%s '%s' contains `@client` fields but local state has not been configured."
  },
  90: {
    file: "@apollo/client/core/QueryManager.js",
    condition: "!hasIncrementalDirective",
    message: "%s '%s' contains `@client` and `@defer` directives. These cannot be used together."
  },
  91: {
    file: "@apollo/client/core/QueryManager.js",
    condition: "this.localState",
    message: "Query '%s' contains `@client` fields with variables provided by `@export` but local state has not been configured."
  },
  93: {
    file: "@apollo/client/core/QueryManager.js",
    condition: "this.localState",
    message: "Query '%s' contains `@client` fields but local state has not been configured."
  },
  94: {
    file: "@apollo/client/core/QueryManager.js",
    condition: "didEmitValue",
    message: "The link chain completed without emitting a value. This is likely unintentional and should be updated to emit a value before completing."
  },
  95: {
    file: "@apollo/client/cache/inmemory/entityStore.js",
    condition: 'typeof dataId === "string"',
    message: "store.merge expects a string ID"
  },
  98: {
    file: "@apollo/client/cache/inmemory/key-extractor.js",
    condition: "extracted !== void 0",
    message: `Missing field '%s' while extracting keyFields from %s`
  },
  99: {
    file: "@apollo/client/cache/inmemory/policies.js",
    condition: "!old || old === which",
    message: `Cannot change root %s __typename more than once`
  },
  102: {
    file: "@apollo/client/cache/inmemory/policies.js",
    message: "Cannot automatically merge arrays"
  },
  103: {
    file: "@apollo/client/cache/inmemory/readFromStore.js",
    message: `No fragment named %s`
  },
  104: {
    file: "@apollo/client/cache/inmemory/readFromStore.js",
    condition: "!isReference(value)",
    message: `Missing selection set for object of type %s returned for query field %s`
  },
  105: {
    file: "@apollo/client/cache/inmemory/writeToStore.js",
    message: `Could not identify object %s`
  },
  107: {
    file: "@apollo/client/cache/inmemory/writeToStore.js",
    message: `No fragment named %s`
  }
};
var devDebug = {
  76: {
    file: "@apollo/client/core/ApolloClient.js",
    message: `In client.refetchQueries, Promise.all promise rejected with error %o`
  },
  82: {
    file: "@apollo/client/core/ObservableQuery.js",
    message: `Missing cache result fields: %o`
  }
};
var devLog = {};
var devWarn = {
  36: {
    file: "@apollo/client/react/hooks/internal/validateSuspenseHookOptions.js",
    message: "Using `returnPartialData` with a `no-cache` fetch policy has no effect. To read partial data from the cache, consider using an alternate fetch policy."
  },
  40: {
    file: "@apollo/client/masking/maskDefinition.js",
    message: "Accessing unmasked field on %s at path '%s'. This field will not be available when masking is enabled. Please read the field from the fragment instead."
  },
  44: {
    file: "@apollo/client/masking/utils.js",
    message: "@unmask 'mode' argument does not support variables."
  },
  45: {
    file: "@apollo/client/masking/utils.js",
    message: "@unmask 'mode' argument must be of type string."
  },
  46: {
    file: "@apollo/client/masking/utils.js",
    message: "@unmask 'mode' argument does not recognize value '%s'."
  },
  50: {
    file: "@apollo/client/local-state/LocalState.js",
    message: "The '%s' resolver returned `undefined` instead of a value. This is likely a bug in the resolver. If you didn't mean to return a value, return `null` instead."
  },
  51: {
    file: "@apollo/client/local-state/LocalState.js",
    message: "The '%s' field had no cached value and only forced resolvers were run. The value was set to `null`."
  },
  52: {
    file: "@apollo/client/local-state/LocalState.js",
    message: "The '%s' field on object %o returned `undefined` instead of a value. The parent resolver did not include the property in the returned value and there was no resolver defined for the field."
  },
  56: {
    file: "@apollo/client/link/ws/index.js",
    message: "`WebSocketLink` uses the deprecated and unmaintained `subscriptions-transport-ws` library. This link is no longer maintained and will be removed in a future major version of Apollo Client. We recommend switching to `GraphQLWsLink` which uses the `graphql-ws` library to send GraphQL operations through WebSocket connections (https://the-guild.dev/graphql/ws)."
  },
  61: {
    file: "@apollo/client/link/core/ApolloLink.js",
    message: "[ApolloLink.split]: The test function returned a non-boolean value which could result in subtle bugs (e.g. such as using an `async` function which always returns a truthy value). Got `%o`."
  },
  62: {
    file: "@apollo/client/link/core/ApolloLink.js",
    message: "The terminating link provided to `ApolloLink.execute` called `forward` instead of handling the request. This results in an observable that immediately completes and does not emit a value. Please provide a terminating link that properly handles the request.\n\nIf you are using a split link, ensure each branch contains a terminating link that handles the request."
  },
  77: {
    file: "@apollo/client/core/ObservableQuery.js",
    message: `Called refetch(%o) for query %o, which does not declare a $variables variable.
Did you mean to call refetch(variables) instead of refetch({ variables })?`
  },
  81: {
    file: "@apollo/client/core/ObservableQuery.js",
    message: "Cannot poll on 'cache-only' query '%s' and as such, polling is disabled. Please use a different fetch policy."
  },
  86: {
    file: "@apollo/client/core/QueryManager.js",
    message: `Unknown query named "%s" requested in refetchQueries options.include array`
  },
  87: {
    file: "@apollo/client/core/QueryManager.js",
    message: `Unknown anonymous query requested in refetchQueries options.include array`
  },
  92: {
    file: "@apollo/client/core/QueryManager.js",
    message: '[%s]: Fragments masked by data masking are inaccessible when using fetch policy "no-cache". Please add `@unmask` to each fragment spread to access the data.'
  },
  96: {
    file: "@apollo/client/cache/inmemory/entityStore.js",
    message: "cache.modify: You are trying to write a Reference that is not part of the store: %o\nPlease make sure to set the `mergeIntoStore` parameter to `true` when creating a Reference that is not part of the store yet:\n`toReference(object, true)`"
  },
  97: {
    file: "@apollo/client/cache/inmemory/entityStore.js",
    message: "cache.modify: Writing an array with a mix of both References and Objects will not result in the Objects being normalized correctly.\nPlease convert the object instance %o to a Reference before writing it to the cache by calling `toReference(object, true)`."
  },
  100: {
    file: "@apollo/client/cache/inmemory/policies.js",
    message: `Inferring subtype %s of supertype %s`
  },
  101: {
    file: "@apollo/client/cache/inmemory/policies.js",
    message: `Undefined 'from' passed to readField with arguments %s`
  },
  108: {
    file: "@apollo/client/cache/inmemory/writeToStore.js",
    message: `Cache data may be lost when replacing the %s field of a %s object.

This could cause additional (usually avoidable) network requests to fetch data that were otherwise cached.

To address this problem (which is not a bug in Apollo Client), %sdefine a custom merge function for the %s field, so InMemoryCache can safely merge these objects:

  existing: %o
  incoming: %o

For more information about these options, please refer to the documentation:

  * Ensuring entity objects have IDs: https://go.apollo.dev/c/generating-unique-identifiers
  * Defining custom merge functions: https://go.apollo.dev/c/merging-non-normalized-objects
`
  },
  109: {
    file: "@apollo/client/cache/core/cache.js",
    message: "Could not identify object passed to `from` for '%s' fragment, either because the object is non-normalized or the key fields are missing. If you are masking this object, please ensure the key fields are requested by the parent object."
  }
};
var devError = {
  14: {
    file: "@apollo/client/utilities/internal/removeDirectivesFromDocument.js",
    message: `Could not find operation or fragment`
  },
  34: {
    file: "@apollo/client/react/hooks/useSyncExternalStore.js",
    message: "The result of getSnapshot should be cached to avoid an infinite loop"
  },
  80: {
    file: "@apollo/client/core/ObservableQuery.js",
    message: "Unhandled GraphQL subscription error"
  },
  106: {
    file: "@apollo/client/cache/inmemory/writeToStore.js",
    message: `Missing field '%s' while writing result %o`
  }
};

// node_modules/@apollo/client/utilities/internal/globals/maybe.js
function maybe(thunk) {
  try {
    return thunk();
  } catch {
  }
}

// node_modules/@apollo/client/utilities/internal/globals/global.js
var global_default = (
  // We don't expect the Function constructor ever to be invoked at runtime, as
  // long as at least one of globalThis, window, self, or global is defined, so
  // we are under no obligation to make it easy for static analysis tools to
  // detect syntactic usage of the Function constructor. If you think you can
  maybe(() => globalThis) || maybe(() => window) || maybe(() => self) || maybe(() => global) || // improve your static analysis to detect this obfuscation, think again. This
  // is an arms race you cannot win, at least not in JavaScript.
  maybe(function() {
    return maybe.constructor("return this")();
  })
);

// node_modules/@apollo/client/version.js
var version = "4.0.9";
var build = "esm";

// node_modules/@apollo/client/dev/symbol.js
var ApolloErrorMessageHandler = Symbol.for("ApolloErrorMessageHandler_" + version);

// node_modules/@apollo/client/dev/setErrorMessageHandler.js
function setErrorMessageHandler(handler2) {
  global_default[ApolloErrorMessageHandler] = handler2;
}

// node_modules/@apollo/client/dev/loadErrorMessageHandler.js
function loadErrorMessageHandler(...errorCodes2) {
  setErrorMessageHandler(handler);
  for (const codes of errorCodes2) {
    Object.assign(handler, codes);
  }
  return handler;
}
var handler = (message, args) => {
  if (typeof message === "number") {
    const definition = global_default[ApolloErrorMessageHandler][message];
    if (!message || !(definition == null ? void 0 : definition.message))
      return;
    message = definition.message;
  }
  return args.reduce((msg, arg) => msg.replace(/%[sdfo]/, String(arg)), String(message));
};

// node_modules/@apollo/client/dev/loadDevMessages.js
function loadDevMessages() {
  loadErrorMessageHandler(devDebug, devError, devLog, devWarn);
}

// node_modules/@apollo/client/dev/loadErrorMessages.js
function loadErrorMessages() {
  loadErrorMessageHandler(errorCodes);
}

// node_modules/@apollo/client/utilities/environment/index.development.js
var __DEV__ = true;

// node_modules/@apollo/client/utilities/internal/makeUniqueId.js
var prefixCounts = /* @__PURE__ */ new Map();
function makeUniqueId(prefix) {
  const count = prefixCounts.get(prefix) || 1;
  prefixCounts.set(prefix, count + 1);
  return `${prefix}:${count}:${Math.random().toString(36).slice(2)}`;
}

// node_modules/@apollo/client/utilities/internal/stringifyForDisplay.js
function stringifyForDisplay(value, space = 0) {
  const undefId = makeUniqueId("stringifyForDisplay");
  return JSON.stringify(value, (_, value2) => {
    return value2 === void 0 ? undefId : value2;
  }, space).split(JSON.stringify(undefId)).join("<undefined>");
}

// node_modules/@apollo/client/utilities/invariant/index.js
var genericMessage = "Invariant Violation";
var InvariantError = class _InvariantError extends Error {
  constructor(message = genericMessage) {
    super(message);
    this.name = genericMessage;
    Object.setPrototypeOf(this, _InvariantError.prototype);
  }
};
var verbosityLevels = ["debug", "log", "warn", "error", "silent"];
var verbosityLevel = verbosityLevels.indexOf(__DEV__ ? "log" : "silent");
function invariant(condition, ...args) {
  if (!condition) {
    throw newInvariantError(...args);
  }
}
function wrapConsoleMethod(name) {
  return function(message, ...args) {
    if (verbosityLevels.indexOf(name) >= verbosityLevel) {
      const method = console[name] || console.log;
      if (typeof message === "number") {
        const arg0 = message;
        message = getHandledErrorMsg(arg0);
        if (!message) {
          message = getFallbackErrorMsg(arg0, args);
          args = [];
        }
      }
      method(message, ...args);
    }
  };
}
invariant.debug = wrapConsoleMethod("debug");
invariant.log = wrapConsoleMethod("log");
invariant.warn = wrapConsoleMethod("warn");
invariant.error = wrapConsoleMethod("error");
function setVerbosity(level) {
  const old = verbosityLevels[verbosityLevel];
  verbosityLevel = Math.max(0, verbosityLevels.indexOf(level));
  return old;
}
function newInvariantError(message, ...optionalParams) {
  return new InvariantError(getHandledErrorMsg(message, optionalParams) || getFallbackErrorMsg(message, optionalParams));
}
var ApolloErrorMessageHandler2 = Symbol.for("ApolloErrorMessageHandler_" + version);
function stringify(arg) {
  if (typeof arg == "string") {
    return arg;
  }
  try {
    return stringifyForDisplay(arg, 2).slice(0, 1e3);
  } catch {
    return "<non-serializable>";
  }
}
function getHandledErrorMsg(message, messageArgs = []) {
  if (!message)
    return;
  return global_default[ApolloErrorMessageHandler2] && global_default[ApolloErrorMessageHandler2](message, messageArgs.map(stringify));
}
function getFallbackErrorMsg(message, messageArgs = []) {
  if (!message)
    return;
  if (typeof message === "string") {
    return messageArgs.reduce((msg, arg) => msg.replace(/%[sdfo]/, stringify(arg)), message);
  }
  return `An error occurred! For more details, see the full error text at https://go.apollo.dev/c/err#${encodeURIComponent(JSON.stringify({
    version,
    message,
    args: messageArgs.map(stringify)
  }))}`;
}

// node_modules/@apollo/client/utilities/invariant/index.development.js
var invariant2 = (() => {
  loadDevMessages();
  loadErrorMessages();
  return invariant;
})();

// node_modules/@apollo/client/utilities/internal/valueToObjectRepresentation.js
function valueToObjectRepresentation(argObj, name, value, variables) {
  if (value.kind === Kind.INT || value.kind === Kind.FLOAT) {
    argObj[name.value] = Number(value.value);
  } else if (value.kind === Kind.BOOLEAN || value.kind === Kind.STRING) {
    argObj[name.value] = value.value;
  } else if (value.kind === Kind.OBJECT) {
    const nestedArgObj = {};
    value.fields.map((obj) => valueToObjectRepresentation(nestedArgObj, obj.name, obj.value, variables));
    argObj[name.value] = nestedArgObj;
  } else if (value.kind === Kind.VARIABLE) {
    const variableValue = (variables || {})[value.name.value];
    argObj[name.value] = variableValue;
  } else if (value.kind === Kind.LIST) {
    argObj[name.value] = value.values.map((listValue) => {
      const nestedArgArrayObj = {};
      valueToObjectRepresentation(nestedArgArrayObj, name, listValue, variables);
      return nestedArgArrayObj[name.value];
    });
  } else if (value.kind === Kind.ENUM) {
    argObj[name.value] = value.value;
  } else if (value.kind === Kind.NULL) {
    argObj[name.value] = null;
  } else {
    throw newInvariantError(19, name.value, value.kind);
  }
}

// node_modules/@apollo/client/utilities/internal/argumentsObjectFromField.js
function argumentsObjectFromField(field, variables) {
  if (field.arguments && field.arguments.length) {
    const argObj = {};
    field.arguments.forEach(({ name, value }) => valueToObjectRepresentation(argObj, name, value, variables));
    return argObj;
  }
  return null;
}

// node_modules/@apollo/client/utilities/internal/canUseDOM.js
var canUseDOM = typeof maybe(() => window.document.createElement) === "function";

// node_modules/@wry/caches/lib/strong.js
function defaultDispose() {
}
var StrongCache = class {
  constructor(max = Infinity, dispose = defaultDispose) {
    this.max = max;
    this.dispose = dispose;
    this.map = /* @__PURE__ */ new Map();
    this.newest = null;
    this.oldest = null;
  }
  has(key) {
    return this.map.has(key);
  }
  get(key) {
    const node = this.getNode(key);
    return node && node.value;
  }
  get size() {
    return this.map.size;
  }
  getNode(key) {
    const node = this.map.get(key);
    if (node && node !== this.newest) {
      const { older, newer } = node;
      if (newer) {
        newer.older = older;
      }
      if (older) {
        older.newer = newer;
      }
      node.older = this.newest;
      node.older.newer = node;
      node.newer = null;
      this.newest = node;
      if (node === this.oldest) {
        this.oldest = newer;
      }
    }
    return node;
  }
  set(key, value) {
    let node = this.getNode(key);
    if (node) {
      return node.value = value;
    }
    node = {
      key,
      value,
      newer: null,
      older: this.newest
    };
    if (this.newest) {
      this.newest.newer = node;
    }
    this.newest = node;
    this.oldest = this.oldest || node;
    this.map.set(key, node);
    return node.value;
  }
  clean() {
    while (this.oldest && this.map.size > this.max) {
      this.delete(this.oldest.key);
    }
  }
  delete(key) {
    const node = this.map.get(key);
    if (node) {
      if (node === this.newest) {
        this.newest = node.older;
      }
      if (node === this.oldest) {
        this.oldest = node.newer;
      }
      if (node.newer) {
        node.newer.older = node.older;
      }
      if (node.older) {
        node.older.newer = node.newer;
      }
      this.map.delete(key);
      this.dispose(node.value, key);
      return true;
    }
    return false;
  }
};

// node_modules/@wry/caches/lib/weak.js
function noop() {
}
var defaultDispose2 = noop;
var _WeakRef = typeof WeakRef !== "undefined" ? WeakRef : function(value) {
  return { deref: () => value };
};
var _WeakMap = typeof WeakMap !== "undefined" ? WeakMap : Map;
var _FinalizationRegistry = typeof FinalizationRegistry !== "undefined" ? FinalizationRegistry : function() {
  return {
    register: noop,
    unregister: noop
  };
};
var finalizationBatchSize = 10024;
var WeakCache = class {
  constructor(max = Infinity, dispose = defaultDispose2) {
    this.max = max;
    this.dispose = dispose;
    this.map = new _WeakMap();
    this.newest = null;
    this.oldest = null;
    this.unfinalizedNodes = /* @__PURE__ */ new Set();
    this.finalizationScheduled = false;
    this.size = 0;
    this.finalize = () => {
      const iterator = this.unfinalizedNodes.values();
      for (let i = 0; i < finalizationBatchSize; i++) {
        const node = iterator.next().value;
        if (!node)
          break;
        this.unfinalizedNodes.delete(node);
        const key = node.key;
        delete node.key;
        node.keyRef = new _WeakRef(key);
        this.registry.register(key, node, node);
      }
      if (this.unfinalizedNodes.size > 0) {
        queueMicrotask(this.finalize);
      } else {
        this.finalizationScheduled = false;
      }
    };
    this.registry = new _FinalizationRegistry(this.deleteNode.bind(this));
  }
  has(key) {
    return this.map.has(key);
  }
  get(key) {
    const node = this.getNode(key);
    return node && node.value;
  }
  getNode(key) {
    const node = this.map.get(key);
    if (node && node !== this.newest) {
      const { older, newer } = node;
      if (newer) {
        newer.older = older;
      }
      if (older) {
        older.newer = newer;
      }
      node.older = this.newest;
      node.older.newer = node;
      node.newer = null;
      this.newest = node;
      if (node === this.oldest) {
        this.oldest = newer;
      }
    }
    return node;
  }
  set(key, value) {
    let node = this.getNode(key);
    if (node) {
      return node.value = value;
    }
    node = {
      key,
      value,
      newer: null,
      older: this.newest
    };
    if (this.newest) {
      this.newest.newer = node;
    }
    this.newest = node;
    this.oldest = this.oldest || node;
    this.scheduleFinalization(node);
    this.map.set(key, node);
    this.size++;
    return node.value;
  }
  clean() {
    while (this.oldest && this.size > this.max) {
      this.deleteNode(this.oldest);
    }
  }
  deleteNode(node) {
    if (node === this.newest) {
      this.newest = node.older;
    }
    if (node === this.oldest) {
      this.oldest = node.newer;
    }
    if (node.newer) {
      node.newer.older = node.older;
    }
    if (node.older) {
      node.older.newer = node.newer;
    }
    this.size--;
    const key = node.key || node.keyRef && node.keyRef.deref();
    this.dispose(node.value, key);
    if (!node.keyRef) {
      this.unfinalizedNodes.delete(node);
    } else {
      this.registry.unregister(node);
    }
    if (key)
      this.map.delete(key);
  }
  delete(key) {
    const node = this.map.get(key);
    if (node) {
      this.deleteNode(node);
      return true;
    }
    return false;
  }
  scheduleFinalization(node) {
    this.unfinalizedNodes.add(node);
    if (!this.finalizationScheduled) {
      this.finalizationScheduled = true;
      queueMicrotask(this.finalize);
    }
  }
};

// node_modules/@wry/trie/lib/index.js
var defaultMakeData = () => /* @__PURE__ */ Object.create(null);
var { forEach, slice } = Array.prototype;
var { hasOwnProperty } = Object.prototype;
var Trie = class _Trie {
  constructor(weakness = true, makeData = defaultMakeData) {
    this.weakness = weakness;
    this.makeData = makeData;
  }
  lookup() {
    return this.lookupArray(arguments);
  }
  lookupArray(array) {
    let node = this;
    forEach.call(array, (key) => node = node.getChildTrie(key));
    return hasOwnProperty.call(node, "data") ? node.data : node.data = this.makeData(slice.call(array));
  }
  peek() {
    return this.peekArray(arguments);
  }
  peekArray(array) {
    let node = this;
    for (let i = 0, len = array.length; node && i < len; ++i) {
      const map3 = node.mapFor(array[i], false);
      node = map3 && map3.get(array[i]);
    }
    return node && node.data;
  }
  remove() {
    return this.removeArray(arguments);
  }
  removeArray(array) {
    let data;
    if (array.length) {
      const head = array[0];
      const map3 = this.mapFor(head, false);
      const child = map3 && map3.get(head);
      if (child) {
        data = child.removeArray(slice.call(array, 1));
        if (!child.data && !child.weak && !(child.strong && child.strong.size)) {
          map3.delete(head);
        }
      }
    } else {
      data = this.data;
      delete this.data;
    }
    return data;
  }
  getChildTrie(key) {
    const map3 = this.mapFor(key, true);
    let child = map3.get(key);
    if (!child)
      map3.set(key, child = new _Trie(this.weakness, this.makeData));
    return child;
  }
  mapFor(key, create) {
    return this.weakness && isObjRef(key) ? this.weak || (create ? this.weak = /* @__PURE__ */ new WeakMap() : void 0) : this.strong || (create ? this.strong = /* @__PURE__ */ new Map() : void 0);
  }
};
function isObjRef(value) {
  switch (typeof value) {
    case "object":
      if (value === null)
        break;
    // Fall through to return true...
    case "function":
      return true;
  }
  return false;
}

// node_modules/@wry/context/lib/slot.js
var currentContext = null;
var MISSING_VALUE = {};
var idCounter = 1;
var makeSlotClass = () => class Slot {
  constructor() {
    this.id = [
      "slot",
      idCounter++,
      Date.now(),
      Math.random().toString(36).slice(2)
    ].join(":");
  }
  hasValue() {
    for (let context = currentContext; context; context = context.parent) {
      if (this.id in context.slots) {
        const value = context.slots[this.id];
        if (value === MISSING_VALUE)
          break;
        if (context !== currentContext) {
          currentContext.slots[this.id] = value;
        }
        return true;
      }
    }
    if (currentContext) {
      currentContext.slots[this.id] = MISSING_VALUE;
    }
    return false;
  }
  getValue() {
    if (this.hasValue()) {
      return currentContext.slots[this.id];
    }
  }
  withValue(value, callback, args, thisArg) {
    const slots = {
      __proto__: null,
      [this.id]: value
    };
    const parent = currentContext;
    currentContext = { parent, slots };
    try {
      return callback.apply(thisArg, args);
    } finally {
      currentContext = parent;
    }
  }
  // Capture the current context and wrap a callback function so that it
  // reestablishes the captured context when called.
  static bind(callback) {
    const context = currentContext;
    return function() {
      const saved = currentContext;
      try {
        currentContext = context;
        return callback.apply(this, arguments);
      } finally {
        currentContext = saved;
      }
    };
  }
  // Immediately run a callback function without any captured context.
  static noContext(callback, args, thisArg) {
    if (currentContext) {
      const saved = currentContext;
      try {
        currentContext = null;
        return callback.apply(thisArg, args);
      } finally {
        currentContext = saved;
      }
    } else {
      return callback.apply(thisArg, args);
    }
  }
};
function maybe2(fn) {
  try {
    return fn();
  } catch (ignored) {
  }
}
var globalKey = "@wry/context:Slot";
var host = (
  // Prefer globalThis when available.
  // https://github.com/benjamn/wryware/issues/347
  maybe2(() => globalThis) || // Fall back to global, which works in Node.js and may be converted by some
  // bundlers to the appropriate identifier (window, self, ...) depending on the
  // bundling target. https://github.com/endojs/endo/issues/576#issuecomment-1178515224
  maybe2(() => global) || // Otherwise, use a dummy host that's local to this module. We used to fall
  // back to using the Array constructor as a namespace, but that was flagged in
  // https://github.com/benjamn/wryware/issues/347, and can be avoided.
  /* @__PURE__ */ Object.create(null)
);
var globalHost = host;
var Slot = globalHost[globalKey] || // Earlier versions of this package stored the globalKey property on the Array
// constructor, so we check there as well, to prevent Slot class duplication.
Array[globalKey] || function(Slot2) {
  try {
    Object.defineProperty(globalHost, globalKey, {
      value: Slot2,
      enumerable: false,
      writable: false,
      // When it was possible for globalHost to be the Array constructor (a
      // legacy Slot dedup strategy), it was important for the property to be
      // configurable:true so it could be deleted. That does not seem to be as
      // important when globalHost is the global object, but I don't want to
      // cause similar problems again, and configurable:true seems safest.
      // https://github.com/endojs/endo/issues/576#issuecomment-1178274008
      configurable: true
    });
  } finally {
    return Slot2;
  }
}(makeSlotClass());

// node_modules/@wry/context/lib/index.js
var { bind, noContext } = Slot;

// node_modules/optimism/lib/context.js
var parentEntrySlot = new Slot();

// node_modules/optimism/lib/helpers.js
var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
var arrayFromSet = Array.from || function(set) {
  const array = [];
  set.forEach((item) => array.push(item));
  return array;
};
function maybeUnsubscribe(entryOrDep) {
  const { unsubscribe } = entryOrDep;
  if (typeof unsubscribe === "function") {
    entryOrDep.unsubscribe = void 0;
    unsubscribe();
  }
}

// node_modules/optimism/lib/entry.js
var emptySetPool = [];
var POOL_TARGET_SIZE = 100;
function assert(condition, optionalMessage) {
  if (!condition) {
    throw new Error(optionalMessage || "assertion failure");
  }
}
function valueIs(a, b) {
  const len = a.length;
  return (
    // Unknown values are not equal to each other.
    len > 0 && // Both values must be ordinary (or both exceptional) to be equal.
    len === b.length && // The underlying value or exception must be the same.
    a[len - 1] === b[len - 1]
  );
}
function valueGet(value) {
  switch (value.length) {
    case 0:
      throw new Error("unknown value");
    case 1:
      return value[0];
    case 2:
      throw value[1];
  }
}
function valueCopy(value) {
  return value.slice(0);
}
var Entry = class _Entry {
  constructor(fn) {
    this.fn = fn;
    this.parents = /* @__PURE__ */ new Set();
    this.childValues = /* @__PURE__ */ new Map();
    this.dirtyChildren = null;
    this.dirty = true;
    this.recomputing = false;
    this.value = [];
    this.deps = null;
    ++_Entry.count;
  }
  peek() {
    if (this.value.length === 1 && !mightBeDirty(this)) {
      rememberParent(this);
      return this.value[0];
    }
  }
  // This is the most important method of the Entry API, because it
  // determines whether the cached this.value can be returned immediately,
  // or must be recomputed. The overall performance of the caching system
  // depends on the truth of the following observations: (1) this.dirty is
  // usually false, (2) this.dirtyChildren is usually null/empty, and thus
  // (3) valueGet(this.value) is usually returned without recomputation.
  recompute(args) {
    assert(!this.recomputing, "already recomputing");
    rememberParent(this);
    return mightBeDirty(this) ? reallyRecompute(this, args) : valueGet(this.value);
  }
  setDirty() {
    if (this.dirty)
      return;
    this.dirty = true;
    reportDirty(this);
    maybeUnsubscribe(this);
  }
  dispose() {
    this.setDirty();
    forgetChildren(this);
    eachParent(this, (parent, child) => {
      parent.setDirty();
      forgetChild(parent, this);
    });
  }
  forget() {
    this.dispose();
  }
  dependOn(dep2) {
    dep2.add(this);
    if (!this.deps) {
      this.deps = emptySetPool.pop() || /* @__PURE__ */ new Set();
    }
    this.deps.add(dep2);
  }
  forgetDeps() {
    if (this.deps) {
      arrayFromSet(this.deps).forEach((dep2) => dep2.delete(this));
      this.deps.clear();
      emptySetPool.push(this.deps);
      this.deps = null;
    }
  }
};
Entry.count = 0;
function rememberParent(child) {
  const parent = parentEntrySlot.getValue();
  if (parent) {
    child.parents.add(parent);
    if (!parent.childValues.has(child)) {
      parent.childValues.set(child, []);
    }
    if (mightBeDirty(child)) {
      reportDirtyChild(parent, child);
    } else {
      reportCleanChild(parent, child);
    }
    return parent;
  }
}
function reallyRecompute(entry, args) {
  forgetChildren(entry);
  parentEntrySlot.withValue(entry, recomputeNewValue, [entry, args]);
  if (maybeSubscribe(entry, args)) {
    setClean(entry);
  }
  return valueGet(entry.value);
}
function recomputeNewValue(entry, args) {
  entry.recomputing = true;
  const { normalizeResult } = entry;
  let oldValueCopy;
  if (normalizeResult && entry.value.length === 1) {
    oldValueCopy = valueCopy(entry.value);
  }
  entry.value.length = 0;
  try {
    entry.value[0] = entry.fn.apply(null, args);
    if (normalizeResult && oldValueCopy && !valueIs(oldValueCopy, entry.value)) {
      try {
        entry.value[0] = normalizeResult(entry.value[0], oldValueCopy[0]);
      } catch (_a2) {
      }
    }
  } catch (e) {
    entry.value[1] = e;
  }
  entry.recomputing = false;
}
function mightBeDirty(entry) {
  return entry.dirty || !!(entry.dirtyChildren && entry.dirtyChildren.size);
}
function setClean(entry) {
  entry.dirty = false;
  if (mightBeDirty(entry)) {
    return;
  }
  reportClean(entry);
}
function reportDirty(child) {
  eachParent(child, reportDirtyChild);
}
function reportClean(child) {
  eachParent(child, reportCleanChild);
}
function eachParent(child, callback) {
  const parentCount = child.parents.size;
  if (parentCount) {
    const parents = arrayFromSet(child.parents);
    for (let i = 0; i < parentCount; ++i) {
      callback(parents[i], child);
    }
  }
}
function reportDirtyChild(parent, child) {
  assert(parent.childValues.has(child));
  assert(mightBeDirty(child));
  const parentWasClean = !mightBeDirty(parent);
  if (!parent.dirtyChildren) {
    parent.dirtyChildren = emptySetPool.pop() || /* @__PURE__ */ new Set();
  } else if (parent.dirtyChildren.has(child)) {
    return;
  }
  parent.dirtyChildren.add(child);
  if (parentWasClean) {
    reportDirty(parent);
  }
}
function reportCleanChild(parent, child) {
  assert(parent.childValues.has(child));
  assert(!mightBeDirty(child));
  const childValue = parent.childValues.get(child);
  if (childValue.length === 0) {
    parent.childValues.set(child, valueCopy(child.value));
  } else if (!valueIs(childValue, child.value)) {
    parent.setDirty();
  }
  removeDirtyChild(parent, child);
  if (mightBeDirty(parent)) {
    return;
  }
  reportClean(parent);
}
function removeDirtyChild(parent, child) {
  const dc = parent.dirtyChildren;
  if (dc) {
    dc.delete(child);
    if (dc.size === 0) {
      if (emptySetPool.length < POOL_TARGET_SIZE) {
        emptySetPool.push(dc);
      }
      parent.dirtyChildren = null;
    }
  }
}
function forgetChildren(parent) {
  if (parent.childValues.size > 0) {
    parent.childValues.forEach((_value, child) => {
      forgetChild(parent, child);
    });
  }
  parent.forgetDeps();
  assert(parent.dirtyChildren === null);
}
function forgetChild(parent, child) {
  child.parents.delete(parent);
  parent.childValues.delete(child);
  removeDirtyChild(parent, child);
}
function maybeSubscribe(entry, args) {
  if (typeof entry.subscribe === "function") {
    try {
      maybeUnsubscribe(entry);
      entry.unsubscribe = entry.subscribe.apply(null, args);
    } catch (e) {
      entry.setDirty();
      return false;
    }
  }
  return true;
}

// node_modules/optimism/lib/dep.js
var EntryMethods = {
  setDirty: true,
  dispose: true,
  forget: true
  // Fully remove parent Entry from LRU cache and computation graph
};
function dep(options) {
  const depsByKey = /* @__PURE__ */ new Map();
  const subscribe = options && options.subscribe;
  function depend(key) {
    const parent = parentEntrySlot.getValue();
    if (parent) {
      let dep2 = depsByKey.get(key);
      if (!dep2) {
        depsByKey.set(key, dep2 = /* @__PURE__ */ new Set());
      }
      parent.dependOn(dep2);
      if (typeof subscribe === "function") {
        maybeUnsubscribe(dep2);
        dep2.unsubscribe = subscribe(key);
      }
    }
  }
  depend.dirty = function dirty(key, entryMethodName) {
    const dep2 = depsByKey.get(key);
    if (dep2) {
      const m = entryMethodName && hasOwnProperty2.call(EntryMethods, entryMethodName) ? entryMethodName : "setDirty";
      arrayFromSet(dep2).forEach((entry) => entry[m]());
      depsByKey.delete(key);
      maybeUnsubscribe(dep2);
    }
  };
  return depend;
}

// node_modules/optimism/lib/index.js
var defaultKeyTrie;
function defaultMakeCacheKey(...args) {
  const trie = defaultKeyTrie || (defaultKeyTrie = new Trie(typeof WeakMap === "function"));
  return trie.lookupArray(args);
}
var caches = /* @__PURE__ */ new Set();
function wrap(originalFunction, { max = Math.pow(2, 16), keyArgs, makeCacheKey = defaultMakeCacheKey, normalizeResult, subscribe, cache: cacheOption = StrongCache } = /* @__PURE__ */ Object.create(null)) {
  const cache = typeof cacheOption === "function" ? new cacheOption(max, (entry) => entry.dispose()) : cacheOption;
  const optimistic = function() {
    const key = makeCacheKey.apply(null, keyArgs ? keyArgs.apply(null, arguments) : arguments);
    if (key === void 0) {
      return originalFunction.apply(null, arguments);
    }
    let entry = cache.get(key);
    if (!entry) {
      cache.set(key, entry = new Entry(originalFunction));
      entry.normalizeResult = normalizeResult;
      entry.subscribe = subscribe;
      entry.forget = () => cache.delete(key);
    }
    const value = entry.recompute(Array.prototype.slice.call(arguments));
    cache.set(key, entry);
    caches.add(cache);
    if (!parentEntrySlot.hasValue()) {
      caches.forEach((cache2) => cache2.clean());
      caches.clear();
    }
    return value;
  };
  Object.defineProperty(optimistic, "size", {
    get: () => cache.size,
    configurable: false,
    enumerable: false
  });
  Object.freeze(optimistic.options = {
    max,
    keyArgs,
    makeCacheKey,
    normalizeResult,
    subscribe,
    cache
  });
  function dirtyKey(key) {
    const entry = key && cache.get(key);
    if (entry) {
      entry.setDirty();
    }
  }
  optimistic.dirtyKey = dirtyKey;
  optimistic.dirty = function dirty() {
    dirtyKey(makeCacheKey.apply(null, arguments));
  };
  function peekKey(key) {
    const entry = key && cache.get(key);
    if (entry) {
      return entry.peek();
    }
  }
  optimistic.peekKey = peekKey;
  optimistic.peek = function peek() {
    return peekKey(makeCacheKey.apply(null, arguments));
  };
  function forgetKey(key) {
    return key ? cache.delete(key) : false;
  }
  optimistic.forgetKey = forgetKey;
  optimistic.forget = function forget() {
    return forgetKey(makeCacheKey.apply(null, arguments));
  };
  optimistic.makeCacheKey = makeCacheKey;
  optimistic.getKey = keyArgs ? function getKey() {
    return makeCacheKey.apply(null, keyArgs.apply(null, arguments));
  } : makeCacheKey;
  return Object.freeze(optimistic);
}

// node_modules/@apollo/client/utilities/caching/sizes.js
var cacheSizeSymbol = Symbol.for("apollo.cacheSize");
var cacheSizes = { ...global_default[cacheSizeSymbol] };

// node_modules/@apollo/client/utilities/internal/getOperationName.js
function getOperationName(doc, fallback) {
  var _a2;
  return ((_a2 = doc.definitions.find((definition) => definition.kind === "OperationDefinition" && !!definition.name)) == null ? void 0 : _a2.name.value) ?? fallback;
}

// node_modules/@apollo/client/utilities/internal/checkDocument.js
var checkDocument = wrap((doc, expectedType) => {
  invariant2(doc && doc.kind === "Document", 1);
  const operations = doc.definitions.filter((d) => d.kind === "OperationDefinition");
  if (__DEV__) {
    doc.definitions.forEach((definition) => {
      if (definition.kind !== "OperationDefinition" && definition.kind !== "FragmentDefinition") {
        throw newInvariantError(2, definition.kind);
      }
    });
    invariant2(operations.length <= 1, 3, operations.length);
  }
  if (expectedType) {
    invariant2(
      operations.length == 1 && operations[0].operation === expectedType,
      4,
      expectedType,
      expectedType,
      operations[0].operation
    );
  }
  visit(doc, {
    Field(field, _, __, path) {
      var _a2;
      if (field.alias && (field.alias.value === "__typename" || field.alias.value.startsWith("__ac_")) && field.alias.value !== field.name.value) {
        let current = doc, fieldPath = [];
        for (const key of path) {
          current = current[key];
          if (current.kind === Kind.FIELD) {
            fieldPath.push(((_a2 = current.alias) == null ? void 0 : _a2.value) || current.name.value);
          }
        }
        fieldPath.splice(-1, 1, field.name.value);
        throw newInvariantError(
          5,
          field.alias.value,
          fieldPath.join("."),
          operations[0].operation,
          getOperationName(doc, "(anonymous)")
        );
      }
    }
  });
}, {
  max: cacheSizes["checkDocument"] || 2e3,
  cache: WeakCache
});

// node_modules/@apollo/client/utilities/internal/cloneDeep.js
var { toString } = Object.prototype;
function cloneDeep(value) {
  return __cloneDeep(value);
}
function __cloneDeep(val, seen) {
  switch (toString.call(val)) {
    case "[object Array]": {
      seen = seen || /* @__PURE__ */ new Map();
      if (seen.has(val))
        return seen.get(val);
      const copy = val.slice(0);
      seen.set(val, copy);
      copy.forEach(function(child, i) {
        copy[i] = __cloneDeep(child, seen);
      });
      return copy;
    }
    case "[object Object]": {
      seen = seen || /* @__PURE__ */ new Map();
      if (seen.has(val))
        return seen.get(val);
      const copy = Object.create(Object.getPrototypeOf(val));
      seen.set(val, copy);
      Object.keys(val).forEach((key) => {
        copy[key] = __cloneDeep(val[key], seen);
      });
      return copy;
    }
    default:
      return val;
  }
}

// node_modules/@apollo/client/utilities/internal/compact.js
function compact(...objects) {
  const result = {};
  objects.forEach((obj) => {
    if (!obj)
      return;
    Object.keys(obj).forEach((key) => {
      const value = obj[key];
      if (value !== void 0) {
        result[key] = value;
      }
    });
  });
  return result;
}

// node_modules/@apollo/client/utilities/internal/createFragmentMap.js
function createFragmentMap(fragments = []) {
  const symTable = {};
  fragments.forEach((fragment) => {
    symTable[fragment.name.value] = fragment;
  });
  return symTable;
}

// node_modules/@apollo/client/utilities/internal/createFulfilledPromise.js
function createFulfilledPromise(value) {
  const promise = Promise.resolve(value);
  promise.status = "fulfilled";
  promise.value = value;
  return promise;
}

// node_modules/@apollo/client/utilities/internal/createRejectedPromise.js
function createRejectedPromise(reason) {
  const promise = Promise.reject(reason);
  promise.catch(() => {
  });
  promise.status = "rejected";
  promise.reason = reason;
  return promise;
}

// node_modules/@apollo/client/utilities/internal/decoratePromise.js
function isDecoratedPromise(promise) {
  return "status" in promise;
}
function decoratePromise(promise) {
  if (isDecoratedPromise(promise)) {
    return promise;
  }
  const pendingPromise = promise;
  pendingPromise.status = "pending";
  pendingPromise.then((value) => {
    if (pendingPromise.status === "pending") {
      const fulfilledPromise = pendingPromise;
      fulfilledPromise.status = "fulfilled";
      fulfilledPromise.value = value;
    }
  }, (reason) => {
    if (pendingPromise.status === "pending") {
      const rejectedPromise = pendingPromise;
      rejectedPromise.status = "rejected";
      rejectedPromise.reason = reason;
    }
  });
  return promise;
}

// node_modules/@apollo/client/utilities/internal/isNonNullObject.js
function isNonNullObject(obj) {
  return obj !== null && typeof obj === "object";
}

// node_modules/@apollo/client/utilities/internal/DeepMerger.js
var { hasOwnProperty: hasOwnProperty3 } = Object.prototype;
var defaultReconciler = function(target, source, property) {
  return this.merge(target[property], source[property]);
};
var DeepMerger = class {
  constructor(reconciler = defaultReconciler) {
    __publicField(this, "reconciler");
    __publicField(this, "isObject", isNonNullObject);
    __publicField(this, "pastCopies", /* @__PURE__ */ new Set());
    this.reconciler = reconciler;
  }
  merge(target, source, ...context) {
    if (isNonNullObject(source) && isNonNullObject(target)) {
      Object.keys(source).forEach((sourceKey) => {
        if (hasOwnProperty3.call(target, sourceKey)) {
          const targetValue = target[sourceKey];
          if (source[sourceKey] !== targetValue) {
            const result = this.reconciler(target, source, sourceKey, ...context);
            if (result !== targetValue) {
              target = this.shallowCopyForMerge(target);
              target[sourceKey] = result;
            }
          }
        } else {
          target = this.shallowCopyForMerge(target);
          target[sourceKey] = source[sourceKey];
        }
      });
      return target;
    }
    return source;
  }
  shallowCopyForMerge(value) {
    if (isNonNullObject(value)) {
      if (!this.pastCopies.has(value)) {
        if (Array.isArray(value)) {
          value = value.slice(0);
        } else {
          value = {
            __proto__: Object.getPrototypeOf(value),
            ...value
          };
        }
        this.pastCopies.add(value);
      }
    }
    return value;
  }
};

// node_modules/@apollo/client/utilities/internal/getDefaultValues.js
function getDefaultValues(definition) {
  const defaultValues = {};
  const defs = definition && definition.variableDefinitions;
  if (defs && defs.length) {
    defs.forEach((def) => {
      if (def.defaultValue) {
        valueToObjectRepresentation(defaultValues, def.variable.name, def.defaultValue);
      }
    });
  }
  return defaultValues;
}

// node_modules/@apollo/client/utilities/internal/getFragmentFromSelection.js
function getFragmentFromSelection(selection, fragmentMap) {
  switch (selection.kind) {
    case "InlineFragment":
      return selection;
    case "FragmentSpread": {
      const fragmentName = selection.name.value;
      if (typeof fragmentMap === "function") {
        return fragmentMap(fragmentName);
      }
      const fragment = fragmentMap && fragmentMap[fragmentName];
      invariant2(fragment, 9, fragmentName);
      return fragment || null;
    }
    default:
      return null;
  }
}

// node_modules/@apollo/client/utilities/internal/getFragmentQueryDocument.js
function getFragmentQueryDocument(document, fragmentName) {
  let actualFragmentName = fragmentName;
  const fragments = [];
  document.definitions.forEach((definition) => {
    if (definition.kind === "OperationDefinition") {
      throw newInvariantError(
        10,
        definition.operation,
        definition.name ? ` named '${definition.name.value}'` : ""
      );
    }
    if (definition.kind === "FragmentDefinition") {
      fragments.push(definition);
    }
  });
  if (typeof actualFragmentName === "undefined") {
    invariant2(fragments.length === 1, 11, fragments.length);
    actualFragmentName = fragments[0].name.value;
  }
  const query = {
    ...document,
    definitions: [
      {
        kind: "OperationDefinition",
        // OperationTypeNode is an enum
        operation: "query",
        selectionSet: {
          kind: "SelectionSet",
          selections: [
            {
              kind: "FragmentSpread",
              name: {
                kind: "Name",
                value: actualFragmentName
              }
            }
          ]
        }
      },
      ...document.definitions
    ]
  };
  return query;
}

// node_modules/@apollo/client/utilities/internal/getFragmentDefinition.js
function getFragmentDefinition(doc) {
  invariant2(doc.kind === "Document", 6);
  invariant2(doc.definitions.length <= 1, 7);
  const fragmentDef = doc.definitions[0];
  invariant2(fragmentDef.kind === "FragmentDefinition", 8);
  return fragmentDef;
}

// node_modules/@apollo/client/utilities/internal/getFragmentDefinitions.js
function getFragmentDefinitions(doc) {
  return doc.definitions.filter((definition) => definition.kind === "FragmentDefinition");
}

// node_modules/@apollo/client/utilities/internal/getMainDefinition.js
function getMainDefinition(queryDoc) {
  checkDocument(queryDoc);
  let fragmentDefinition;
  for (let definition of queryDoc.definitions) {
    if (definition.kind === "OperationDefinition") {
      return definition;
    }
    if (definition.kind === "FragmentDefinition" && !fragmentDefinition) {
      fragmentDefinition = definition;
    }
  }
  if (fragmentDefinition) {
    return fragmentDefinition;
  }
  throw newInvariantError(12);
}

// node_modules/@apollo/client/utilities/internal/getOperationDefinition.js
function getOperationDefinition(doc) {
  checkDocument(doc);
  return doc.definitions.filter((definition) => definition.kind === "OperationDefinition")[0];
}

// node_modules/@apollo/client/utilities/internal/getQueryDefinition.js
function getQueryDefinition(doc) {
  const queryDef = getOperationDefinition(doc);
  invariant2(queryDef && queryDef.operation === "query", 13);
  return queryDef;
}

// node_modules/@apollo/client/utilities/internal/caches.js
var scheduledCleanup = /* @__PURE__ */ new WeakSet();
function schedule(cache) {
  if (cache.size <= (cache.max || -1)) {
    return;
  }
  if (!scheduledCleanup.has(cache)) {
    scheduledCleanup.add(cache);
    setTimeout(() => {
      cache.clean();
      scheduledCleanup.delete(cache);
    }, 100);
  }
}
var AutoCleanedWeakCache = function(max, dispose) {
  const cache = new WeakCache(max, dispose);
  cache.set = function(key, value) {
    const ret = WeakCache.prototype.set.call(this, key, value);
    schedule(this);
    return ret;
  };
  return cache;
};
var AutoCleanedStrongCache = function(max, dispose) {
  const cache = new StrongCache(max, dispose);
  cache.set = function(key, value) {
    const ret = StrongCache.prototype.set.call(this, key, value);
    schedule(this);
    return ret;
  };
  return cache;
};

// node_modules/@apollo/client/utilities/internal/getMemoryInternals.js
var globalCaches = {};
function registerGlobalCache(name, getSize) {
  globalCaches[name] = getSize;
}
var getApolloClientMemoryInternals = __DEV__ ? _getApolloClientMemoryInternals : void 0;
var getInMemoryCacheMemoryInternals = __DEV__ ? _getInMemoryCacheMemoryInternals : void 0;
var getApolloCacheMemoryInternals = __DEV__ ? _getApolloCacheMemoryInternals : void 0;
function getCurrentCacheSizes() {
  const defaults = {
    canonicalStringify: 1e3,
    checkDocument: 2e3,
    print: 2e3,
    "documentTransform.cache": 2e3,
    "queryManager.getDocumentInfo": 2e3,
    "PersistedQueryLink.persistedQueryHashes": 2e3,
    "fragmentRegistry.transform": 2e3,
    "fragmentRegistry.lookup": 1e3,
    "fragmentRegistry.findFragmentSpreads": 4e3,
    "cache.fragmentQueryDocuments": 1e3,
    "removeTypenameFromVariables.getVariableDefinitions": 2e3,
    "inMemoryCache.maybeBroadcastWatch": 5e3,
    "inMemoryCache.executeSelectionSet": 5e4,
    "inMemoryCache.executeSubSelectedArray": 1e4
  };
  return Object.fromEntries(Object.entries(defaults).map(([k, v]) => [
    k,
    cacheSizes[k] || v
  ]));
}
function _getApolloClientMemoryInternals() {
  var _a2, _b, _c, _d;
  if (!__DEV__)
    throw new Error("only supported in development mode");
  return {
    limits: getCurrentCacheSizes(),
    sizes: {
      print: (_a2 = globalCaches.print) == null ? void 0 : _a2.call(globalCaches),
      canonicalStringify: (_b = globalCaches.canonicalStringify) == null ? void 0 : _b.call(globalCaches),
      links: linkInfo(this.link),
      queryManager: {
        getDocumentInfo: this["queryManager"]["transformCache"].size,
        documentTransforms: transformInfo(this["queryManager"].documentTransform)
      },
      ...(_d = (_c = this.cache).getMemoryInternals) == null ? void 0 : _d.call(_c)
    }
  };
}
function _getApolloCacheMemoryInternals() {
  return {
    cache: {
      fragmentQueryDocuments: getWrapperInformation(this["getFragmentDoc"])
    }
  };
}
function _getInMemoryCacheMemoryInternals() {
  const fragments = this.config.fragments;
  return {
    ..._getApolloCacheMemoryInternals.apply(this),
    addTypenameDocumentTransform: transformInfo(this["addTypenameTransform"]),
    inMemoryCache: {
      executeSelectionSet: getWrapperInformation(this["storeReader"]["executeSelectionSet"]),
      executeSubSelectedArray: getWrapperInformation(this["storeReader"]["executeSubSelectedArray"]),
      maybeBroadcastWatch: getWrapperInformation(this["maybeBroadcastWatch"])
    },
    fragmentRegistry: {
      findFragmentSpreads: getWrapperInformation(fragments == null ? void 0 : fragments.findFragmentSpreads),
      lookup: getWrapperInformation(fragments == null ? void 0 : fragments.lookup),
      transform: getWrapperInformation(fragments == null ? void 0 : fragments.transform)
    }
  };
}
function isWrapper(f) {
  return !!f && "dirtyKey" in f;
}
function getWrapperInformation(f) {
  return isWrapper(f) ? f.size : void 0;
}
function isDefined(value) {
  return value != null;
}
function transformInfo(transform) {
  return recurseTransformInfo(transform).map((cache) => ({ cache }));
}
function recurseTransformInfo(transform) {
  return transform ? [
    getWrapperInformation(transform == null ? void 0 : transform["performWork"]),
    ...recurseTransformInfo(transform == null ? void 0 : transform["left"]),
    ...recurseTransformInfo(transform == null ? void 0 : transform["right"])
  ].filter(isDefined) : [];
}
function linkInfo(link) {
  var _a2;
  return link ? [
    (_a2 = link == null ? void 0 : link.getMemoryInternals) == null ? void 0 : _a2.call(link),
    ...linkInfo(link == null ? void 0 : link.left),
    ...linkInfo(link == null ? void 0 : link.right)
  ].filter(isDefined) : [];
}

// node_modules/@apollo/client/utilities/internal/canonicalStringify.js
var canonicalStringify = Object.assign(function canonicalStringify2(value) {
  return JSON.stringify(value, stableObjectReplacer);
}, {
  reset() {
    sortingMap = new AutoCleanedStrongCache(
      cacheSizes.canonicalStringify || 1e3
      /* defaultCacheSizes.canonicalStringify */
    );
  }
});
if (__DEV__) {
  registerGlobalCache("canonicalStringify", () => sortingMap.size);
}
var sortingMap;
canonicalStringify.reset();
function stableObjectReplacer(key, value) {
  if (value && typeof value === "object") {
    const proto = Object.getPrototypeOf(value);
    if (proto === Object.prototype || proto === null) {
      const keys = Object.keys(value);
      if (keys.every(everyKeyInOrder))
        return value;
      const unsortedKey = JSON.stringify(keys);
      let sortedKeys = sortingMap.get(unsortedKey);
      if (!sortedKeys) {
        keys.sort();
        const sortedKey = JSON.stringify(keys);
        sortedKeys = sortingMap.get(sortedKey) || keys;
        sortingMap.set(unsortedKey, sortedKeys);
        sortingMap.set(sortedKey, sortedKeys);
      }
      const sortedObject = Object.create(proto);
      sortedKeys.forEach((key2) => {
        sortedObject[key2] = value[key2];
      });
      return sortedObject;
    }
  }
  return value;
}
function everyKeyInOrder(key, i, keys) {
  return i === 0 || keys[i - 1] <= key;
}

// node_modules/@apollo/client/utilities/internal/getStoreKeyName.js
var KNOWN_DIRECTIVES = [
  "connection",
  "include",
  "skip",
  "client",
  "rest",
  "export",
  "nonreactive"
];
var storeKeyNameStringify = canonicalStringify;
var getStoreKeyName = Object.assign(function(fieldName, args, directives) {
  if (args && directives && directives["connection"] && directives["connection"]["key"]) {
    if (directives["connection"]["filter"] && directives["connection"]["filter"].length > 0) {
      const filterKeys = directives["connection"]["filter"] ? directives["connection"]["filter"] : [];
      filterKeys.sort();
      const filteredArgs = {};
      filterKeys.forEach((key) => {
        filteredArgs[key] = args[key];
      });
      const stringifiedArgs = storeKeyNameStringify(filteredArgs);
      if (stringifiedArgs !== "{}") {
        return `${directives["connection"]["key"]}(${stringifiedArgs})`;
      }
    }
    return directives["connection"]["key"];
  }
  let completeFieldName = fieldName;
  if (args) {
    const stringifiedArgs = storeKeyNameStringify(args);
    if (stringifiedArgs !== "{}") {
      completeFieldName += `(${stringifiedArgs})`;
    }
  }
  if (directives) {
    Object.keys(directives).forEach((key) => {
      if (KNOWN_DIRECTIVES.indexOf(key) !== -1)
        return;
      if (directives[key] && Object.keys(directives[key]).length) {
        completeFieldName += `@${key}(${storeKeyNameStringify(directives[key])})`;
      } else {
        completeFieldName += `@${key}`;
      }
    });
  }
  return completeFieldName;
}, {
  setStringify(s) {
    const previous = storeKeyNameStringify;
    storeKeyNameStringify = s;
    return previous;
  }
});

// node_modules/@apollo/client/utilities/internal/graphQLResultHasError.js
function graphQLResultHasError(result) {
  var _a2;
  return !!((_a2 = result.errors) == null ? void 0 : _a2.length);
}

// node_modules/@apollo/client/utilities/internal/hasDirectives.js
function hasDirectives(names, root, all) {
  const nameSet = new Set(names);
  const uniqueCount = nameSet.size;
  visit(root, {
    Directive(node) {
      if (nameSet.delete(node.name.value) && (!all || !nameSet.size)) {
        return BREAK;
      }
    }
  });
  return all ? !nameSet.size : nameSet.size < uniqueCount;
}

// node_modules/@apollo/client/utilities/internal/hasForcedResolvers.js
function hasForcedResolvers(document) {
  let forceResolvers = false;
  visit(document, {
    Directive: {
      enter(node) {
        if (node.name.value === "client" && node.arguments) {
          forceResolvers = node.arguments.some((arg) => arg.name.value === "always" && arg.value.kind === "BooleanValue" && arg.value.value === true);
          if (forceResolvers) {
            return BREAK;
          }
        }
      }
    }
  });
  return forceResolvers;
}

// node_modules/@apollo/client/utilities/internal/isArray.js
var isArray = Array.isArray;

// node_modules/@apollo/client/utilities/internal/isDocumentNode.js
function isDocumentNode(value) {
  return isNonNullObject(value) && value.kind === "Document" && Array.isArray(value.definitions);
}

// node_modules/@apollo/client/utilities/internal/isField.js
function isField(selection) {
  return selection.kind === "Field";
}

// node_modules/@apollo/client/utilities/internal/isNonEmptyArray.js
function isNonEmptyArray(value) {
  return Array.isArray(value) && value.length > 0;
}

// node_modules/@apollo/client/utilities/internal/makeReference.js
function makeReference(id) {
  return { __ref: String(id) };
}

// node_modules/@apollo/client/utilities/internal/deepFreeze.js
function deepFreeze(value) {
  const workSet = /* @__PURE__ */ new Set([value]);
  workSet.forEach((obj) => {
    if (isNonNullObject(obj) && shallowFreeze(obj) === obj) {
      Object.getOwnPropertyNames(obj).forEach((name) => {
        if (isNonNullObject(obj[name]))
          workSet.add(obj[name]);
      });
    }
  });
  return value;
}
function shallowFreeze(obj) {
  if (__DEV__ && !Object.isFrozen(obj)) {
    try {
      Object.freeze(obj);
    } catch (e) {
      if (e instanceof TypeError)
        return null;
      throw e;
    }
  }
  return obj;
}

// node_modules/@apollo/client/utilities/internal/maybeDeepFreeze.js
function maybeDeepFreeze(obj) {
  if (__DEV__) {
    deepFreeze(obj);
  }
  return obj;
}

// node_modules/@apollo/client/utilities/internal/mergeDeepArray.js
function mergeDeepArray(sources) {
  let target = sources[0] || {};
  const count = sources.length;
  if (count > 1) {
    const merger = new DeepMerger();
    for (let i = 1; i < count; ++i) {
      target = merger.merge(target, sources[i]);
    }
  }
  return target;
}

// node_modules/@apollo/client/utilities/internal/mergeOptions.js
function mergeOptions(defaults, options) {
  return compact(defaults, options, options.variables && {
    variables: compact({
      ...defaults && defaults.variables,
      ...options.variables
    })
  });
}

// node_modules/@apollo/client/utilities/internal/preventUnhandledRejection.js
function preventUnhandledRejection(promise) {
  promise.catch(() => {
  });
  return promise;
}

// node_modules/@apollo/client/utilities/internal/removeDirectivesFromDocument.js
function removeDirectivesFromDocument(directives, doc) {
  checkDocument(doc);
  const getInUseByOperationName = makeInUseGetterFunction("");
  const getInUseByFragmentName = makeInUseGetterFunction("");
  const getInUse = (ancestors) => {
    for (let p = 0, ancestor; p < ancestors.length && (ancestor = ancestors[p]); ++p) {
      if (isArray(ancestor))
        continue;
      if (ancestor.kind === Kind.OPERATION_DEFINITION) {
        return getInUseByOperationName(ancestor.name && ancestor.name.value);
      }
      if (ancestor.kind === Kind.FRAGMENT_DEFINITION) {
        return getInUseByFragmentName(ancestor.name.value);
      }
    }
    invariant2.error(14);
    return null;
  };
  let operationCount = 0;
  for (let i = doc.definitions.length - 1; i >= 0; --i) {
    if (doc.definitions[i].kind === Kind.OPERATION_DEFINITION) {
      ++operationCount;
    }
  }
  const directiveMatcher = getDirectiveMatcher(directives);
  const shouldRemoveField = (nodeDirectives) => isNonEmptyArray(nodeDirectives) && nodeDirectives.map(directiveMatcher).some((config) => config && config.remove);
  const originalFragmentDefsByPath = /* @__PURE__ */ new Map();
  let firstVisitMadeChanges = false;
  const fieldOrInlineFragmentVisitor = {
    enter(node) {
      if (shouldRemoveField(node.directives)) {
        firstVisitMadeChanges = true;
        return null;
      }
    }
  };
  const docWithoutDirectiveSubtrees = visit(doc, {
    // These two AST node types share the same implementation, defined above.
    Field: fieldOrInlineFragmentVisitor,
    InlineFragment: fieldOrInlineFragmentVisitor,
    VariableDefinition: {
      enter() {
        return false;
      }
    },
    Variable: {
      enter(node, _key, _parent, _path, ancestors) {
        const inUse = getInUse(ancestors);
        if (inUse) {
          inUse.variables.add(node.name.value);
        }
      }
    },
    FragmentSpread: {
      enter(node, _key, _parent, _path, ancestors) {
        if (shouldRemoveField(node.directives)) {
          firstVisitMadeChanges = true;
          return null;
        }
        const inUse = getInUse(ancestors);
        if (inUse) {
          inUse.fragmentSpreads.add(node.name.value);
        }
      }
    },
    FragmentDefinition: {
      enter(node, _key, _parent, path) {
        originalFragmentDefsByPath.set(JSON.stringify(path), node);
      },
      leave(node, _key, _parent, path) {
        const originalNode = originalFragmentDefsByPath.get(JSON.stringify(path));
        if (node === originalNode) {
          return node;
        }
        if (
          // This logic applies only if the document contains one or more
          // operations, since removing all fragments from a document containing
          // only fragments makes the document useless.
          operationCount > 0 && node.selectionSet.selections.every((selection) => selection.kind === Kind.FIELD && selection.name.value === "__typename")
        ) {
          getInUseByFragmentName(node.name.value).removed = true;
          firstVisitMadeChanges = true;
          return null;
        }
      }
    },
    Directive: {
      leave(node) {
        if (directiveMatcher(node)) {
          firstVisitMadeChanges = true;
          return null;
        }
      }
    }
  });
  if (!firstVisitMadeChanges) {
    return doc;
  }
  const populateTransitiveVars = (inUse) => {
    if (!inUse.transitiveVars) {
      inUse.transitiveVars = new Set(inUse.variables);
      if (!inUse.removed) {
        inUse.fragmentSpreads.forEach((childFragmentName) => {
          populateTransitiveVars(getInUseByFragmentName(childFragmentName)).transitiveVars.forEach((varName) => {
            inUse.transitiveVars.add(varName);
          });
        });
      }
    }
    return inUse;
  };
  const allFragmentNamesUsed = /* @__PURE__ */ new Set();
  docWithoutDirectiveSubtrees.definitions.forEach((def) => {
    if (def.kind === Kind.OPERATION_DEFINITION) {
      populateTransitiveVars(getInUseByOperationName(def.name && def.name.value)).fragmentSpreads.forEach((childFragmentName) => {
        allFragmentNamesUsed.add(childFragmentName);
      });
    } else if (def.kind === Kind.FRAGMENT_DEFINITION && // If there are no operations in the document, then all fragment
    // definitions count as usages of their own fragment names. This heuristic
    // prevents accidentally removing all fragment definitions from the
    // document just because it contains no operations that use the fragments.
    operationCount === 0 && !getInUseByFragmentName(def.name.value).removed) {
      allFragmentNamesUsed.add(def.name.value);
    }
  });
  allFragmentNamesUsed.forEach((fragmentName) => {
    populateTransitiveVars(getInUseByFragmentName(fragmentName)).fragmentSpreads.forEach((childFragmentName) => {
      allFragmentNamesUsed.add(childFragmentName);
    });
  });
  const fragmentWillBeRemoved = (fragmentName) => !!// A fragment definition will be removed if there are no spreads that refer
  // to it, or the fragment was explicitly removed because it had no fields
  // other than __typename.
  (!allFragmentNamesUsed.has(fragmentName) || getInUseByFragmentName(fragmentName).removed);
  const enterVisitor = {
    enter(node) {
      if (fragmentWillBeRemoved(node.name.value)) {
        return null;
      }
    }
  };
  return nullIfDocIsEmpty(visit(docWithoutDirectiveSubtrees, {
    // If the fragment is going to be removed, then leaving any dangling
    // FragmentSpread nodes with the same name would be a mistake.
    FragmentSpread: enterVisitor,
    // This is where the fragment definition is actually removed.
    FragmentDefinition: enterVisitor,
    OperationDefinition: {
      leave(node) {
        if (node.variableDefinitions) {
          const usedVariableNames = populateTransitiveVars(
            // If an operation is anonymous, we use the empty string as its key.
            getInUseByOperationName(node.name && node.name.value)
          ).transitiveVars;
          if (usedVariableNames.size < node.variableDefinitions.length) {
            return {
              ...node,
              variableDefinitions: node.variableDefinitions.filter((varDef) => usedVariableNames.has(varDef.variable.name.value))
            };
          }
        }
      }
    }
  }));
}
function makeInUseGetterFunction(defaultKey) {
  const map3 = /* @__PURE__ */ new Map();
  return function inUseGetterFunction(key = defaultKey) {
    let inUse = map3.get(key);
    if (!inUse) {
      map3.set(key, inUse = {
        // Variable and fragment spread names used directly within this
        // operation or fragment definition, as identified by key. These sets
        // will be populated during the first traversal of the document in
        // removeDirectivesFromDocument below.
        variables: /* @__PURE__ */ new Set(),
        fragmentSpreads: /* @__PURE__ */ new Set()
      });
    }
    return inUse;
  };
}
function getDirectiveMatcher(configs) {
  const names = /* @__PURE__ */ new Map();
  const tests = /* @__PURE__ */ new Map();
  configs.forEach((directive) => {
    if (directive) {
      if (directive.name) {
        names.set(directive.name, directive);
      } else if (directive.test) {
        tests.set(directive.test, directive);
      }
    }
  });
  return (directive) => {
    let config = names.get(directive.name.value);
    if (!config && tests.size) {
      tests.forEach((testConfig, test) => {
        if (test(directive)) {
          config = testConfig;
        }
      });
    }
    return config;
  };
}
function isEmpty(op, fragmentMap) {
  return !op || op.selectionSet.selections.every((selection) => selection.kind === Kind.FRAGMENT_SPREAD && isEmpty(fragmentMap[selection.name.value], fragmentMap));
}
function nullIfDocIsEmpty(doc) {
  return isEmpty(getOperationDefinition(doc) || getFragmentDefinition(doc), createFragmentMap(getFragmentDefinitions(doc))) ? null : doc;
}

// node_modules/@apollo/client/utilities/internal/removeFragmentSpreads.js
function removeMaskedFragmentSpreads(document) {
  return visit(document, {
    FragmentSpread(node) {
      var _a2;
      if (!((_a2 = node.directives) == null ? void 0 : _a2.some(({ name }) => name.value === "unmask"))) {
        return null;
      }
    }
  });
}

// node_modules/@apollo/client/utilities/internal/resultKeyNameFromField.js
function resultKeyNameFromField(field) {
  return field.alias ? field.alias.value : field.name.value;
}

// node_modules/@apollo/client/utilities/internal/shouldInclude.js
function shouldInclude({ directives }, variables) {
  if (!directives || !directives.length) {
    return true;
  }
  return getInclusionDirectives(directives).every(({ directive, ifArgument }) => {
    let evaledValue = false;
    if (ifArgument.value.kind === "Variable") {
      evaledValue = variables && variables[ifArgument.value.name.value];
      invariant2(evaledValue !== void 0, 15, directive.name.value);
    } else {
      evaledValue = ifArgument.value.value;
    }
    return directive.name.value === "skip" ? !evaledValue : evaledValue;
  });
}
function isInclusionDirective({ name: { value } }) {
  return value === "skip" || value === "include";
}
function getInclusionDirectives(directives) {
  const result = [];
  if (directives && directives.length) {
    directives.forEach((directive) => {
      if (!isInclusionDirective(directive))
        return;
      const directiveArguments = directive.arguments;
      const directiveName = directive.name.value;
      invariant2(directiveArguments && directiveArguments.length === 1, 16, directiveName);
      const ifArgument = directiveArguments[0];
      invariant2(ifArgument.name && ifArgument.name.value === "if", 17, directiveName);
      const ifValue = ifArgument.value;
      invariant2(ifValue && (ifValue.kind === "Variable" || ifValue.kind === "BooleanValue"), 18, directiveName);
      result.push({ directive, ifArgument });
    });
  }
  return result;
}

// node_modules/@apollo/client/utilities/internal/storeKeyNameFromField.js
function storeKeyNameFromField(field, variables) {
  let directivesObj = null;
  if (field.directives) {
    directivesObj = {};
    field.directives.forEach((directive) => {
      directivesObj[directive.name.value] = {};
      if (directive.arguments) {
        directive.arguments.forEach(({ name, value }) => valueToObjectRepresentation(directivesObj[directive.name.value], name, value, variables));
      }
    });
  }
  let argObj = null;
  if (field.arguments && field.arguments.length) {
    argObj = {};
    field.arguments.forEach(({ name, value }) => valueToObjectRepresentation(argObj, name, value, variables));
  }
  return getStoreKeyName(field.name.value, argObj, directivesObj);
}

// node_modules/@apollo/client/utilities/internal/toQueryResult.js
function toQueryResult(value) {
  const result = {
    data: value.data
  };
  if (value.error) {
    result.error = value.error;
  }
  return result;
}

// node_modules/@apollo/client/utilities/internal/filterMap.js
var import_rxjs = __toESM(require_cjs(), 1);
function filterMap(fn, makeContext = () => void 0) {
  return (source) => new import_rxjs.Observable((subscriber) => {
    let context = makeContext();
    return source.subscribe({
      next(value) {
        let result;
        try {
          result = fn(value, context);
        } catch (e) {
          subscriber.error(e);
        }
        if (result === void 0) {
          return;
        }
        subscriber.next(result);
      },
      error(err) {
        subscriber.error(err);
      },
      complete() {
        subscriber.complete();
      }
    });
  });
}

// node_modules/@wry/equality/lib/index.js
var { toString: toString2, hasOwnProperty: hasOwnProperty4 } = Object.prototype;
var fnToStr = Function.prototype.toString;
var previousComparisons = /* @__PURE__ */ new Map();
function equal(a, b) {
  try {
    return check(a, b);
  } finally {
    previousComparisons.clear();
  }
}
function check(a, b) {
  if (a === b) {
    return true;
  }
  const aTag = toString2.call(a);
  const bTag = toString2.call(b);
  if (aTag !== bTag) {
    return false;
  }
  switch (aTag) {
    case "[object Array]":
      if (a.length !== b.length)
        return false;
    // Fall through to object case...
    case "[object Object]": {
      if (previouslyCompared(a, b))
        return true;
      const aKeys = definedKeys(a);
      const bKeys = definedKeys(b);
      const keyCount = aKeys.length;
      if (keyCount !== bKeys.length)
        return false;
      for (let k = 0; k < keyCount; ++k) {
        if (!hasOwnProperty4.call(b, aKeys[k])) {
          return false;
        }
      }
      for (let k = 0; k < keyCount; ++k) {
        const key = aKeys[k];
        if (!check(a[key], b[key])) {
          return false;
        }
      }
      return true;
    }
    case "[object Error]":
      return a.name === b.name && a.message === b.message;
    case "[object Number]":
      if (a !== a)
        return b !== b;
    // Fall through to shared +a === +b case...
    case "[object Boolean]":
    case "[object Date]":
      return +a === +b;
    case "[object RegExp]":
    case "[object String]":
      return a == `${b}`;
    case "[object Map]":
    case "[object Set]": {
      if (a.size !== b.size)
        return false;
      if (previouslyCompared(a, b))
        return true;
      const aIterator = a.entries();
      const isMap = aTag === "[object Map]";
      while (true) {
        const info = aIterator.next();
        if (info.done)
          break;
        const [aKey, aValue] = info.value;
        if (!b.has(aKey)) {
          return false;
        }
        if (isMap && !check(aValue, b.get(aKey))) {
          return false;
        }
      }
      return true;
    }
    case "[object Uint16Array]":
    case "[object Uint8Array]":
    // Buffer, in Node.js.
    case "[object Uint32Array]":
    case "[object Int32Array]":
    case "[object Int8Array]":
    case "[object Int16Array]":
    case "[object ArrayBuffer]":
      a = new Uint8Array(a);
      b = new Uint8Array(b);
    // Fall through...
    case "[object DataView]": {
      let len = a.byteLength;
      if (len === b.byteLength) {
        while (len-- && a[len] === b[len]) {
        }
      }
      return len === -1;
    }
    case "[object AsyncFunction]":
    case "[object GeneratorFunction]":
    case "[object AsyncGeneratorFunction]":
    case "[object Function]": {
      const aCode = fnToStr.call(a);
      if (aCode !== fnToStr.call(b)) {
        return false;
      }
      return !endsWith(aCode, nativeCodeSuffix);
    }
  }
  return false;
}
function definedKeys(obj) {
  return Object.keys(obj).filter(isDefinedKey, obj);
}
function isDefinedKey(key) {
  return this[key] !== void 0;
}
var nativeCodeSuffix = "{ [native code] }";
function endsWith(full, suffix) {
  const fromIndex = full.length - suffix.length;
  return fromIndex >= 0 && full.indexOf(suffix, fromIndex) === fromIndex;
}
function previouslyCompared(a, b) {
  let bSet = previousComparisons.get(a);
  if (bSet) {
    if (bSet.has(b))
      return true;
  } else {
    previousComparisons.set(a, bSet = /* @__PURE__ */ new Set());
  }
  bSet.add(b);
  return false;
}

// node_modules/@apollo/client/utilities/internal/equalByQuery.js
function equalByQuery(query, { data: aData, ...aRest }, { data: bData, ...bRest }, variables) {
  return equal(aRest, bRest) && equalBySelectionSet(getMainDefinition(query).selectionSet, aData, bData, {
    fragmentMap: createFragmentMap(getFragmentDefinitions(query)),
    variables
  });
}
function equalBySelectionSet(selectionSet, aResult, bResult, context) {
  if (aResult === bResult) {
    return true;
  }
  const seenSelections = /* @__PURE__ */ new Set();
  return selectionSet.selections.every((selection) => {
    if (seenSelections.has(selection))
      return true;
    seenSelections.add(selection);
    if (!shouldInclude(selection, context.variables))
      return true;
    if (selectionHasNonreactiveDirective(selection))
      return true;
    if (isField(selection)) {
      const resultKey = resultKeyNameFromField(selection);
      const aResultChild = aResult && aResult[resultKey];
      const bResultChild = bResult && bResult[resultKey];
      const childSelectionSet = selection.selectionSet;
      if (!childSelectionSet) {
        return equal(aResultChild, bResultChild);
      }
      const aChildIsArray = Array.isArray(aResultChild);
      const bChildIsArray = Array.isArray(bResultChild);
      if (aChildIsArray !== bChildIsArray)
        return false;
      if (aChildIsArray && bChildIsArray) {
        const length = aResultChild.length;
        if (bResultChild.length !== length) {
          return false;
        }
        for (let i = 0; i < length; ++i) {
          if (!equalBySelectionSet(childSelectionSet, aResultChild[i], bResultChild[i], context)) {
            return false;
          }
        }
        return true;
      }
      return equalBySelectionSet(childSelectionSet, aResultChild, bResultChild, context);
    } else {
      const fragment = getFragmentFromSelection(selection, context.fragmentMap);
      if (fragment) {
        if (selectionHasNonreactiveDirective(fragment))
          return true;
        return equalBySelectionSet(
          fragment.selectionSet,
          // Notice that we reuse the same aResult and bResult values here,
          // since the fragment ...spread does not specify a field name, but
          // consists of multiple fields (within the fragment's selection set)
          // that should be applied to the current result value(s).
          aResult,
          bResult,
          context
        );
      }
    }
  });
}
function selectionHasNonreactiveDirective(selection) {
  return !!selection.directives && selection.directives.some(directiveIsNonreactive);
}
function directiveIsNonreactive(dir) {
  return dir.name.value === "nonreactive";
}

// node_modules/@apollo/client/incremental/handlers/notImplemented.js
var NotImplementedHandler = class {
  constructor() {
    // This code path can never be reached, so we won't implement it.
    __publicField(this, "startRequest");
  }
  isIncrementalResult(_) {
    return false;
  }
  prepareRequest(request) {
    invariant2(!hasDirectives(["defer"], request.query), 64);
    return request;
  }
  extractErrors() {
  }
};

// node_modules/@apollo/client/link/core/ApolloLink.js
var import_rxjs2 = __toESM(require_cjs(), 1);

// node_modules/@apollo/client/link/utils/createOperation.js
function createOperation(request, { client }) {
  const operation = {
    query: request.query,
    variables: request.variables || {},
    extensions: request.extensions || {},
    operationName: getOperationName(request.query),
    operationType: getOperationDefinition(request.query).operation
  };
  let context = { ...request.context };
  const setContext = (next) => {
    if (typeof next === "function") {
      context = { ...context, ...next(getContext()) };
    } else {
      context = { ...context, ...next };
    }
  };
  const getContext = () => Object.freeze({ ...context });
  Object.defineProperty(operation, "setContext", {
    enumerable: false,
    value: setContext
  });
  Object.defineProperty(operation, "getContext", {
    enumerable: false,
    value: getContext
  });
  Object.defineProperty(operation, "client", {
    enumerable: false,
    value: client
  });
  return operation;
}

// node_modules/@apollo/client/link/utils/filterOperationVariables.js
function filterOperationVariables(variables, query) {
  const result = { ...variables };
  const unusedNames = new Set(Object.keys(variables));
  visit(query, {
    Variable(node, _key, parent) {
      if (parent && parent.kind !== "VariableDefinition") {
        unusedNames.delete(node.name.value);
      }
    }
  });
  unusedNames.forEach((name) => {
    delete result[name];
  });
  return result;
}

// node_modules/@apollo/client/link/core/ApolloLink.js
var ApolloLink = class _ApolloLink {
  constructor(request) {
    /**
    * @internal
    * Used to iterate through all links that are concatenations or `split` links.
    * 
    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
    */
    __publicField(this, "left");
    /**
    * @internal
    * Used to iterate through all links that are concatenations or `split` links.
    * 
    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
    */
    __publicField(this, "right");
    if (request)
      this.request = request;
  }
  /**
   * Creates a link that completes immediately and does not emit a result.
   *
   * @example
   *
   * ```ts
   * const link = ApolloLink.empty();
   * ```
   */
  static empty() {
    return new _ApolloLink(() => import_rxjs2.EMPTY);
  }
  /**
   * Composes multiple links into a single composed link that executes each
   * provided link in serial order.
   *
   * @example
   *
   * ```ts
   * import { from, HttpLink, ApolloLink } from "@apollo/client";
   * import { RetryLink } from "@apollo/client/link/retry";
   * import MyAuthLink from "../auth";
   *
   * const link = ApolloLink.from([
   *   new RetryLink(),
   *   new MyAuthLink(),
   *   new HttpLink({ uri: "http://localhost:4000/graphql" }),
   * ]);
   * ```
   *
   * @param links - An array of `ApolloLink` instances or request handlers that
   * are executed in serial order.
   */
  static from(links) {
    if (links.length === 0)
      return _ApolloLink.empty();
    const [first, ...rest] = links;
    return first.concat(...rest);
  }
  /**
   * Creates a link that conditionally routes a request to different links.
   *
   * @example
   *
   * ```ts
   * import { ApolloLink, HttpLink } from "@apollo/client";
   *
   * const link = ApolloLink.split(
   *   (operation) => operation.getContext().version === 1,
   *   new HttpLink({ uri: "http://localhost:4000/v1/graphql" }),
   *   new HttpLink({ uri: "http://localhost:4000/v2/graphql" })
   * );
   * ```
   *
   * @param test - A predicate function that receives the current `operation`
   * and returns a boolean indicating which link to execute. Returning `true`
   * executes the `left` link. Returning `false` executes the `right` link.
   *
   * @param left - The link that executes when the `test` function returns
   * `true`.
   *
   * @param right - The link that executes when the `test` function returns
   * `false`. If the `right` link is not provided, the request is forwarded to
   * the next link in the chain.
   */
  static split(test, left, right = new _ApolloLink((op, forward) => forward(op))) {
    const link = new _ApolloLink((operation, forward) => {
      const result = test(operation);
      if (__DEV__) {
        if (typeof result !== "boolean") {
          __DEV__ && invariant2.warn(61, result);
        }
      }
      return result ? left.request(operation, forward) : right.request(operation, forward);
    });
    return Object.assign(link, { left, right });
  }
  /**
   * Executes a GraphQL request against a link. The `execute` function begins
   * the request by calling the request handler of the link.
   *
   * @example
   *
   * ```ts
   * const observable = ApolloLink.execute(link, { query, variables }, { client });
   *
   * observable.subscribe({
   *   next(value) {
   *     console.log("Received", value);
   *   },
   *   error(error) {
   *     console.error("Oops got error", error);
   *   },
   *   complete() {
   *     console.log("Request complete");
   *   },
   * });
   * ```
   *
   * @param link - The `ApolloLink` instance to execute the request.
   *
   * @param request - The GraphQL request details, such as the `query` and
   * `variables`.
   *
   * @param context - The execution context for the request, such as the
   * `client` making the request.
   */
  static execute(link, request, context) {
    return link.request(createOperation(request, context), () => {
      if (__DEV__) {
        __DEV__ && invariant2.warn(62);
      }
      return import_rxjs2.EMPTY;
    });
  }
  /**
   * Combines multiple links into a single composed link.
   *
   * @example
   *
   * ```ts
   * const link = ApolloLink.concat(firstLink, secondLink, thirdLink);
   * ```
   *
   * @param links - The links to concatenate into a single link. Each link will
   * execute in serial order.
   *
   * @deprecated Use `ApolloLink.from` instead. `ApolloLink.concat` will be
   * removed in a future major version.
   */
  static concat(...links) {
    return _ApolloLink.from(links);
  }
  /**
   * Concatenates a link that conditionally routes a request to different links.
   *
   * @example
   *
   * ```ts
   * import { ApolloLink, HttpLink } from "@apollo/client";
   *
   * const previousLink = new ApolloLink((operation, forward) => {
   *   // Handle the request
   *
   *   return forward(operation);
   * });
   *
   * const link = previousLink.split(
   *   (operation) => operation.getContext().version === 1,
   *   new HttpLink({ uri: "http://localhost:4000/v1/graphql" }),
   *   new HttpLink({ uri: "http://localhost:4000/v2/graphql" })
   * );
   * ```
   *
   * @param test - A predicate function that receives the current `operation`
   * and returns a boolean indicating which link to execute. Returning `true`
   * executes the `left` link. Returning `false` executes the `right` link.
   *
   * @param left - The link that executes when the `test` function returns
   * `true`.
   *
   * @param right - The link that executes when the `test` function returns
   * `false`. If the `right` link is not provided, the request is forwarded to
   * the next link in the chain.
   */
  split(test, left, right) {
    return this.concat(_ApolloLink.split(test, left, right));
  }
  /**
   * Combines the link with other links into a single composed link.
   *
   * @example
   *
   * ```ts
   * import { ApolloLink, HttpLink } from "@apollo/client";
   *
   * const previousLink = new ApolloLink((operation, forward) => {
   *   // Handle the request
   *
   *   return forward(operation);
   * });
   *
   * const link = previousLink.concat(
   *   link1,
   *   link2,
   *   new HttpLink({ uri: "http://localhost:4000/graphql" })
   * );
   * ```
   */
  concat(...links) {
    if (links.length === 0) {
      return this;
    }
    return links.reduce(this.combine.bind(this), this);
  }
  combine(left, right) {
    const link = new _ApolloLink((operation, forward) => {
      return left.request(operation, (op) => right.request(op, forward));
    });
    return Object.assign(link, { left, right });
  }
  /**
   * Runs the request handler for the provided operation.
   *
   * > [!NOTE]
   * > This is called by the `ApolloLink.execute` function for you and should
   * > not be called directly. Prefer using `ApolloLink.execute` to make the
   * > request instead.
   */
  request(operation, forward) {
    throw newInvariantError(63);
  }
};

// node_modules/@apollo/client/link/core/empty.js
var empty = ApolloLink.empty;

// node_modules/@apollo/client/link/core/from.js
var from = ApolloLink.from;

// node_modules/@apollo/client/link/core/split.js
var split = ApolloLink.split;

// node_modules/@apollo/client/link/core/concat.js
var concat = ApolloLink.concat;

// node_modules/@apollo/client/link/core/execute.js
var execute = ApolloLink.execute;

// node_modules/@apollo/client/utilities/index.js
var import_rxjs3 = __toESM(require_cjs());

// node_modules/@apollo/client/utilities/graphql/DocumentTransform.js
function identity(document) {
  return document;
}
var DocumentTransform = class _DocumentTransform {
  constructor(transform, options = {}) {
    __publicField(this, "transform");
    __publicField(this, "cached");
    __publicField(this, "resultCache", /* @__PURE__ */ new WeakSet());
    /**
    * @internal
    * Used to iterate through all transforms that are concatenations or `split` links.
    * 
    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
    */
    __publicField(this, "left");
    /**
    * @internal
    * Used to iterate through all transforms that are concatenations or `split` links.
    * 
    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
    */
    __publicField(this, "right");
    this.transform = transform;
    if (options.getCacheKey) {
      this.getCacheKey = options.getCacheKey;
    }
    this.cached = options.cache !== false;
    this.resetCache();
  }
  // This default implementation of getCacheKey can be overridden by providing
  // options.getCacheKey to the DocumentTransform constructor. In general, a
  // getCacheKey function may either return an array of keys (often including
  // the document) to be used as a cache key, or undefined to indicate the
  // transform for this document should not be cached.
  getCacheKey(document) {
    return [document];
  }
  /**
   * Creates a DocumentTransform that returns the input document unchanged.
   *
   * @returns The input document
   */
  static identity() {
    return new _DocumentTransform(identity, { cache: false });
  }
  /**
   * Creates a DocumentTransform that conditionally applies one of two transforms.
   *
   * @param predicate - Function that determines which transform to apply
   * @param left - Transform to apply when `predicate` returns `true`
   * @param right - Transform to apply when `predicate` returns `false`. If not provided, it defaults to `DocumentTransform.identity()`.
   * @returns A DocumentTransform that conditionally applies a document transform based on the predicate
   *
   * @example
   *
   * ```ts
   * import { isQueryOperation } from "@apollo/client/utilities";
   *
   * const conditionalTransform = DocumentTransform.split(
   *   (document) => isQueryOperation(document),
   *   queryTransform,
   *   mutationTransform
   * );
   * ```
   */
  static split(predicate, left, right = _DocumentTransform.identity()) {
    return Object.assign(new _DocumentTransform(
      (document) => {
        const documentTransform = predicate(document) ? left : right;
        return documentTransform.transformDocument(document);
      },
      // Reasonably assume both `left` and `right` transforms handle their own caching
      { cache: false }
    ), { left, right });
  }
  /**
   * Resets the internal cache of this transform, if it is cached.
   */
  resetCache() {
    if (this.cached) {
      const stableCacheKeys = new Trie();
      this.performWork = wrap(_DocumentTransform.prototype.performWork.bind(this), {
        makeCacheKey: (document) => {
          const cacheKeys = this.getCacheKey(document);
          if (cacheKeys) {
            invariant2(Array.isArray(cacheKeys), 20);
            return stableCacheKeys.lookupArray(cacheKeys);
          }
        },
        max: cacheSizes["documentTransform.cache"],
        cache: WeakCache
      });
    }
  }
  performWork(document) {
    checkDocument(document);
    return this.transform(document);
  }
  /**
   * Transforms a GraphQL document using the configured transform function.
   *
   * @remarks
   *
   * Note that `transformDocument` caches the transformed document. Calling
   * `transformDocument` again with the already-transformed document will
   * immediately return it.
   *
   * @param document - The GraphQL document to transform
   * @returns The transformed document
   *
   * @example
   *
   * ```ts
   * const document = gql`
   *   # ...
   * `;
   *
   * const documentTransform = new DocumentTransform(transformFn);
   * const transformedDocument = documentTransform.transformDocument(document);
   * ```
   */
  transformDocument(document) {
    if (this.resultCache.has(document)) {
      return document;
    }
    const transformedDocument = this.performWork(document);
    this.resultCache.add(transformedDocument);
    return transformedDocument;
  }
  /**
   * Combines this document transform with another document transform. The
   * returned document transform first applies the current document transform,
   * then applies the other document transform.
   *
   * @param otherTransform - The transform to apply after this one
   * @returns A new DocumentTransform that applies both transforms in sequence
   *
   * @example
   *
   * ```ts
   * const combinedTransform = addTypenameTransform.concat(
   *   removeDirectivesTransform
   * );
   * ```
   */
  concat(otherTransform) {
    return Object.assign(new _DocumentTransform(
      (document) => {
        return otherTransform.transformDocument(this.transformDocument(document));
      },
      // Reasonably assume both transforms handle their own caching
      { cache: false }
    ), {
      left: this,
      right: otherTransform
    });
  }
};

// node_modules/@apollo/client/utilities/graphql/print.js
var printCache;
var print2 = Object.assign((ast) => {
  let result = printCache.get(ast);
  if (!result) {
    result = print(ast);
    printCache.set(ast, result);
  }
  return result;
}, {
  reset() {
    printCache = new AutoCleanedWeakCache(
      cacheSizes.print || 2e3
      /* defaultCacheSizes.print */
    );
  }
});
print2.reset();
if (__DEV__) {
  registerGlobalCache("print", () => printCache ? printCache.size : 0);
}

// node_modules/@apollo/client/utilities/graphql/storeUtils.js
function isReference(obj) {
  return Boolean(obj && typeof obj === "object" && typeof obj.__ref === "string");
}

// node_modules/@apollo/client/utilities/graphql/transform.js
var TYPENAME_FIELD = {
  kind: Kind.FIELD,
  name: {
    kind: Kind.NAME,
    value: "__typename"
  }
};
var addTypenameToDocument = Object.assign(function(doc) {
  return visit(doc, {
    SelectionSet: {
      enter(node, _key, parent) {
        if (parent && parent.kind === Kind.OPERATION_DEFINITION) {
          return;
        }
        const { selections } = node;
        if (!selections) {
          return;
        }
        const skip = selections.some((selection) => {
          return selection.kind === Kind.FIELD && (selection.name.value === "__typename" || selection.name.value.lastIndexOf("__", 0) === 0);
        });
        if (skip) {
          return;
        }
        const field = parent;
        if (field.kind === Kind.FIELD && field.directives && field.directives.some((d) => d.name.value === "export")) {
          return;
        }
        return {
          ...node,
          selections: [...selections, TYPENAME_FIELD]
        };
      }
    }
  });
}, {
  added(field) {
    return field === TYPENAME_FIELD;
  }
});

// node_modules/@apollo/client/utilities/graphql/operations.js
function isOperation(document, operation) {
  var _a2;
  return ((_a2 = getOperationDefinition(document)) == null ? void 0 : _a2.operation) === operation;
}
function isMutationOperation(document) {
  return isOperation(document, "mutation");
}
function isSubscriptionOperation(document) {
  return isOperation(document, "subscription");
}

// node_modules/@apollo/client/utilities/isNetworkRequestSettled.js
function isNetworkRequestSettled(networkStatus) {
  return networkStatus === 7 || networkStatus === 8;
}

// node_modules/@apollo/client/utilities/isNetworkRequestInFlight.js
function isNetworkRequestInFlight(networkStatus) {
  return !isNetworkRequestSettled(networkStatus);
}

// node_modules/@apollo/client/core/QueryManager.js
var import_rxjs6 = __toESM(require_cjs(), 1);
var import_rxjs7 = __toESM(require_cjs(), 1);

// node_modules/@apollo/client/cache/core/cache.js
var import_rxjs4 = __toESM(require_cjs(), 1);
var ApolloCache = class {
  constructor() {
    __publicField(this, "assumeImmutableResults", false);
    // Make sure we compute the same (===) fragment query document every
    // time we receive the same fragment in readFragment.
    __publicField(this, "getFragmentDoc", wrap(getFragmentQueryDocument, {
      max: cacheSizes["cache.fragmentQueryDocuments"] || 1e3,
      cache: WeakCache
    }));
  }
  // Function used to lookup a fragment when a fragment definition is not part
  // of the GraphQL document. This is useful for caches, such as InMemoryCache,
  // that register fragments ahead of time so they can be referenced by name.
  lookupFragment(fragmentName) {
    return null;
  }
  // Transactional API
  // The batch method is intended to replace/subsume both performTransaction
  // and recordOptimisticTransaction, but performTransaction came first, so we
  // provide a default batch implementation that's just another way of calling
  // performTransaction. Subclasses of ApolloCache (such as InMemoryCache) can
  // override the batch method to do more interesting things with its options.
  batch(options) {
    const optimisticId = typeof options.optimistic === "string" ? options.optimistic : options.optimistic === false ? null : void 0;
    let updateResult;
    this.performTransaction(() => updateResult = options.update(this), optimisticId);
    return updateResult;
  }
  recordOptimisticTransaction(transaction, optimisticId) {
    this.performTransaction(transaction, optimisticId);
  }
  // Optional API
  // Called once per input document, allowing the cache to make static changes
  // to the query, such as adding __typename fields.
  transformDocument(document) {
    return document;
  }
  // Called before each ApolloLink request, allowing the cache to make dynamic
  // changes to the query, such as filling in missing fragment definitions.
  transformForLink(document) {
    return document;
  }
  identify(object) {
    return;
  }
  gc() {
    return [];
  }
  modify(options) {
    return false;
  }
  readQuery(options, optimistic = !!options.optimistic) {
    return this.read({
      ...options,
      rootId: options.id || "ROOT_QUERY",
      optimistic
    });
  }
  /**
  * Watches the cache store of the fragment according to the options specified
  * and returns an `Observable`. We can subscribe to this
  * `Observable` and receive updated results through an
  * observer when the cache store changes.
  * 
  * You must pass in a GraphQL document with a single fragment or a document
  * with multiple fragments that represent what you are reading. If you pass
  * in a document with multiple fragments then you must also specify a
  * `fragmentName`.
  * 
  * @since 3.10.0
  * @param options - An object of type `WatchFragmentOptions` that allows
  * the cache to identify the fragment and optionally specify whether to react
  * to optimistic updates.
  */
  watchFragment(options) {
    const { fragment, fragmentName, from: from3, optimistic = true, ...otherOptions } = options;
    const query = this.getFragmentDoc(fragment, fragmentName);
    const id = typeof from3 === "undefined" || typeof from3 === "string" ? from3 : this.identify(from3);
    if (__DEV__) {
      const actualFragmentName = fragmentName || getFragmentDefinition(fragment).name.value;
      if (!id) {
        __DEV__ && invariant2.warn(109, actualFragmentName);
      }
    }
    const diffOptions = {
      ...otherOptions,
      returnPartialData: true,
      id,
      query,
      optimistic
    };
    let latestDiff;
    return new import_rxjs4.Observable((observer) => {
      return this.watch({
        ...diffOptions,
        immediate: true,
        callback: (diff) => {
          let data = diff.result;
          if (data === null) {
            data = {};
          }
          if (
            // Always ensure we deliver the first result
            latestDiff && equalByQuery(query, { data: latestDiff.result }, { data }, options.variables)
          ) {
            return;
          }
          const result = {
            data,
            dataState: diff.complete ? "complete" : "partial",
            complete: !!diff.complete
          };
          if (diff.missing) {
            result.missing = diff.missing.missing;
          }
          latestDiff = { ...diff, result: data };
          observer.next(result);
        }
      });
    });
  }
  readFragment(options, optimistic = !!options.optimistic) {
    return this.read({
      ...options,
      query: this.getFragmentDoc(options.fragment, options.fragmentName),
      rootId: options.id,
      optimistic
    });
  }
  writeQuery({ id, data, ...options }) {
    return this.write(Object.assign(options, {
      dataId: id || "ROOT_QUERY",
      result: data
    }));
  }
  writeFragment({ id, data, fragment, fragmentName, ...options }) {
    return this.write(Object.assign(options, {
      query: this.getFragmentDoc(fragment, fragmentName),
      dataId: id,
      result: data
    }));
  }
  updateQuery(options, update) {
    return this.batch({
      update(cache) {
        const value = cache.readQuery(options);
        const data = update(value);
        if (data === void 0 || data === null)
          return value;
        cache.writeQuery({ ...options, data });
        return data;
      }
    });
  }
  updateFragment(options, update) {
    return this.batch({
      update(cache) {
        const value = cache.readFragment(options);
        const data = update(value);
        if (data === void 0 || data === null)
          return value;
        cache.writeFragment({ ...options, data });
        return data;
      }
    });
  }
};
if (__DEV__) {
  ApolloCache.prototype.getMemoryInternals = getApolloCacheMemoryInternals;
}

// node_modules/@apollo/client/cache/core/types/common.js
var MissingFieldError = class _MissingFieldError extends Error {
  constructor(message, path, query, variables) {
    super(message);
    __publicField(this, "message");
    __publicField(this, "path");
    __publicField(this, "query");
    __publicField(this, "variables");
    __publicField(this, "missing");
    this.message = message;
    this.path = path;
    this.query = query;
    this.variables = variables;
    this.name = "MissingFieldError";
    if (Array.isArray(this.path)) {
      this.missing = this.message;
      for (let i = this.path.length - 1; i >= 0; --i) {
        this.missing = { [this.path[i]]: this.missing };
      }
    } else {
      this.missing = this.path;
    }
    this.__proto__ = _MissingFieldError.prototype;
  }
};

// node_modules/@apollo/client/cache/inmemory/helpers.js
var { hasOwnProperty: hasOwn } = Object.prototype;
function defaultDataIdFromObject({ __typename, id, _id }, context) {
  if (typeof __typename === "string") {
    if (context) {
      context.keyObject = id != null ? { id } : _id != null ? { _id } : void 0;
    }
    if (id == null && _id != null) {
      id = _id;
    }
    if (id != null) {
      return `${__typename}:${typeof id === "number" || typeof id === "string" ? id : JSON.stringify(id)}`;
    }
  }
}
var defaultConfig = {
  dataIdFromObject: defaultDataIdFromObject,
  resultCaching: true
};
function normalizeConfig(config) {
  return compact(defaultConfig, config);
}
function getTypenameFromStoreObject(store, objectOrReference) {
  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, "__typename") : objectOrReference && objectOrReference.__typename;
}
var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;
function fieldNameFromStoreName(storeFieldName) {
  const match = storeFieldName.match(TypeOrFieldNameRegExp);
  return match ? match[0] : storeFieldName;
}
function selectionSetMatchesResult(selectionSet, result, variables) {
  if (isNonNullObject(result)) {
    return isArray(result) ? result.every((item) => selectionSetMatchesResult(selectionSet, item, variables)) : selectionSet.selections.every((field) => {
      if (isField(field) && shouldInclude(field, variables)) {
        const key = resultKeyNameFromField(field);
        return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));
      }
      return true;
    });
  }
  return false;
}
function storeValueIsStoreObject(value) {
  return isNonNullObject(value) && !isReference(value) && !isArray(value);
}
function makeProcessedFieldsMerger() {
  return new DeepMerger();
}
function extractFragmentContext(document, fragments) {
  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));
  return {
    fragmentMap,
    lookupFragment(name) {
      let def = fragmentMap[name];
      if (!def && fragments) {
        def = fragments.lookup(name);
      }
      return def || null;
    }
  };
}

// node_modules/@apollo/client/cache/inmemory/entityStore.js
var DELETE = {};
var delModifier = () => DELETE;
var INVALIDATE = {};
var EntityStore = class {
  constructor(policies, group) {
    __publicField(this, "policies");
    __publicField(this, "group");
    __publicField(this, "data", {});
    // Maps root entity IDs to the number of times they have been retained, minus
    // the number of times they have been released. Retained entities keep other
    // entities they reference (even indirectly) from being garbage collected.
    __publicField(this, "rootIds", {});
    // Lazily tracks { __ref: <dataId> } strings contained by this.data[dataId].
    __publicField(this, "refs", {});
    // Bound function that can be passed around to provide easy access to fields
    // of Reference objects as well as ordinary objects.
    __publicField(this, "getFieldValue", (objectOrReference, storeFieldName) => maybeDeepFreeze(isReference(objectOrReference) ? this.get(objectOrReference.__ref, storeFieldName) : objectOrReference && objectOrReference[storeFieldName]));
    // Returns true for non-normalized StoreObjects and non-dangling
    // References, indicating that readField(name, objOrRef) has a chance of
    // working. Useful for filtering out dangling references from lists.
    __publicField(this, "canRead", (objOrRef) => {
      return isReference(objOrRef) ? this.has(objOrRef.__ref) : typeof objOrRef === "object";
    });
    // Bound function that converts an id or an object with a __typename and
    // primary key fields to a Reference object. If called with a Reference object,
    // that same Reference object is returned. Pass true for mergeIntoStore to persist
    // an object into the store.
    __publicField(this, "toReference", (objOrIdOrRef, mergeIntoStore) => {
      if (typeof objOrIdOrRef === "string") {
        return makeReference(objOrIdOrRef);
      }
      if (isReference(objOrIdOrRef)) {
        return objOrIdOrRef;
      }
      const [id] = this.policies.identify(objOrIdOrRef);
      if (id) {
        const ref = makeReference(id);
        if (mergeIntoStore) {
          this.merge(id, objOrIdOrRef);
        }
        return ref;
      }
    });
    this.policies = policies;
    this.group = group;
  }
  // Although the EntityStore class is abstract, it contains concrete
  // implementations of the various NormalizedCache interface methods that
  // are inherited by the Root and Layer subclasses.
  toObject() {
    return { ...this.data };
  }
  has(dataId) {
    return this.lookup(dataId, true) !== void 0;
  }
  get(dataId, fieldName) {
    this.group.depend(dataId, fieldName);
    if (hasOwn.call(this.data, dataId)) {
      const storeObject = this.data[dataId];
      if (storeObject && hasOwn.call(storeObject, fieldName)) {
        return storeObject[fieldName];
      }
    }
    if (fieldName === "__typename" && hasOwn.call(this.policies.rootTypenamesById, dataId)) {
      return this.policies.rootTypenamesById[dataId];
    }
    if (this instanceof Layer) {
      return this.parent.get(dataId, fieldName);
    }
  }
  lookup(dataId, dependOnExistence) {
    if (dependOnExistence)
      this.group.depend(dataId, "__exists");
    if (hasOwn.call(this.data, dataId)) {
      return this.data[dataId];
    }
    if (this instanceof Layer) {
      return this.parent.lookup(dataId, dependOnExistence);
    }
    if (this.policies.rootTypenamesById[dataId]) {
      return {};
    }
  }
  merge(older, newer) {
    let dataId;
    if (isReference(older))
      older = older.__ref;
    if (isReference(newer))
      newer = newer.__ref;
    const existing = typeof older === "string" ? this.lookup(dataId = older) : older;
    const incoming = typeof newer === "string" ? this.lookup(dataId = newer) : newer;
    if (!incoming)
      return;
    invariant2(typeof dataId === "string", 95);
    const merged = new DeepMerger(storeObjectReconciler).merge(existing, incoming);
    this.data[dataId] = merged;
    if (merged !== existing) {
      delete this.refs[dataId];
      if (this.group.caching) {
        const fieldsToDirty = {};
        if (!existing)
          fieldsToDirty.__exists = 1;
        Object.keys(incoming).forEach((storeFieldName) => {
          if (!existing || existing[storeFieldName] !== merged[storeFieldName]) {
            fieldsToDirty[storeFieldName] = 1;
            const fieldName = fieldNameFromStoreName(storeFieldName);
            if (fieldName !== storeFieldName && !this.policies.hasKeyArgs(merged.__typename, fieldName)) {
              fieldsToDirty[fieldName] = 1;
            }
            if (merged[storeFieldName] === void 0 && !(this instanceof Layer)) {
              delete merged[storeFieldName];
            }
          }
        });
        if (fieldsToDirty.__typename && !(existing && existing.__typename) && // Since we return default root __typename strings
        // automatically from store.get, we don't need to dirty the
        // ROOT_QUERY.__typename field if merged.__typename is equal
        // to the default string (usually "Query").
        this.policies.rootTypenamesById[dataId] === merged.__typename) {
          delete fieldsToDirty.__typename;
        }
        Object.keys(fieldsToDirty).forEach((fieldName) => this.group.dirty(dataId, fieldName));
      }
    }
  }
  modify(dataId, fields, exact) {
    const storeObject = this.lookup(dataId);
    if (storeObject) {
      const changedFields = {};
      let needToMerge = false;
      let allDeleted = true;
      const sharedDetails = {
        DELETE,
        INVALIDATE,
        isReference,
        toReference: this.toReference,
        canRead: this.canRead,
        readField: (fieldNameOrOptions, from3) => this.policies.readField(typeof fieldNameOrOptions === "string" ? {
          fieldName: fieldNameOrOptions,
          from: from3 || makeReference(dataId)
        } : fieldNameOrOptions, { store: this })
      };
      Object.keys(storeObject).forEach((storeFieldName) => {
        const fieldName = fieldNameFromStoreName(storeFieldName);
        let fieldValue = storeObject[storeFieldName];
        if (fieldValue === void 0)
          return;
        const modify = typeof fields === "function" ? fields : fields[storeFieldName] || (exact ? void 0 : fields[fieldName]);
        if (modify) {
          let newValue = modify === delModifier ? DELETE : modify(maybeDeepFreeze(fieldValue), {
            ...sharedDetails,
            fieldName,
            storeFieldName,
            storage: this.getStorage(dataId, storeFieldName)
          });
          if (newValue === INVALIDATE) {
            this.group.dirty(dataId, storeFieldName);
          } else {
            if (newValue === DELETE)
              newValue = void 0;
            if (newValue !== fieldValue) {
              changedFields[storeFieldName] = newValue;
              needToMerge = true;
              fieldValue = newValue;
              if (__DEV__) {
                const checkReference = (ref) => {
                  if (this.lookup(ref.__ref) === void 0) {
                    __DEV__ && invariant2.warn(96, ref);
                    return true;
                  }
                };
                if (isReference(newValue)) {
                  checkReference(newValue);
                } else if (Array.isArray(newValue)) {
                  let seenReference = false;
                  let someNonReference;
                  for (const value of newValue) {
                    if (isReference(value)) {
                      seenReference = true;
                      if (checkReference(value))
                        break;
                    } else {
                      if (typeof value === "object" && !!value) {
                        const [id] = this.policies.identify(value);
                        if (id) {
                          someNonReference = value;
                        }
                      }
                    }
                    if (seenReference && someNonReference !== void 0) {
                      __DEV__ && invariant2.warn(97, someNonReference);
                      break;
                    }
                  }
                }
              }
            }
          }
        }
        if (fieldValue !== void 0) {
          allDeleted = false;
        }
      });
      if (needToMerge) {
        this.merge(dataId, changedFields);
        if (allDeleted) {
          if (this instanceof Layer) {
            this.data[dataId] = void 0;
          } else {
            delete this.data[dataId];
          }
          this.group.dirty(dataId, "__exists");
        }
        return true;
      }
    }
    return false;
  }
  // If called with only one argument, removes the entire entity
  // identified by dataId. If called with a fieldName as well, removes all
  // fields of that entity whose names match fieldName according to the
  // fieldNameFromStoreName helper function. If called with a fieldName
  // and variables, removes all fields of that entity whose names match fieldName
  // and whose arguments when cached exactly match the variables passed.
  delete(dataId, fieldName, args) {
    const storeObject = this.lookup(dataId);
    if (storeObject) {
      const typename = this.getFieldValue(storeObject, "__typename");
      const storeFieldName = fieldName && args ? this.policies.getStoreFieldName({ typename, fieldName, args }) : fieldName;
      return this.modify(dataId, storeFieldName ? {
        [storeFieldName]: delModifier
      } : delModifier, !!args);
    }
    return false;
  }
  evict(options, limit) {
    let evicted = false;
    if (options.id) {
      if (hasOwn.call(this.data, options.id)) {
        evicted = this.delete(options.id, options.fieldName, options.args);
      }
      if (this instanceof Layer && this !== limit) {
        evicted = this.parent.evict(options, limit) || evicted;
      }
      if (options.fieldName || evicted) {
        this.group.dirty(options.id, options.fieldName || "__exists");
      }
    }
    return evicted;
  }
  clear() {
    this.replace(null);
  }
  extract() {
    const obj = this.toObject();
    const extraRootIds = [];
    this.getRootIdSet().forEach((id) => {
      if (!hasOwn.call(this.policies.rootTypenamesById, id)) {
        extraRootIds.push(id);
      }
    });
    if (extraRootIds.length) {
      obj.__META = { extraRootIds: extraRootIds.sort() };
    }
    return obj;
  }
  replace(newData) {
    Object.keys(this.data).forEach((dataId) => {
      if (!(newData && hasOwn.call(newData, dataId))) {
        this.delete(dataId);
      }
    });
    if (newData) {
      const { __META, ...rest } = newData;
      Object.keys(rest).forEach((dataId) => {
        this.merge(dataId, rest[dataId]);
      });
      if (__META) {
        __META.extraRootIds.forEach(this.retain, this);
      }
    }
  }
  retain(rootId) {
    return this.rootIds[rootId] = (this.rootIds[rootId] || 0) + 1;
  }
  release(rootId) {
    if (this.rootIds[rootId] > 0) {
      const count = --this.rootIds[rootId];
      if (!count)
        delete this.rootIds[rootId];
      return count;
    }
    return 0;
  }
  // Return a Set<string> of all the ID strings that have been retained by
  // this layer/root *and* any layers/roots beneath it.
  getRootIdSet(ids = /* @__PURE__ */ new Set()) {
    Object.keys(this.rootIds).forEach(ids.add, ids);
    if (this instanceof Layer) {
      this.parent.getRootIdSet(ids);
    } else {
      Object.keys(this.policies.rootTypenamesById).forEach(ids.add, ids);
    }
    return ids;
  }
  // The goal of garbage collection is to remove IDs from the Root layer of the
  // store that are no longer reachable starting from any IDs that have been
  // explicitly retained (see retain and release, above). Returns an array of
  // dataId strings that were removed from the store.
  gc() {
    const ids = this.getRootIdSet();
    const snapshot = this.toObject();
    ids.forEach((id) => {
      if (hasOwn.call(snapshot, id)) {
        Object.keys(this.findChildRefIds(id)).forEach(ids.add, ids);
        delete snapshot[id];
      }
    });
    const idsToRemove = Object.keys(snapshot);
    if (idsToRemove.length) {
      let root = this;
      while (root instanceof Layer)
        root = root.parent;
      idsToRemove.forEach((id) => root.delete(id));
    }
    return idsToRemove;
  }
  findChildRefIds(dataId) {
    if (!hasOwn.call(this.refs, dataId)) {
      const found = this.refs[dataId] = {};
      const root = this.data[dataId];
      if (!root)
        return found;
      const workSet = /* @__PURE__ */ new Set([root]);
      workSet.forEach((obj) => {
        if (isReference(obj)) {
          found[obj.__ref] = true;
        }
        if (isNonNullObject(obj)) {
          Object.keys(obj).forEach((key) => {
            const child = obj[key];
            if (isNonNullObject(child)) {
              workSet.add(child);
            }
          });
        }
      });
    }
    return this.refs[dataId];
  }
  makeCacheKey() {
    return this.group.keyMaker.lookupArray(arguments);
  }
  get supportsResultCaching() {
    return this.group.caching;
  }
};
var CacheGroup = class {
  constructor(caching, parent = null) {
    __publicField(this, "caching");
    __publicField(this, "parent");
    __publicField(this, "d", null);
    // Used by the EntityStore#makeCacheKey method to compute cache keys
    // specific to this CacheGroup.
    __publicField(this, "keyMaker");
    this.caching = caching;
    this.parent = parent;
    this.resetCaching();
  }
  resetCaching() {
    this.d = this.caching ? dep() : null;
    this.keyMaker = new Trie();
  }
  depend(dataId, storeFieldName) {
    if (this.d) {
      this.d(makeDepKey(dataId, storeFieldName));
      const fieldName = fieldNameFromStoreName(storeFieldName);
      if (fieldName !== storeFieldName) {
        this.d(makeDepKey(dataId, fieldName));
      }
      if (this.parent) {
        this.parent.depend(dataId, storeFieldName);
      }
    }
  }
  dirty(dataId, storeFieldName) {
    if (this.d) {
      this.d.dirty(
        makeDepKey(dataId, storeFieldName),
        // When storeFieldName === "__exists", that means the entity identified
        // by dataId has either disappeared from the cache or was newly added,
        // so the result caching system would do well to "forget everything it
        // knows" about that object. To achieve that kind of invalidation, we
        // not only dirty the associated result cache entry, but also remove it
        // completely from the dependency graph. For the optimism implementation
        // details, see https://github.com/benjamn/optimism/pull/195.
        storeFieldName === "__exists" ? "forget" : "setDirty"
      );
    }
  }
};
function makeDepKey(dataId, storeFieldName) {
  return storeFieldName + "#" + dataId;
}
function maybeDependOnExistenceOfEntity(store, entityId) {
  if (supportsResultCaching(store)) {
    store.group.depend(entityId, "__exists");
  }
}
var Root = class extends EntityStore {
  constructor({ policies, resultCaching = true, seed }) {
    super(policies, new CacheGroup(resultCaching));
    __publicField(this, "stump", new Stump(this));
    __publicField(this, "storageTrie", new Trie());
    if (seed)
      this.replace(seed);
  }
  addLayer(layerId, replay) {
    return this.stump.addLayer(layerId, replay);
  }
  removeLayer() {
    return this;
  }
  getStorage() {
    return this.storageTrie.lookupArray(arguments);
  }
};
EntityStore.Root = Root;
var Layer = class _Layer extends EntityStore {
  constructor(id, parent, replay, group) {
    super(parent.policies, group);
    __publicField(this, "id");
    __publicField(this, "parent");
    __publicField(this, "replay");
    __publicField(this, "group");
    this.id = id;
    this.parent = parent;
    this.replay = replay;
    this.group = group;
    replay(this);
  }
  addLayer(layerId, replay) {
    return new _Layer(layerId, this, replay, this.group);
  }
  removeLayer(layerId) {
    const parent = this.parent.removeLayer(layerId);
    if (layerId === this.id) {
      if (this.group.caching) {
        Object.keys(this.data).forEach((dataId) => {
          const ownStoreObject = this.data[dataId];
          const parentStoreObject = parent["lookup"](dataId);
          if (!parentStoreObject) {
            this.delete(dataId);
          } else if (!ownStoreObject) {
            this.group.dirty(dataId, "__exists");
            Object.keys(parentStoreObject).forEach((storeFieldName) => {
              this.group.dirty(dataId, storeFieldName);
            });
          } else if (ownStoreObject !== parentStoreObject) {
            Object.keys(ownStoreObject).forEach((storeFieldName) => {
              if (!equal(ownStoreObject[storeFieldName], parentStoreObject[storeFieldName])) {
                this.group.dirty(dataId, storeFieldName);
              }
            });
          }
        });
      }
      return parent;
    }
    if (parent === this.parent)
      return this;
    return parent.addLayer(this.id, this.replay);
  }
  toObject() {
    return {
      ...this.parent.toObject(),
      ...this.data
    };
  }
  findChildRefIds(dataId) {
    const fromParent = this.parent.findChildRefIds(dataId);
    return hasOwn.call(this.data, dataId) ? {
      ...fromParent,
      ...super.findChildRefIds(dataId)
    } : fromParent;
  }
  getStorage(...args) {
    let p = this.parent;
    while (p.parent)
      p = p.parent;
    return p.getStorage(...args);
  }
};
var Stump = class extends Layer {
  constructor(root) {
    super("EntityStore.Stump", root, () => {
    }, new CacheGroup(root.group.caching, root.group));
  }
  removeLayer() {
    return this;
  }
  merge(older, newer) {
    return this.parent.merge(older, newer);
  }
};
function storeObjectReconciler(existingObject, incomingObject, property) {
  const existingValue = existingObject[property];
  const incomingValue = incomingObject[property];
  return equal(existingValue, incomingValue) ? existingValue : incomingValue;
}
function supportsResultCaching(store) {
  return !!(store && store.supportsResultCaching);
}

// node_modules/@apollo/client/masking/utils.js
var disableWarningsSlot = new Slot();
function getFragmentMaskMode(fragment) {
  var _a2, _b;
  const directive = (_a2 = fragment.directives) == null ? void 0 : _a2.find(({ name }) => name.value === "unmask");
  if (!directive) {
    return "mask";
  }
  const modeArg = (_b = directive.arguments) == null ? void 0 : _b.find(({ name }) => name.value === "mode");
  if (__DEV__) {
    if (modeArg) {
      if (modeArg.value.kind === Kind.VARIABLE) {
        __DEV__ && invariant2.warn(44);
      } else if (modeArg.value.kind !== Kind.STRING) {
        __DEV__ && invariant2.warn(45);
      } else if (modeArg.value.value !== "migrate") {
        __DEV__ && invariant2.warn(46, modeArg.value.value);
      }
    }
  }
  if (modeArg && "value" in modeArg.value && modeArg.value.value === "migrate") {
    return "migrate";
  }
  return "unmask";
}

// node_modules/@apollo/client/masking/maskDefinition.js
function maskDefinition(data, selectionSet, context) {
  return disableWarningsSlot.withValue(true, () => {
    const masked = maskSelectionSet(data, selectionSet, context, false);
    if (Object.isFrozen(data)) {
      maybeDeepFreeze(masked);
    }
    return masked;
  });
}
function getMutableTarget(data, mutableTargets) {
  if (mutableTargets.has(data)) {
    return mutableTargets.get(data);
  }
  const mutableTarget = Array.isArray(data) ? [] : {};
  mutableTargets.set(data, mutableTarget);
  return mutableTarget;
}
function maskSelectionSet(data, selectionSet, context, migration, path) {
  var _a2;
  const { knownChanged } = context;
  const memo = getMutableTarget(data, context.mutableTargets);
  if (Array.isArray(data)) {
    for (const [index, item] of Array.from(data.entries())) {
      if (item === null) {
        memo[index] = null;
        continue;
      }
      const masked = maskSelectionSet(item, selectionSet, context, migration, __DEV__ ? `${path || ""}[${index}]` : void 0);
      if (knownChanged.has(masked)) {
        knownChanged.add(memo);
      }
      memo[index] = masked;
    }
    return knownChanged.has(memo) ? memo : data;
  }
  for (const selection of selectionSet.selections) {
    let value;
    if (migration) {
      knownChanged.add(memo);
    }
    if (selection.kind === Kind.FIELD) {
      const keyName = resultKeyNameFromField(selection);
      const childSelectionSet = selection.selectionSet;
      value = memo[keyName] || data[keyName];
      if (value === void 0) {
        continue;
      }
      if (childSelectionSet && value !== null) {
        const masked = maskSelectionSet(data[keyName], childSelectionSet, context, migration, __DEV__ ? `${path || ""}.${keyName}` : void 0);
        if (knownChanged.has(masked)) {
          value = masked;
        }
      }
      if (!__DEV__) {
        memo[keyName] = value;
      }
      if (__DEV__) {
        if (migration && keyName !== "__typename" && // either the field is not present in the memo object
        // or it has a `get` descriptor, not a `value` descriptor
        // => it is a warning accessor and we can overwrite it
        // with another accessor
        !((_a2 = Object.getOwnPropertyDescriptor(memo, keyName)) == null ? void 0 : _a2.value)) {
          Object.defineProperty(memo, keyName, getAccessorWarningDescriptor(keyName, value, path || "", context.operationName, context.operationType));
        } else {
          delete memo[keyName];
          memo[keyName] = value;
        }
      }
    }
    if (selection.kind === Kind.INLINE_FRAGMENT && (!selection.typeCondition || context.cache.fragmentMatches(selection, data.__typename))) {
      value = maskSelectionSet(data, selection.selectionSet, context, migration, path);
    }
    if (selection.kind === Kind.FRAGMENT_SPREAD) {
      const fragmentName = selection.name.value;
      const fragment = context.fragmentMap[fragmentName] || (context.fragmentMap[fragmentName] = context.cache.lookupFragment(fragmentName));
      invariant2(fragment, 39, fragmentName);
      const mode = getFragmentMaskMode(selection);
      if (mode !== "mask") {
        value = maskSelectionSet(data, fragment.selectionSet, context, mode === "migrate", path);
      }
    }
    if (knownChanged.has(value)) {
      knownChanged.add(memo);
    }
  }
  if ("__typename" in data && !("__typename" in memo)) {
    memo.__typename = data.__typename;
  }
  if (Object.keys(memo).length !== Object.keys(data).length) {
    knownChanged.add(memo);
  }
  return knownChanged.has(memo) ? memo : data;
}
function getAccessorWarningDescriptor(fieldName, value, path, operationName, operationType) {
  let getValue = () => {
    if (disableWarningsSlot.getValue()) {
      return value;
    }
    __DEV__ && invariant2.warn(40, operationName ? `${operationType} '${operationName}'` : `anonymous ${operationType}`, `${path}.${fieldName}`.replace(/^\./, ""));
    getValue = () => value;
    return value;
  };
  return {
    get() {
      return getValue();
    },
    set(newValue) {
      getValue = () => newValue;
    },
    enumerable: true,
    configurable: true
  };
}

// node_modules/@apollo/client/masking/maskFragment.js
function maskFragment(data, document, cache, fragmentName) {
  const fragments = document.definitions.filter((node) => node.kind === Kind.FRAGMENT_DEFINITION);
  if (typeof fragmentName === "undefined") {
    invariant2(fragments.length === 1, 41, fragments.length);
    fragmentName = fragments[0].name.value;
  }
  const fragment = fragments.find((fragment2) => fragment2.name.value === fragmentName);
  invariant2(!!fragment, 42, fragmentName);
  if (data == null) {
    return data;
  }
  if (equal(data, {})) {
    return data;
  }
  return maskDefinition(data, fragment.selectionSet, {
    operationType: "fragment",
    operationName: fragment.name.value,
    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),
    cache,
    mutableTargets: /* @__PURE__ */ new WeakMap(),
    knownChanged: /* @__PURE__ */ new WeakSet()
  });
}

// node_modules/@apollo/client/masking/maskOperation.js
function maskOperation(data, document, cache) {
  var _a2;
  const definition = getOperationDefinition(document);
  invariant2(definition, 43);
  if (data == null) {
    return data;
  }
  return maskDefinition(data, definition.selectionSet, {
    operationType: definition.operation,
    operationName: (_a2 = definition.name) == null ? void 0 : _a2.value,
    fragmentMap: createFragmentMap(getFragmentDefinitions(document)),
    cache,
    mutableTargets: /* @__PURE__ */ new WeakMap(),
    knownChanged: /* @__PURE__ */ new WeakSet()
  });
}

// node_modules/@apollo/client/cache/inmemory/key-extractor.js
var specifierInfoCache = {};
function lookupSpecifierInfo(spec) {
  const cacheKey = JSON.stringify(spec);
  return specifierInfoCache[cacheKey] || (specifierInfoCache[cacheKey] = {});
}
function keyFieldsFnFromSpecifier(specifier) {
  const info = lookupSpecifierInfo(specifier);
  return info.keyFieldsFn || (info.keyFieldsFn = (object, context) => {
    const extract = (from3, key) => context.readField(key, from3);
    const keyObject = context.keyObject = collectSpecifierPaths(specifier, (schemaKeyPath) => {
      let extracted = extractKeyPath(
        context.storeObject,
        schemaKeyPath,
        // Using context.readField to extract paths from context.storeObject
        // allows the extraction to see through Reference objects and respect
        // custom read functions.
        extract
      );
      if (extracted === void 0 && object !== context.storeObject && hasOwn.call(object, schemaKeyPath[0])) {
        extracted = extractKeyPath(object, schemaKeyPath, extractKey);
      }
      invariant2(extracted !== void 0, 98, schemaKeyPath.join("."), object);
      return extracted;
    });
    return `${context.typename}:${JSON.stringify(keyObject)}`;
  });
}
function keyArgsFnFromSpecifier(specifier) {
  const info = lookupSpecifierInfo(specifier);
  return info.keyArgsFn || (info.keyArgsFn = (args, { field, variables, fieldName }) => {
    const collected = collectSpecifierPaths(specifier, (keyPath) => {
      const firstKey = keyPath[0];
      const firstChar = firstKey.charAt(0);
      if (firstChar === "@") {
        if (field && isNonEmptyArray(field.directives)) {
          const directiveName = firstKey.slice(1);
          const d = field.directives.find((d2) => d2.name.value === directiveName);
          const directiveArgs = d && argumentsObjectFromField(d, variables);
          return directiveArgs && extractKeyPath(
            directiveArgs,
            // If keyPath.length === 1, this code calls extractKeyPath with an
            // empty path, which works because it uses directiveArgs as the
            // extracted value.
            keyPath.slice(1)
          );
        }
        return;
      }
      if (firstChar === "$") {
        const variableName = firstKey.slice(1);
        if (variables && hasOwn.call(variables, variableName)) {
          const varKeyPath = keyPath.slice(0);
          varKeyPath[0] = variableName;
          return extractKeyPath(variables, varKeyPath);
        }
        return;
      }
      if (args) {
        return extractKeyPath(args, keyPath);
      }
    });
    const suffix = JSON.stringify(collected);
    if (args || suffix !== "{}") {
      fieldName += ":" + suffix;
    }
    return fieldName;
  });
}
function collectSpecifierPaths(specifier, extractor) {
  const merger = new DeepMerger();
  return getSpecifierPaths(specifier).reduce((collected, path) => {
    let toMerge = extractor(path);
    if (toMerge !== void 0) {
      for (let i = path.length - 1; i >= 0; --i) {
        toMerge = { [path[i]]: toMerge };
      }
      collected = merger.merge(collected, toMerge);
    }
    return collected;
  }, {});
}
function getSpecifierPaths(spec) {
  const info = lookupSpecifierInfo(spec);
  if (!info.paths) {
    const paths = info.paths = [];
    const currentPath = [];
    spec.forEach((s, i) => {
      if (isArray(s)) {
        getSpecifierPaths(s).forEach((p) => paths.push(currentPath.concat(p)));
        currentPath.length = 0;
      } else {
        currentPath.push(s);
        if (!isArray(spec[i + 1])) {
          paths.push(currentPath.slice(0));
          currentPath.length = 0;
        }
      }
    });
  }
  return info.paths;
}
function extractKey(object, key) {
  return object[key];
}
function extractKeyPath(object, path, extract) {
  extract = extract || extractKey;
  return normalize(path.reduce(function reducer(obj, key) {
    return isArray(obj) ? obj.map((child) => reducer(child, key)) : obj && extract(obj, key);
  }, object));
}
function normalize(value) {
  if (isNonNullObject(value)) {
    if (isArray(value)) {
      return value.map(normalize);
    }
    return collectSpecifierPaths(Object.keys(value).sort(), (path) => extractKeyPath(value, path));
  }
  return value;
}

// node_modules/@apollo/client/cache/inmemory/reactiveVars.js
var cacheSlot = new Slot();
var cacheInfoMap = /* @__PURE__ */ new WeakMap();
function getCacheInfo(cache) {
  let info = cacheInfoMap.get(cache);
  if (!info) {
    cacheInfoMap.set(cache, info = {
      vars: /* @__PURE__ */ new Set(),
      dep: dep()
    });
  }
  return info;
}
function forgetCache(cache) {
  getCacheInfo(cache).vars.forEach((rv) => rv.forgetCache(cache));
}
function recallCache(cache) {
  getCacheInfo(cache).vars.forEach((rv) => rv.attachCache(cache));
}
function makeVar(value) {
  const caches2 = /* @__PURE__ */ new Set();
  const listeners = /* @__PURE__ */ new Set();
  const rv = function(newValue) {
    if (arguments.length > 0) {
      if (value !== newValue) {
        value = newValue;
        caches2.forEach((cache) => {
          getCacheInfo(cache).dep.dirty(rv);
          broadcast(cache);
        });
        const oldListeners = Array.from(listeners);
        listeners.clear();
        oldListeners.forEach((listener) => listener(value));
      }
    } else {
      const cache = cacheSlot.getValue();
      if (cache) {
        attach(cache);
        getCacheInfo(cache).dep(rv);
      }
    }
    return value;
  };
  rv.onNextChange = (listener) => {
    listeners.add(listener);
    return () => {
      listeners.delete(listener);
    };
  };
  const attach = rv.attachCache = (cache) => {
    caches2.add(cache);
    getCacheInfo(cache).vars.add(rv);
    return rv;
  };
  rv.forgetCache = (cache) => caches2.delete(cache);
  return rv;
}
function broadcast(cache) {
  if (cache.broadcastWatches) {
    cache.broadcastWatches();
  }
}

// node_modules/@apollo/client/cache/inmemory/policies.js
function argsFromFieldSpecifier(spec) {
  return spec.args !== void 0 ? spec.args : spec.field ? argumentsObjectFromField(spec.field, spec.variables) : null;
}
var nullKeyFieldsFn = () => void 0;
var simpleKeyArgsFn = (_args, context) => context.fieldName;
var mergeTrueFn = (existing, incoming, { mergeObjects }) => mergeObjects(existing, incoming);
var mergeFalseFn = (_, incoming) => incoming;
var Policies = class {
  constructor(config) {
    __publicField(this, "config");
    __publicField(this, "typePolicies", {});
    __publicField(this, "toBeAdded", {});
    // Map from subtype names to sets of supertype names. Note that this
    // representation inverts the structure of possibleTypes (whose keys are
    // supertypes and whose values are arrays of subtypes) because it tends
    // to be much more efficient to search upwards than downwards.
    __publicField(this, "supertypeMap", /* @__PURE__ */ new Map());
    // Any fuzzy subtypes specified by possibleTypes will be converted to
    // RegExp objects and recorded here. Every key of this map can also be
    // found in supertypeMap. In many cases this Map will be empty, which
    // means no fuzzy subtype checking will happen in fragmentMatches.
    __publicField(this, "fuzzySubtypes", /* @__PURE__ */ new Map());
    __publicField(this, "cache");
    __publicField(this, "rootIdsByTypename", {});
    __publicField(this, "rootTypenamesById", {});
    __publicField(this, "usingPossibleTypes", false);
    this.config = config;
    this.config = {
      dataIdFromObject: defaultDataIdFromObject,
      ...config
    };
    this.cache = this.config.cache;
    this.setRootTypename("Query");
    this.setRootTypename("Mutation");
    this.setRootTypename("Subscription");
    if (config.possibleTypes) {
      this.addPossibleTypes(config.possibleTypes);
    }
    if (config.typePolicies) {
      this.addTypePolicies(config.typePolicies);
    }
  }
  identify(object, partialContext) {
    var _a2;
    const policies = this;
    const typename = partialContext && (partialContext.typename || ((_a2 = partialContext.storeObject) == null ? void 0 : _a2.__typename)) || object.__typename;
    if (typename === this.rootTypenamesById.ROOT_QUERY) {
      return ["ROOT_QUERY"];
    }
    const storeObject = partialContext && partialContext.storeObject || object;
    const context = {
      ...partialContext,
      typename,
      storeObject,
      readField: partialContext && partialContext.readField || ((...args) => {
        const options = normalizeReadFieldOptions(args, storeObject);
        return policies.readField(options, {
          store: policies.cache["data"],
          variables: options.variables
        });
      })
    };
    let id;
    const policy = typename && this.getTypePolicy(typename);
    let keyFn = policy && policy.keyFn || this.config.dataIdFromObject;
    disableWarningsSlot.withValue(true, () => {
      while (keyFn) {
        const specifierOrId = keyFn({ ...object, ...storeObject }, context);
        if (isArray(specifierOrId)) {
          keyFn = keyFieldsFnFromSpecifier(specifierOrId);
        } else {
          id = specifierOrId;
          break;
        }
      }
    });
    id = id ? String(id) : void 0;
    return context.keyObject ? [id, context.keyObject] : [id];
  }
  addTypePolicies(typePolicies) {
    Object.keys(typePolicies).forEach((typename) => {
      const { queryType, mutationType, subscriptionType, ...incoming } = typePolicies[typename];
      if (queryType)
        this.setRootTypename("Query", typename);
      if (mutationType)
        this.setRootTypename("Mutation", typename);
      if (subscriptionType)
        this.setRootTypename("Subscription", typename);
      if (hasOwn.call(this.toBeAdded, typename)) {
        this.toBeAdded[typename].push(incoming);
      } else {
        this.toBeAdded[typename] = [incoming];
      }
    });
  }
  updateTypePolicy(typename, incoming, existingFieldPolicies) {
    const existing = this.getTypePolicy(typename);
    const { keyFields, fields } = incoming;
    function setMerge(existing2, merge) {
      existing2.merge = typeof merge === "function" ? merge : merge === true ? mergeTrueFn : merge === false ? mergeFalseFn : existing2.merge;
    }
    setMerge(existing, incoming.merge);
    existing.keyFn = // Pass false to disable normalization for this typename.
    keyFields === false ? nullKeyFieldsFn : isArray(keyFields) ? keyFieldsFnFromSpecifier(keyFields) : typeof keyFields === "function" ? keyFields : existing.keyFn;
    if (fields) {
      Object.keys(fields).forEach((fieldName) => {
        let existing2 = existingFieldPolicies[fieldName];
        if (!existing2 || (existing2 == null ? void 0 : existing2.typename) !== typename) {
          existing2 = existingFieldPolicies[fieldName] = { typename };
        }
        const incoming2 = fields[fieldName];
        if (typeof incoming2 === "function") {
          existing2.read = incoming2;
        } else {
          const { keyArgs, read, merge } = incoming2;
          existing2.keyFn = // Pass false to disable argument-based differentiation of
          // field identities.
          keyArgs === false ? simpleKeyArgsFn : isArray(keyArgs) ? keyArgsFnFromSpecifier(keyArgs) : typeof keyArgs === "function" ? keyArgs : existing2.keyFn;
          if (typeof read === "function") {
            existing2.read = read;
          }
          setMerge(existing2, merge);
        }
        if (existing2.read && existing2.merge) {
          existing2.keyFn = existing2.keyFn || simpleKeyArgsFn;
        }
      });
    }
  }
  setRootTypename(which, typename = which) {
    const rootId = "ROOT_" + which.toUpperCase();
    const old = this.rootTypenamesById[rootId];
    if (typename !== old) {
      invariant2(!old || old === which, 99, which);
      if (old)
        delete this.rootIdsByTypename[old];
      this.rootIdsByTypename[typename] = rootId;
      this.rootTypenamesById[rootId] = typename;
    }
  }
  addPossibleTypes(possibleTypes) {
    this.usingPossibleTypes = true;
    Object.keys(possibleTypes).forEach((supertype) => {
      this.getSupertypeSet(supertype, true);
      possibleTypes[supertype].forEach((subtype) => {
        this.getSupertypeSet(subtype, true).add(supertype);
        const match = subtype.match(TypeOrFieldNameRegExp);
        if (!match || match[0] !== subtype) {
          this.fuzzySubtypes.set(subtype, new RegExp(subtype));
        }
      });
    });
  }
  getTypePolicy(typename) {
    if (!hasOwn.call(this.typePolicies, typename)) {
      const policy = this.typePolicies[typename] = {};
      policy.fields = {};
      let supertypes = this.supertypeMap.get(typename);
      if (!supertypes && this.fuzzySubtypes.size) {
        supertypes = this.getSupertypeSet(typename, true);
        this.fuzzySubtypes.forEach((regExp, fuzzy) => {
          if (regExp.test(typename)) {
            const fuzzySupertypes = this.supertypeMap.get(fuzzy);
            if (fuzzySupertypes) {
              fuzzySupertypes.forEach((supertype) => supertypes.add(supertype));
            }
          }
        });
      }
      if (supertypes && supertypes.size) {
        supertypes.forEach((supertype) => {
          const { fields, ...rest } = this.getTypePolicy(supertype);
          Object.assign(policy, rest);
          Object.assign(policy.fields, fields);
        });
      }
    }
    const inbox = this.toBeAdded[typename];
    if (inbox && inbox.length) {
      inbox.splice(0).forEach((policy) => {
        this.updateTypePolicy(typename, policy, this.typePolicies[typename].fields);
      });
    }
    return this.typePolicies[typename];
  }
  getFieldPolicy(typename, fieldName) {
    if (typename) {
      return this.getTypePolicy(typename).fields[fieldName];
    }
  }
  getSupertypeSet(subtype, createIfMissing) {
    let supertypeSet = this.supertypeMap.get(subtype);
    if (!supertypeSet && createIfMissing) {
      this.supertypeMap.set(subtype, supertypeSet = /* @__PURE__ */ new Set());
    }
    return supertypeSet;
  }
  fragmentMatches(fragment, typename, result, variables) {
    if (!fragment.typeCondition)
      return true;
    if (!typename)
      return false;
    const supertype = fragment.typeCondition.name.value;
    if (typename === supertype)
      return true;
    if (this.usingPossibleTypes && this.supertypeMap.has(supertype)) {
      const typenameSupertypeSet = this.getSupertypeSet(typename, true);
      const workQueue = [typenameSupertypeSet];
      const maybeEnqueue = (subtype) => {
        const supertypeSet = this.getSupertypeSet(subtype, false);
        if (supertypeSet && supertypeSet.size && workQueue.indexOf(supertypeSet) < 0) {
          workQueue.push(supertypeSet);
        }
      };
      let needToCheckFuzzySubtypes = !!(result && this.fuzzySubtypes.size);
      let checkingFuzzySubtypes = false;
      for (let i = 0; i < workQueue.length; ++i) {
        const supertypeSet = workQueue[i];
        if (supertypeSet.has(supertype)) {
          if (!typenameSupertypeSet.has(supertype)) {
            if (checkingFuzzySubtypes) {
              __DEV__ && invariant2.warn(100, typename, supertype);
            }
            typenameSupertypeSet.add(supertype);
          }
          return true;
        }
        supertypeSet.forEach(maybeEnqueue);
        if (needToCheckFuzzySubtypes && // Start checking fuzzy subtypes only after exhausting all
        // non-fuzzy subtypes (after the final iteration of the loop).
        i === workQueue.length - 1 && // We could wait to compare fragment.selectionSet to result
        // after we verify the supertype, but this check is often less
        // expensive than that search, and we will have to do the
        // comparison anyway whenever we find a potential match.
        selectionSetMatchesResult(fragment.selectionSet, result, variables)) {
          needToCheckFuzzySubtypes = false;
          checkingFuzzySubtypes = true;
          this.fuzzySubtypes.forEach((regExp, fuzzyString) => {
            const match = typename.match(regExp);
            if (match && match[0] === typename) {
              maybeEnqueue(fuzzyString);
            }
          });
        }
      }
    }
    return false;
  }
  hasKeyArgs(typename, fieldName) {
    const policy = this.getFieldPolicy(typename, fieldName);
    return !!(policy && policy.keyFn);
  }
  getStoreFieldName(fieldSpec) {
    const { typename, fieldName } = fieldSpec;
    const policy = this.getFieldPolicy(typename, fieldName);
    let storeFieldName;
    let keyFn = policy && policy.keyFn;
    if (keyFn && typename) {
      const context = {
        typename,
        fieldName,
        field: fieldSpec.field || null,
        variables: fieldSpec.variables
      };
      const args = argsFromFieldSpecifier(fieldSpec);
      while (keyFn) {
        const specifierOrString = keyFn(args, context);
        if (isArray(specifierOrString)) {
          keyFn = keyArgsFnFromSpecifier(specifierOrString);
        } else {
          storeFieldName = specifierOrString || fieldName;
          break;
        }
      }
    }
    if (storeFieldName === void 0) {
      storeFieldName = fieldSpec.field ? storeKeyNameFromField(fieldSpec.field, fieldSpec.variables) : getStoreKeyName(fieldName, argsFromFieldSpecifier(fieldSpec));
    }
    if (storeFieldName === false) {
      return fieldName;
    }
    return fieldName === fieldNameFromStoreName(storeFieldName) ? storeFieldName : fieldName + ":" + storeFieldName;
  }
  readField(options, context) {
    const objectOrReference = options.from;
    if (!objectOrReference)
      return;
    const nameOrField = options.field || options.fieldName;
    if (!nameOrField)
      return;
    if (options.typename === void 0) {
      const typename = context.store.getFieldValue(objectOrReference, "__typename");
      if (typename)
        options.typename = typename;
    }
    const storeFieldName = this.getStoreFieldName(options);
    const fieldName = fieldNameFromStoreName(storeFieldName);
    const existing = context.store.getFieldValue(objectOrReference, storeFieldName);
    const policy = this.getFieldPolicy(options.typename, fieldName);
    const read = policy && policy.read;
    if (read) {
      const readOptions = makeFieldFunctionOptions(this, objectOrReference, options, context, context.store.getStorage(isReference(objectOrReference) ? objectOrReference.__ref : objectOrReference, storeFieldName));
      return cacheSlot.withValue(this.cache, read, [
        existing,
        readOptions
      ]);
    }
    return existing;
  }
  getReadFunction(typename, fieldName) {
    const policy = this.getFieldPolicy(typename, fieldName);
    return policy && policy.read;
  }
  getMergeFunction(parentTypename, fieldName, childTypename) {
    let policy = this.getFieldPolicy(parentTypename, fieldName);
    let merge = policy && policy.merge;
    if (!merge && childTypename) {
      policy = this.getTypePolicy(childTypename);
      merge = policy && policy.merge;
    }
    return merge;
  }
  runMergeFunction(existing, incoming, { field, typename, merge }, context, storage) {
    if (merge === mergeTrueFn) {
      return makeMergeObjectsFunction(context.store)(existing, incoming);
    }
    if (merge === mergeFalseFn) {
      return incoming;
    }
    if (context.overwrite) {
      existing = void 0;
    }
    return merge(existing, incoming, makeFieldFunctionOptions(
      this,
      // Unlike options.readField for read functions, we do not fall
      // back to the current object if no foreignObjOrRef is provided,
      // because it's not clear what the current object should be for
      // merge functions: the (possibly undefined) existing object, or
      // the incoming object? If you think your merge function needs
      // to read sibling fields in order to produce a new value for
      // the current field, you might want to rethink your strategy,
      // because that's a recipe for making merge behavior sensitive
      // to the order in which fields are written into the cache.
      // However, readField(name, ref) is useful for merge functions
      // that need to deduplicate child objects and references.
      void 0,
      {
        typename,
        fieldName: field.name.value,
        field,
        variables: context.variables
      },
      context,
      storage || {}
    ));
  }
};
function makeFieldFunctionOptions(policies, objectOrReference, fieldSpec, context, storage) {
  const storeFieldName = policies.getStoreFieldName(fieldSpec);
  const fieldName = fieldNameFromStoreName(storeFieldName);
  const variables = fieldSpec.variables || context.variables;
  const { toReference, canRead } = context.store;
  return {
    args: argsFromFieldSpecifier(fieldSpec),
    field: fieldSpec.field || null,
    fieldName,
    storeFieldName,
    variables,
    isReference,
    toReference,
    storage,
    cache: policies.cache,
    canRead,
    readField(...args) {
      return policies.readField(normalizeReadFieldOptions(args, objectOrReference, variables), context);
    },
    mergeObjects: makeMergeObjectsFunction(context.store)
  };
}
function normalizeReadFieldOptions(readFieldArgs, objectOrReference, variables) {
  const { 0: fieldNameOrOptions, 1: from3, length: argc } = readFieldArgs;
  let options;
  if (typeof fieldNameOrOptions === "string") {
    options = {
      fieldName: fieldNameOrOptions,
      // Default to objectOrReference only when no second argument was
      // passed for the from parameter, not when undefined is explicitly
      // passed as the second argument.
      from: argc > 1 ? from3 : objectOrReference
    };
  } else {
    options = { ...fieldNameOrOptions };
    if (!hasOwn.call(options, "from")) {
      options.from = objectOrReference;
    }
  }
  if (__DEV__ && options.from === void 0) {
    __DEV__ && invariant2.warn(101, stringifyForDisplay(Array.from(readFieldArgs)));
  }
  if (void 0 === options.variables) {
    options.variables = variables;
  }
  return options;
}
function makeMergeObjectsFunction(store) {
  return function mergeObjects(existing, incoming) {
    if (isArray(existing) || isArray(incoming)) {
      throw newInvariantError(102);
    }
    if (isNonNullObject(existing) && isNonNullObject(incoming)) {
      const eType = store.getFieldValue(existing, "__typename");
      const iType = store.getFieldValue(incoming, "__typename");
      const typesDiffer = eType && iType && eType !== iType;
      if (typesDiffer) {
        return incoming;
      }
      if (isReference(existing) && storeValueIsStoreObject(incoming)) {
        store.merge(existing.__ref, incoming);
        return existing;
      }
      if (storeValueIsStoreObject(existing) && isReference(incoming)) {
        store.merge(existing, incoming.__ref);
        return incoming;
      }
      if (storeValueIsStoreObject(existing) && storeValueIsStoreObject(incoming)) {
        return { ...existing, ...incoming };
      }
    }
    return incoming;
  };
}

// node_modules/@apollo/client/cache/inmemory/readFromStore.js
function execSelectionSetKeyArgs(options) {
  return [options.selectionSet, options.objectOrReference, options.context];
}
var StoreReader = class {
  constructor(config) {
    // cached version of executeSelectionSet
    __publicField(this, "executeSelectionSet");
    // cached version of executeSubSelectedArray
    __publicField(this, "executeSubSelectedArray");
    __publicField(this, "config");
    __publicField(this, "knownResults", /* @__PURE__ */ new WeakMap());
    this.config = config;
    this.executeSelectionSet = wrap((options) => {
      const peekArgs = execSelectionSetKeyArgs(options);
      const other = this.executeSelectionSet.peek(...peekArgs);
      if (other) {
        return other;
      }
      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
      return this.execSelectionSetImpl(options);
    }, {
      max: cacheSizes["inMemoryCache.executeSelectionSet"] || 5e4,
      keyArgs: execSelectionSetKeyArgs,
      // Note that the parameters of makeCacheKey are determined by the
      // array returned by keyArgs.
      makeCacheKey(selectionSet, parent, context) {
        if (supportsResultCaching(context.store)) {
          return context.store.makeCacheKey(selectionSet, isReference(parent) ? parent.__ref : parent, context.varString);
        }
      }
    });
    this.executeSubSelectedArray = wrap((options) => {
      maybeDependOnExistenceOfEntity(options.context.store, options.enclosingRef.__ref);
      return this.execSubSelectedArrayImpl(options);
    }, {
      max: cacheSizes["inMemoryCache.executeSubSelectedArray"] || 1e4,
      makeCacheKey({ field, array, context }) {
        if (supportsResultCaching(context.store)) {
          return context.store.makeCacheKey(field, array, context.varString);
        }
      }
    });
  }
  /**
   * Given a store and a query, return as much of the result as possible and
   * identify if any data was missing from the store.
   */
  diffQueryAgainstStore({ store, query, rootId = "ROOT_QUERY", variables, returnPartialData = true }) {
    const policies = this.config.cache.policies;
    variables = {
      ...getDefaultValues(getQueryDefinition(query)),
      ...variables
    };
    const rootRef = makeReference(rootId);
    const execResult = this.executeSelectionSet({
      selectionSet: getMainDefinition(query).selectionSet,
      objectOrReference: rootRef,
      enclosingRef: rootRef,
      context: {
        store,
        query,
        policies,
        variables,
        varString: canonicalStringify(variables),
        ...extractFragmentContext(query, this.config.fragments)
      }
    });
    let missing;
    if (execResult.missing) {
      missing = new MissingFieldError(firstMissing(execResult.missing), execResult.missing, query, variables);
    }
    const complete = !missing;
    const { result } = execResult;
    return {
      result: complete || returnPartialData ? Object.keys(result).length === 0 ? null : result : null,
      complete,
      missing
    };
  }
  isFresh(result, parent, selectionSet, context) {
    if (supportsResultCaching(context.store) && this.knownResults.get(result) === selectionSet) {
      const latest = this.executeSelectionSet.peek(selectionSet, parent, context);
      if (latest && result === latest.result) {
        return true;
      }
    }
    return false;
  }
  // Uncached version of executeSelectionSet.
  execSelectionSetImpl({ selectionSet, objectOrReference, enclosingRef, context }) {
    if (isReference(objectOrReference) && !context.policies.rootTypenamesById[objectOrReference.__ref] && !context.store.has(objectOrReference.__ref)) {
      return {
        result: {},
        missing: `Dangling reference to missing ${objectOrReference.__ref} object`
      };
    }
    const { variables, policies, store } = context;
    const typename = store.getFieldValue(objectOrReference, "__typename");
    const objectsToMerge = [];
    let missing;
    const missingMerger = new DeepMerger();
    if (typeof typename === "string" && !policies.rootIdsByTypename[typename]) {
      objectsToMerge.push({ __typename: typename });
    }
    function handleMissing(result2, resultName) {
      if (result2.missing) {
        missing = missingMerger.merge(missing, {
          [resultName]: result2.missing
        });
      }
      return result2.result;
    }
    const workSet = new Set(selectionSet.selections);
    workSet.forEach((selection) => {
      if (!shouldInclude(selection, variables))
        return;
      if (isField(selection)) {
        let fieldValue = policies.readField({
          fieldName: selection.name.value,
          field: selection,
          variables: context.variables,
          from: objectOrReference
        }, context);
        const resultName = resultKeyNameFromField(selection);
        if (fieldValue === void 0) {
          if (!addTypenameToDocument.added(selection)) {
            missing = missingMerger.merge(missing, {
              [resultName]: `Can't find field '${selection.name.value}' on ${isReference(objectOrReference) ? objectOrReference.__ref + " object" : "object " + JSON.stringify(objectOrReference, null, 2)}`
            });
          }
        } else if (isArray(fieldValue)) {
          if (fieldValue.length > 0) {
            fieldValue = handleMissing(this.executeSubSelectedArray({
              field: selection,
              array: fieldValue,
              enclosingRef,
              context
            }), resultName);
          }
        } else if (!selection.selectionSet) {
        } else if (fieldValue != null) {
          fieldValue = handleMissing(this.executeSelectionSet({
            selectionSet: selection.selectionSet,
            objectOrReference: fieldValue,
            enclosingRef: isReference(fieldValue) ? fieldValue : enclosingRef,
            context
          }), resultName);
        }
        if (fieldValue !== void 0) {
          objectsToMerge.push({ [resultName]: fieldValue });
        }
      } else {
        const fragment = getFragmentFromSelection(selection, context.lookupFragment);
        if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
          throw newInvariantError(103, selection.name.value);
        }
        if (fragment && policies.fragmentMatches(fragment, typename)) {
          fragment.selectionSet.selections.forEach(workSet.add, workSet);
        }
      }
    });
    const result = mergeDeepArray(objectsToMerge);
    const finalResult = { result, missing };
    const frozen = maybeDeepFreeze(finalResult);
    if (frozen.result) {
      this.knownResults.set(frozen.result, selectionSet);
    }
    return frozen;
  }
  // Uncached version of executeSubSelectedArray.
  execSubSelectedArrayImpl({ field, array, enclosingRef, context }) {
    let missing;
    let missingMerger = new DeepMerger();
    function handleMissing(childResult, i) {
      if (childResult.missing) {
        missing = missingMerger.merge(missing, { [i]: childResult.missing });
      }
      return childResult.result;
    }
    if (field.selectionSet) {
      array = array.filter(context.store.canRead);
    }
    array = array.map((item, i) => {
      if (item === null) {
        return null;
      }
      if (isArray(item)) {
        return handleMissing(this.executeSubSelectedArray({
          field,
          array: item,
          enclosingRef,
          context
        }), i);
      }
      if (field.selectionSet) {
        return handleMissing(this.executeSelectionSet({
          selectionSet: field.selectionSet,
          objectOrReference: item,
          enclosingRef: isReference(item) ? item : enclosingRef,
          context
        }), i);
      }
      if (__DEV__) {
        assertSelectionSetForIdValue(context.store, field, item);
      }
      return item;
    });
    return {
      result: array,
      missing
    };
  }
};
function firstMissing(tree) {
  try {
    JSON.stringify(tree, (_, value) => {
      if (typeof value === "string")
        throw value;
      return value;
    });
  } catch (result) {
    return result;
  }
}
function assertSelectionSetForIdValue(store, field, fieldValue) {
  if (!field.selectionSet) {
    const workSet = /* @__PURE__ */ new Set([fieldValue]);
    workSet.forEach((value) => {
      if (isNonNullObject(value)) {
        invariant2(
          !isReference(value),
          104,
          getTypenameFromStoreObject(store, value),
          field.name.value
        );
        Object.values(value).forEach(workSet.add, workSet);
      }
    });
  }
}

// node_modules/@apollo/client/cache/inmemory/writeToStore.js
function getContextFlavor(context, clientOnly, deferred) {
  const key = `${clientOnly}${deferred}`;
  let flavored = context.flavors.get(key);
  if (!flavored) {
    context.flavors.set(key, flavored = context.clientOnly === clientOnly && context.deferred === deferred ? context : {
      ...context,
      clientOnly,
      deferred
    });
  }
  return flavored;
}
var StoreWriter = class {
  constructor(cache, reader, fragments) {
    __publicField(this, "cache");
    __publicField(this, "reader");
    __publicField(this, "fragments");
    this.cache = cache;
    this.reader = reader;
    this.fragments = fragments;
  }
  writeToStore(store, { query, result, dataId, variables, overwrite }) {
    const operationDefinition = getOperationDefinition(query);
    const merger = makeProcessedFieldsMerger();
    variables = {
      ...getDefaultValues(operationDefinition),
      ...variables
    };
    const context = {
      store,
      written: {},
      merge(existing, incoming) {
        return merger.merge(existing, incoming);
      },
      variables,
      varString: canonicalStringify(variables),
      ...extractFragmentContext(query, this.fragments),
      overwrite: !!overwrite,
      incomingById: /* @__PURE__ */ new Map(),
      clientOnly: false,
      deferred: false,
      flavors: /* @__PURE__ */ new Map()
    };
    const ref = this.processSelectionSet({
      result: result || {},
      dataId,
      selectionSet: operationDefinition.selectionSet,
      mergeTree: { map: /* @__PURE__ */ new Map() },
      context
    });
    if (!isReference(ref)) {
      throw newInvariantError(105, result);
    }
    context.incomingById.forEach(({ storeObject, mergeTree, fieldNodeSet }, dataId2) => {
      const entityRef = makeReference(dataId2);
      if (mergeTree && mergeTree.map.size) {
        const applied = this.applyMerges(mergeTree, entityRef, storeObject, context);
        if (isReference(applied)) {
          return;
        }
        storeObject = applied;
      }
      if (__DEV__ && !context.overwrite) {
        const fieldsWithSelectionSets = {};
        fieldNodeSet.forEach((field) => {
          if (field.selectionSet) {
            fieldsWithSelectionSets[field.name.value] = true;
          }
        });
        const hasSelectionSet = (storeFieldName) => fieldsWithSelectionSets[fieldNameFromStoreName(storeFieldName)] === true;
        const hasMergeFunction = (storeFieldName) => {
          const childTree = mergeTree && mergeTree.map.get(storeFieldName);
          return Boolean(childTree && childTree.info && childTree.info.merge);
        };
        Object.keys(storeObject).forEach((storeFieldName) => {
          if (hasSelectionSet(storeFieldName) && !hasMergeFunction(storeFieldName)) {
            warnAboutDataLoss(entityRef, storeObject, storeFieldName, context.store);
          }
        });
      }
      store.merge(dataId2, storeObject);
    });
    store.retain(ref.__ref);
    return ref;
  }
  processSelectionSet({
    dataId,
    result,
    selectionSet,
    context,
    // This object allows processSelectionSet to report useful information
    // to its callers without explicitly returning that information.
    mergeTree
  }) {
    const { policies } = this.cache;
    let incoming = {};
    const typename = dataId && policies.rootTypenamesById[dataId] || getTypenameFromResult(result, selectionSet, context.fragmentMap) || dataId && context.store.get(dataId, "__typename");
    if ("string" === typeof typename) {
      incoming.__typename = typename;
    }
    const readField = (...args) => {
      const options = normalizeReadFieldOptions(args, incoming, context.variables);
      if (isReference(options.from)) {
        const info = context.incomingById.get(options.from.__ref);
        if (info) {
          const result2 = policies.readField({
            ...options,
            from: info.storeObject
          }, context);
          if (result2 !== void 0) {
            return result2;
          }
        }
      }
      return policies.readField(options, context);
    };
    const fieldNodeSet = /* @__PURE__ */ new Set();
    this.flattenFields(
      selectionSet,
      result,
      // This WriteContext will be the default context value for fields returned
      // by the flattenFields method, but some fields may be assigned a modified
      // context, depending on the presence of @client and other directives.
      context,
      typename
    ).forEach((context2, field) => {
      const resultFieldKey = resultKeyNameFromField(field);
      const value = result[resultFieldKey];
      fieldNodeSet.add(field);
      if (value !== void 0) {
        const storeFieldName = policies.getStoreFieldName({
          typename,
          fieldName: field.name.value,
          field,
          variables: context2.variables
        });
        const childTree = getChildMergeTree(mergeTree, storeFieldName);
        let incomingValue = this.processFieldValue(
          value,
          field,
          // Reset context.clientOnly and context.deferred to their default
          // values before processing nested selection sets.
          field.selectionSet ? getContextFlavor(context2, false, false) : context2,
          childTree
        );
        let childTypename;
        if (field.selectionSet && (isReference(incomingValue) || storeValueIsStoreObject(incomingValue))) {
          childTypename = readField("__typename", incomingValue);
        }
        const merge = policies.getMergeFunction(typename, field.name.value, childTypename);
        if (merge) {
          childTree.info = {
            // TODO Check compatibility against any existing childTree.field?
            field,
            typename,
            merge
          };
        } else {
          maybeRecycleChildMergeTree(mergeTree, storeFieldName);
        }
        incoming = context2.merge(incoming, {
          [storeFieldName]: incomingValue
        });
      } else if (__DEV__ && !context2.clientOnly && !context2.deferred && !addTypenameToDocument.added(field) && // If the field has a read function, it may be a synthetic field or
      // provide a default value, so its absence from the written data should
      // not be cause for alarm.
      !policies.getReadFunction(typename, field.name.value)) {
        invariant2.error(106, resultKeyNameFromField(field), result);
      }
    });
    try {
      const [id, keyObject] = policies.identify(result, {
        typename,
        selectionSet,
        fragmentMap: context.fragmentMap,
        storeObject: incoming,
        readField
      });
      dataId = dataId || id;
      if (keyObject) {
        incoming = context.merge(incoming, keyObject);
      }
    } catch (e) {
      if (!dataId)
        throw e;
    }
    if ("string" === typeof dataId) {
      const dataRef = makeReference(dataId);
      const sets = context.written[dataId] || (context.written[dataId] = []);
      if (sets.indexOf(selectionSet) >= 0)
        return dataRef;
      sets.push(selectionSet);
      if (this.reader && this.reader.isFresh(result, dataRef, selectionSet, context)) {
        return dataRef;
      }
      const previous = context.incomingById.get(dataId);
      if (previous) {
        previous.storeObject = context.merge(previous.storeObject, incoming);
        previous.mergeTree = mergeMergeTrees(previous.mergeTree, mergeTree);
        fieldNodeSet.forEach((field) => previous.fieldNodeSet.add(field));
      } else {
        context.incomingById.set(dataId, {
          storeObject: incoming,
          // Save a reference to mergeTree only if it is not empty, because
          // empty MergeTrees may be recycled by maybeRecycleChildMergeTree and
          // reused for entirely different parts of the result tree.
          mergeTree: mergeTreeIsEmpty(mergeTree) ? void 0 : mergeTree,
          fieldNodeSet
        });
      }
      return dataRef;
    }
    return incoming;
  }
  processFieldValue(value, field, context, mergeTree) {
    if (!field.selectionSet || value === null) {
      return __DEV__ ? cloneDeep(value) : value;
    }
    if (isArray(value)) {
      return value.map((item, i) => {
        const value2 = this.processFieldValue(item, field, context, getChildMergeTree(mergeTree, i));
        maybeRecycleChildMergeTree(mergeTree, i);
        return value2;
      });
    }
    return this.processSelectionSet({
      result: value,
      selectionSet: field.selectionSet,
      context,
      mergeTree
    });
  }
  // Implements https://spec.graphql.org/draft/#sec-Field-Collection, but with
  // some additions for tracking @client and @defer directives.
  flattenFields(selectionSet, result, context, typename = getTypenameFromResult(result, selectionSet, context.fragmentMap)) {
    const fieldMap = /* @__PURE__ */ new Map();
    const { policies } = this.cache;
    const limitingTrie = new Trie(false);
    (function flatten(selectionSet2, inheritedContext) {
      const visitedNode = limitingTrie.lookup(
        selectionSet2,
        // Because we take inheritedClientOnly and inheritedDeferred into
        // consideration here (in addition to selectionSet), it's possible for
        // the same selection set to be flattened more than once, if it appears
        // in the query with different @client and/or @directive configurations.
        inheritedContext.clientOnly,
        inheritedContext.deferred
      );
      if (visitedNode.visited)
        return;
      visitedNode.visited = true;
      selectionSet2.selections.forEach((selection) => {
        if (!shouldInclude(selection, context.variables))
          return;
        let { clientOnly, deferred } = inheritedContext;
        if (
          // Since the presence of @client or @defer on this field can only
          // cause clientOnly or deferred to become true, we can skip the
          // forEach loop if both clientOnly and deferred are already true.
          !(clientOnly && deferred) && isNonEmptyArray(selection.directives)
        ) {
          selection.directives.forEach((dir) => {
            const name = dir.name.value;
            if (name === "client")
              clientOnly = true;
            if (name === "defer") {
              const args = argumentsObjectFromField(dir, context.variables);
              if (!args || args.if !== false) {
                deferred = true;
              }
            }
          });
        }
        if (isField(selection)) {
          const existing = fieldMap.get(selection);
          if (existing) {
            clientOnly = clientOnly && existing.clientOnly;
            deferred = deferred && existing.deferred;
          }
          fieldMap.set(selection, getContextFlavor(context, clientOnly, deferred));
        } else {
          const fragment = getFragmentFromSelection(selection, context.lookupFragment);
          if (!fragment && selection.kind === Kind.FRAGMENT_SPREAD) {
            throw newInvariantError(107, selection.name.value);
          }
          if (fragment && policies.fragmentMatches(fragment, typename, result, context.variables)) {
            flatten(fragment.selectionSet, getContextFlavor(context, clientOnly, deferred));
          }
        }
      });
    })(selectionSet, context);
    return fieldMap;
  }
  applyMerges(mergeTree, existing, incoming, context, getStorageArgs) {
    if (mergeTree.map.size && !isReference(incoming)) {
      const e = (
        // Items in the same position in different arrays are not
        // necessarily related to each other, so when incoming is an array
        // we process its elements as if there was no existing data.
        !isArray(incoming) && // Likewise, existing must be either a Reference or a StoreObject
        // in order for its fields to be safe to merge with the fields of
        // the incoming object.
        (isReference(existing) || storeValueIsStoreObject(existing)) ? existing : void 0
      );
      const i = incoming;
      if (e && !getStorageArgs) {
        getStorageArgs = [isReference(e) ? e.__ref : e];
      }
      let changedFields;
      const getValue = (from3, name) => {
        return isArray(from3) ? typeof name === "number" ? from3[name] : void 0 : context.store.getFieldValue(from3, String(name));
      };
      mergeTree.map.forEach((childTree, storeFieldName) => {
        const eVal = getValue(e, storeFieldName);
        const iVal = getValue(i, storeFieldName);
        if (void 0 === iVal)
          return;
        if (getStorageArgs) {
          getStorageArgs.push(storeFieldName);
        }
        const aVal = this.applyMerges(childTree, eVal, iVal, context, getStorageArgs);
        if (aVal !== iVal) {
          changedFields = changedFields || /* @__PURE__ */ new Map();
          changedFields.set(storeFieldName, aVal);
        }
        if (getStorageArgs) {
          invariant2(getStorageArgs.pop() === storeFieldName);
        }
      });
      if (changedFields) {
        incoming = isArray(i) ? i.slice(0) : { ...i };
        changedFields.forEach((value, name) => {
          incoming[name] = value;
        });
      }
    }
    if (mergeTree.info) {
      return this.cache.policies.runMergeFunction(existing, incoming, mergeTree.info, context, getStorageArgs && context.store.getStorage(...getStorageArgs));
    }
    return incoming;
  }
};
var emptyMergeTreePool = [];
function getChildMergeTree({ map: map3 }, name) {
  if (!map3.has(name)) {
    map3.set(name, emptyMergeTreePool.pop() || { map: /* @__PURE__ */ new Map() });
  }
  return map3.get(name);
}
function mergeMergeTrees(left, right) {
  if (left === right || !right || mergeTreeIsEmpty(right))
    return left;
  if (!left || mergeTreeIsEmpty(left))
    return right;
  const info = left.info && right.info ? {
    ...left.info,
    ...right.info
  } : left.info || right.info;
  const needToMergeMaps = left.map.size && right.map.size;
  const map3 = needToMergeMaps ? /* @__PURE__ */ new Map() : left.map.size ? left.map : right.map;
  const merged = { info, map: map3 };
  if (needToMergeMaps) {
    const remainingRightKeys = new Set(right.map.keys());
    left.map.forEach((leftTree, key) => {
      merged.map.set(key, mergeMergeTrees(leftTree, right.map.get(key)));
      remainingRightKeys.delete(key);
    });
    remainingRightKeys.forEach((key) => {
      merged.map.set(key, mergeMergeTrees(right.map.get(key), left.map.get(key)));
    });
  }
  return merged;
}
function mergeTreeIsEmpty(tree) {
  return !tree || !(tree.info || tree.map.size);
}
function maybeRecycleChildMergeTree({ map: map3 }, name) {
  const childTree = map3.get(name);
  if (childTree && mergeTreeIsEmpty(childTree)) {
    emptyMergeTreePool.push(childTree);
    map3.delete(name);
  }
}
var warnings = /* @__PURE__ */ new Set();
function warnAboutDataLoss(existingRef, incomingObj, storeFieldName, store) {
  const getChild = (objOrRef) => {
    const child = store.getFieldValue(objOrRef, storeFieldName);
    return typeof child === "object" && child;
  };
  const existing = getChild(existingRef);
  if (!existing)
    return;
  const incoming = getChild(incomingObj);
  if (!incoming)
    return;
  if (isReference(existing))
    return;
  if (equal(existing, incoming))
    return;
  if (Object.keys(existing).every((key) => store.getFieldValue(incoming, key) !== void 0)) {
    return;
  }
  const parentType = store.getFieldValue(existingRef, "__typename") || store.getFieldValue(incomingObj, "__typename");
  const fieldName = fieldNameFromStoreName(storeFieldName);
  const typeDotName = `${parentType}.${fieldName}`;
  if (warnings.has(typeDotName))
    return;
  warnings.add(typeDotName);
  const childTypenames = [];
  if (!isArray(existing) && !isArray(incoming)) {
    [existing, incoming].forEach((child) => {
      const typename = store.getFieldValue(child, "__typename");
      if (typeof typename === "string" && !childTypenames.includes(typename)) {
        childTypenames.push(typename);
      }
    });
  }
  __DEV__ && invariant2.warn(108, fieldName, parentType, childTypenames.length ? "either ensure all objects of type " + childTypenames.join(" and ") + " have an ID or a custom merge function, or " : "", typeDotName, { ...existing }, { ...incoming });
}
function getTypenameFromResult(result, selectionSet, fragmentMap) {
  let fragments;
  for (const selection of selectionSet.selections) {
    if (isField(selection)) {
      if (selection.name.value === "__typename") {
        return result[resultKeyNameFromField(selection)];
      }
    } else if (fragments) {
      fragments.push(selection);
    } else {
      fragments = [selection];
    }
  }
  if (typeof result.__typename === "string") {
    return result.__typename;
  }
  if (fragments) {
    for (const selection of fragments) {
      const typename = getTypenameFromResult(result, getFragmentFromSelection(selection, fragmentMap).selectionSet, fragmentMap);
      if (typeof typename === "string") {
        return typename;
      }
    }
  }
}

// node_modules/@apollo/client/cache/inmemory/inMemoryCache.js
var InMemoryCache = class extends ApolloCache {
  constructor(config = {}) {
    super();
    __publicField(this, "data");
    __publicField(this, "optimisticData");
    __publicField(this, "config");
    __publicField(this, "watches", /* @__PURE__ */ new Set());
    __publicField(this, "storeReader");
    __publicField(this, "storeWriter");
    __publicField(this, "addTypenameTransform", new DocumentTransform(addTypenameToDocument));
    __publicField(this, "maybeBroadcastWatch");
    // Override the default value, since InMemoryCache result objects are frozen
    // in development and expected to remain logically immutable in production.
    __publicField(this, "assumeImmutableResults", true);
    // Dynamically imported code can augment existing typePolicies or
    // possibleTypes by calling cache.policies.addTypePolicies or
    // cache.policies.addPossibletypes.
    __publicField(this, "policies");
    __publicField(this, "makeVar", makeVar);
    __publicField(this, "txCount", 0);
    this.config = normalizeConfig(config);
    this.policies = new Policies({
      cache: this,
      dataIdFromObject: this.config.dataIdFromObject,
      possibleTypes: this.config.possibleTypes,
      typePolicies: this.config.typePolicies
    });
    this.init();
  }
  init() {
    const rootStore = this.data = new EntityStore.Root({
      policies: this.policies,
      resultCaching: this.config.resultCaching
    });
    this.optimisticData = rootStore.stump;
    this.resetResultCache();
  }
  resetResultCache() {
    const { fragments } = this.config;
    this.addTypenameTransform.resetCache();
    fragments == null ? void 0 : fragments.resetCaches();
    this.storeWriter = new StoreWriter(this, this.storeReader = new StoreReader({ cache: this, fragments }), fragments);
    this.maybeBroadcastWatch = wrap((c, options) => {
      return this.broadcastWatch(c, options);
    }, {
      max: cacheSizes["inMemoryCache.maybeBroadcastWatch"] || 5e3,
      makeCacheKey: (c) => {
        const store = c.optimistic ? this.optimisticData : this.data;
        if (supportsResultCaching(store)) {
          const { optimistic, id, variables } = c;
          return store.makeCacheKey(
            c.query,
            // Different watches can have the same query, optimistic
            // status, rootId, and variables, but if their callbacks are
            // different, the (identical) result needs to be delivered to
            // each distinct callback. The easiest way to achieve that
            // separation is to include c.callback in the cache key for
            // maybeBroadcastWatch calls. See issue #5733.
            c.callback,
            canonicalStringify({ optimistic, id, variables })
          );
        }
      }
    });
    (/* @__PURE__ */ new Set([this.data.group, this.optimisticData.group])).forEach((group) => group.resetCaching());
  }
  restore(data) {
    this.init();
    if (data)
      this.data.replace(data);
    return this;
  }
  extract(optimistic = false) {
    return (optimistic ? this.optimisticData : this.data).extract();
  }
  read(options) {
    const {
      // Since read returns data or null, without any additional metadata
      // about whether/where there might have been missing fields, the
      // default behavior cannot be returnPartialData = true (like it is
      // for the diff method), since defaulting to true would violate the
      // integrity of the T in the return type. However, partial data may
      // be useful in some cases, so returnPartialData:true may be
      // specified explicitly.
      returnPartialData = false
    } = options;
    return this.storeReader.diffQueryAgainstStore({
      ...options,
      store: options.optimistic ? this.optimisticData : this.data,
      config: this.config,
      returnPartialData
    }).result;
  }
  write(options) {
    try {
      ++this.txCount;
      return this.storeWriter.writeToStore(this.data, options);
    } finally {
      if (!--this.txCount && options.broadcast !== false) {
        this.broadcastWatches();
      }
    }
  }
  modify(options) {
    if (hasOwn.call(options, "id") && !options.id) {
      return false;
    }
    const store = options.optimistic ? this.optimisticData : this.data;
    try {
      ++this.txCount;
      return store.modify(options.id || "ROOT_QUERY", options.fields, false);
    } finally {
      if (!--this.txCount && options.broadcast !== false) {
        this.broadcastWatches();
      }
    }
  }
  diff(options) {
    return this.storeReader.diffQueryAgainstStore({
      ...options,
      store: options.optimistic ? this.optimisticData : this.data,
      rootId: options.id || "ROOT_QUERY",
      config: this.config
    });
  }
  watch(watch) {
    if (!this.watches.size) {
      recallCache(this);
    }
    this.watches.add(watch);
    if (watch.immediate) {
      this.maybeBroadcastWatch(watch);
    }
    return () => {
      if (this.watches.delete(watch) && !this.watches.size) {
        forgetCache(this);
      }
      this.maybeBroadcastWatch.forget(watch);
    };
  }
  gc(options) {
    canonicalStringify.reset();
    print2.reset();
    const ids = this.optimisticData.gc();
    if (options && !this.txCount && options.resetResultCache) {
      this.resetResultCache();
    }
    return ids;
  }
  // Call this method to ensure the given root ID remains in the cache after
  // garbage collection, along with its transitive child entities. Note that
  // the cache automatically retains all directly written entities. By default,
  // the retainment persists after optimistic updates are removed. Pass true
  // for the optimistic argument if you would prefer for the retainment to be
  // discarded when the top-most optimistic layer is removed. Returns the
  // resulting (non-negative) retainment count.
  retain(rootId, optimistic) {
    return (optimistic ? this.optimisticData : this.data).retain(rootId);
  }
  // Call this method to undo the effect of the retain method, above. Once the
  // retainment count falls to zero, the given ID will no longer be preserved
  // during garbage collection, though it may still be preserved by other safe
  // entities that refer to it. Returns the resulting (non-negative) retainment
  // count, in case that's useful.
  release(rootId, optimistic) {
    return (optimistic ? this.optimisticData : this.data).release(rootId);
  }
  // Returns the canonical ID for a given StoreObject, obeying typePolicies
  // and keyFields (and dataIdFromObject, if you still use that). At minimum,
  // the object must contain a __typename and any primary key fields required
  // to identify entities of that type. If you pass a query result object, be
  // sure that none of the primary key fields have been renamed by aliasing.
  // If you pass a Reference object, its __ref ID string will be returned.
  identify(object) {
    if (isReference(object))
      return object.__ref;
    try {
      return this.policies.identify(object)[0];
    } catch (e) {
      __DEV__ && invariant2.warn(e);
    }
  }
  evict(options) {
    if (!options.id) {
      if (hasOwn.call(options, "id")) {
        return false;
      }
      options = { ...options, id: "ROOT_QUERY" };
    }
    try {
      ++this.txCount;
      return this.optimisticData.evict(options, this.data);
    } finally {
      if (!--this.txCount && options.broadcast !== false) {
        this.broadcastWatches();
      }
    }
  }
  reset(options) {
    this.init();
    canonicalStringify.reset();
    if (options && options.discardWatches) {
      this.watches.forEach((watch) => this.maybeBroadcastWatch.forget(watch));
      this.watches.clear();
      forgetCache(this);
    } else {
      this.broadcastWatches();
    }
    return Promise.resolve();
  }
  removeOptimistic(idToRemove) {
    const newOptimisticData = this.optimisticData.removeLayer(idToRemove);
    if (newOptimisticData !== this.optimisticData) {
      this.optimisticData = newOptimisticData;
      this.broadcastWatches();
    }
  }
  batch(options) {
    const { update, optimistic = true, removeOptimistic, onWatchUpdated } = options;
    let updateResult;
    const perform = (layer) => {
      const { data, optimisticData } = this;
      ++this.txCount;
      if (layer) {
        this.data = this.optimisticData = layer;
      }
      try {
        return updateResult = update(this);
      } finally {
        --this.txCount;
        this.data = data;
        this.optimisticData = optimisticData;
      }
    };
    const alreadyDirty = /* @__PURE__ */ new Set();
    if (onWatchUpdated && !this.txCount) {
      this.broadcastWatches({
        ...options,
        onWatchUpdated(watch) {
          alreadyDirty.add(watch);
          return false;
        }
      });
    }
    if (typeof optimistic === "string") {
      this.optimisticData = this.optimisticData.addLayer(optimistic, perform);
    } else if (optimistic === false) {
      perform(this.data);
    } else {
      perform();
    }
    if (typeof removeOptimistic === "string") {
      this.optimisticData = this.optimisticData.removeLayer(removeOptimistic);
    }
    if (onWatchUpdated && alreadyDirty.size) {
      this.broadcastWatches({
        ...options,
        onWatchUpdated(watch, diff) {
          const result = onWatchUpdated.call(this, watch, diff);
          if (result !== false) {
            alreadyDirty.delete(watch);
          }
          return result;
        }
      });
      if (alreadyDirty.size) {
        alreadyDirty.forEach((watch) => this.maybeBroadcastWatch.dirty(watch));
      }
    } else {
      this.broadcastWatches(options);
    }
    return updateResult;
  }
  performTransaction(update, optimisticId) {
    return this.batch({
      update,
      optimistic: optimisticId || optimisticId !== null
    });
  }
  transformDocument(document) {
    return this.addTypenameTransform.transformDocument(this.addFragmentsToDocument(document));
  }
  fragmentMatches(fragment, typename) {
    return this.policies.fragmentMatches(fragment, typename);
  }
  lookupFragment(fragmentName) {
    var _a2;
    return ((_a2 = this.config.fragments) == null ? void 0 : _a2.lookup(fragmentName)) || null;
  }
  broadcastWatches(options) {
    if (!this.txCount) {
      this.watches.forEach((c) => this.maybeBroadcastWatch(c, options));
    }
  }
  addFragmentsToDocument(document) {
    const { fragments } = this.config;
    return fragments ? fragments.transform(document) : document;
  }
  // This method is wrapped by maybeBroadcastWatch, which is called by
  // broadcastWatches, so that we compute and broadcast results only when
  // the data that would be broadcast might have changed. It would be
  // simpler to check for changes after recomputing a result but before
  // broadcasting it, but this wrapping approach allows us to skip both
  // the recomputation and the broadcast, in most cases.
  broadcastWatch(c, options) {
    const { lastDiff } = c;
    const diff = this.diff(c);
    if (options) {
      if (c.optimistic && typeof options.optimistic === "string") {
        diff.fromOptimisticTransaction = true;
      }
      if (options.onWatchUpdated && options.onWatchUpdated.call(this, c, diff, lastDiff) === false) {
        return;
      }
    }
    if (!lastDiff || !equal(lastDiff.result, diff.result)) {
      c.callback(c.lastDiff = diff, lastDiff);
    }
  }
};
if (__DEV__) {
  InMemoryCache.prototype.getMemoryInternals = getInMemoryCacheMemoryInternals;
}

// node_modules/@apollo/client/errors/utils.js
function isBranded(error, name) {
  return typeof error === "object" && error !== null && error[Symbol.for("apollo.error")] === name;
}
function brand(error) {
  Object.defineProperty(error, Symbol.for("apollo.error"), {
    value: error.name,
    enumerable: false,
    writable: false,
    configurable: false
  });
}

// node_modules/@apollo/client/errors/CombinedProtocolErrors.js
function defaultFormatMessage(errors) {
  return errors.map((e) => e.message || "Error message not found.").join("\n");
}
var _CombinedProtocolErrors = class _CombinedProtocolErrors extends Error {
  constructor(protocolErrors) {
    super(_CombinedProtocolErrors.formatMessage(protocolErrors, {
      defaultFormatMessage
    }));
    /**
    * The raw list of errors returned by the top-level `errors` field in the
    * multipart HTTP subscription response.
    */
    __publicField(this, "errors");
    this.name = "CombinedProtocolErrors";
    this.errors = protocolErrors;
    brand(this);
    Object.setPrototypeOf(this, _CombinedProtocolErrors.prototype);
  }
  /**
   * A method that determines whether an error is a `CombinedProtocolErrors`
   * object. This method enables TypeScript to narrow the error type.
   *
   * @example
   *
   * ```ts
   * if (CombinedProtocolErrors.is(error)) {
   *   // TypeScript now knows `error` is a CombinedProtocolErrors object
   *   console.log(error.errors);
   * }
   * ```
   */
  static is(error) {
    return isBranded(error, "CombinedProtocolErrors");
  }
};
/**
* A function that formats the error message used for the error's `message`
* property. Override this method to provide your own formatting.
* 
* @remarks
* 
* The `formatMessage` function is called by the `CombinedProtocolErrors`
* constructor to provide a formatted message as the `message` property of the
* `CombinedProtocolErrors` object. Follow the ["Providing a custom message
* formatter"](https://www.apollographql.com/docs/react/api/errors/CombinedProtocolErrors#providing-a-custom-message-formatter) guide to learn how to modify the message format.
* 
* @param errors - The array of GraphQL errors returned from the server in the
* `errors` field of the response.
* @param options - Additional context that could be useful when formatting
* the message.
*/
__publicField(_CombinedProtocolErrors, "formatMessage", defaultFormatMessage);
var CombinedProtocolErrors = _CombinedProtocolErrors;

// node_modules/@apollo/client/errors/isErrorLike.js
function isErrorLike(error) {
  return error !== null && typeof error === "object" && typeof error.message === "string" && typeof error.name === "string" && (typeof error.stack === "string" || typeof error.stack === "undefined");
}

// node_modules/@apollo/client/errors/UnconventionalError.js
var UnconventionalError = class _UnconventionalError extends Error {
  /**
   * A method that determines whether an error is an `UnconventionalError`
   * object. This method enables TypeScript to narrow the error type.
   *
   * @example
   *
   * ```ts
   * if (UnconventionalError.is(error)) {
   *   // TypeScript now knows `error` is a UnconventionalError object
   *   console.log("What caused this?", error.cause);
   * }
   * ```
   */
  static is(error) {
    return isBranded(error, "UnconventionalError");
  }
  constructor(errorType) {
    super("An error of unexpected shape occurred.", { cause: errorType });
    this.name = "UnconventionalError";
    brand(this);
    Object.setPrototypeOf(this, _UnconventionalError.prototype);
  }
};

// node_modules/@apollo/client/errors/CombinedGraphQLErrors.js
function defaultFormatMessage2(errors) {
  return errors.filter((e) => e).map((e) => e.message || "Error message not found.").join("\n");
}
var _CombinedGraphQLErrors = class _CombinedGraphQLErrors extends Error {
  constructor(result, errors = result.errors || []) {
    super(_CombinedGraphQLErrors.formatMessage(errors, {
      result,
      defaultFormatMessage: defaultFormatMessage2
    }));
    /**
    * The raw list of GraphQL errors returned by the `errors` field in the GraphQL response.
    */
    __publicField(this, "errors");
    /**
    * Partial data returned in the `data` field of the GraphQL response.
    */
    __publicField(this, "data");
    /**
    * Extensions returned by the `extensions` field in the GraphQL response.
    */
    __publicField(this, "extensions");
    this.errors = errors;
    this.data = result.data;
    this.extensions = result.extensions;
    this.name = "CombinedGraphQLErrors";
    brand(this);
    Object.setPrototypeOf(this, _CombinedGraphQLErrors.prototype);
  }
  /**
  * A method that determines whether an error is a `CombinedGraphQLErrors`
  * object. This method enables TypeScript to narrow the error type.
  * 
  * @example
  * 
  * ```ts
  * if (CombinedGraphQLErrors.is(error)) {
  *   // TypeScript now knows `error` is a `CombinedGraphQLErrors` object
  *   console.log(error.errors);
  * }
  * ```
  */
  static is(error) {
    return isBranded(error, "CombinedGraphQLErrors");
  }
};
/**
* A function that formats the error message used for the error's `message`
* property. Override this method to provide your own formatting.
* 
* @remarks
* 
* The `formatMessage` function is called by the `CombinedGraphQLErrors`
* constructor to provide a formatted message as the `message` property of the
* `CombinedGraphQLErrors` object. Follow the ["Providing a custom message
* formatter"](https://www.apollographql.com/docs/react/api/errors/CombinedGraphQLErrors#providing-a-custom-message-formatter) guide to learn how to modify the message format.
* 
* @param errors - The array of GraphQL errors returned from the server in
* the `errors` field of the response.
* @param options - Additional context that could be useful when formatting
* the message.
*/
__publicField(_CombinedGraphQLErrors, "formatMessage", defaultFormatMessage2);
var CombinedGraphQLErrors = _CombinedGraphQLErrors;

// node_modules/@apollo/client/errors/LinkError.js
var registry = /* @__PURE__ */ new WeakSet();
function registerLinkError(error) {
  registry.add(error);
}
var LinkError = {
  /**
   * A method that determines whether an error originated from the link chain.
   * `is` does not provide any type narrowing.
   *
   * @example
   *
   * ```ts
   * if (LinkError.is(error)) {
   *   // The error originated from the link chain
   *   console.log("Got network error:", error.message);
   * }
   * ```
   */
  is: (error) => registry.has(error)
};

// node_modules/@apollo/client/errors/LocalStateError.js
var LocalStateError = class _LocalStateError extends Error {
  constructor(message, options = {}) {
    super(message, { cause: options.sourceError });
    /**
    * The path to the field that caused the error.
    */
    __publicField(this, "path");
    this.name = "LocalStateError";
    this.path = options.path;
    brand(this);
    Object.setPrototypeOf(this, _LocalStateError.prototype);
  }
  /**
   * A method that determines whether an error is a `LocalStateError`
   * object. This method enables TypeScript to narrow the error type.
   *
   * @example
   *
   * ```ts
   * if (LocalStateError.is(error)) {
   *   // TypeScript now knows `error` is a LocalStateError object
   *   console.log(error.path);
   * }
   * ```
   */
  static is(error) {
    return isBranded(error, "LocalStateError");
  }
};

// node_modules/@apollo/client/errors/ServerError.js
var ServerError = class _ServerError extends Error {
  constructor(message, options) {
    super(message);
    /**
    * The raw [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) object provided by the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
    */
    __publicField(this, "response");
    /**
    * The status code returned by the server in the response. This is provided as
    * a shortcut for `response.status`.
    */
    __publicField(this, "statusCode");
    /**
    * The raw response body text.
    */
    __publicField(this, "bodyText");
    this.name = "ServerError";
    this.response = options.response;
    this.statusCode = options.response.status;
    this.bodyText = options.bodyText;
    brand(this);
    Object.setPrototypeOf(this, _ServerError.prototype);
  }
  /**
   * A method that determines whether an error is a `ServerError` object. This
   * method enables TypeScript to narrow the error type.
   *
   * @example
   *
   * ```ts
   * if (ServerError.is(error)) {
   *   // TypeScript now knows `error` is a ServerError object
   *   console.log(error.errors);
   * }
   * ```
   */
  static is(error) {
    return isBranded(error, "ServerError");
  }
};

// node_modules/@apollo/client/errors/ServerParseError.js
var ServerParseError = class _ServerParseError extends Error {
  constructor(originalParseError, options) {
    super(originalParseError instanceof Error ? originalParseError.message : "Could not parse server response", { cause: originalParseError });
    /**
    * The raw [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) object provided by the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
    */
    __publicField(this, "response");
    /**
    * The status code returned by the server in the response. This is provided
    * as a shortcut for `response.status`.
    */
    __publicField(this, "statusCode");
    /**
    * The raw response body text.
    */
    __publicField(this, "bodyText");
    this.name = "ServerParseError";
    this.response = options.response;
    this.statusCode = options.response.status;
    this.bodyText = options.bodyText;
    brand(this);
    Object.setPrototypeOf(this, _ServerParseError.prototype);
  }
  /**
   * A method that determines whether an error is a `ServerParseError`
   * object. This method enables TypeScript to narrow the error type.
   *
   * @example
   *
   * ```ts
   * if (ServerParseError.is(error)) {
   *   // TypeScript now knows `error` is a ServerParseError object
   *   console.log(error.statusCode);
   * }
   * ```
   */
  static is(error) {
    return isBranded(error, "ServerParseError");
  }
};

// node_modules/@apollo/client/errors/index.js
var PROTOCOL_ERRORS_SYMBOL = Symbol();
function graphQLResultHasProtocolErrors(result) {
  if ("extensions" in result) {
    return CombinedProtocolErrors.is(result.extensions[PROTOCOL_ERRORS_SYMBOL]);
  }
  return false;
}
function toErrorLike(error) {
  if (isErrorLike(error)) {
    return error;
  }
  if (typeof error === "string") {
    return new Error(error, { cause: error });
  }
  return new UnconventionalError(error);
}

// node_modules/@apollo/client/core/networkStatus.js
var NetworkStatus;
(function(NetworkStatus2) {
  NetworkStatus2[NetworkStatus2["loading"] = 1] = "loading";
  NetworkStatus2[NetworkStatus2["setVariables"] = 2] = "setVariables";
  NetworkStatus2[NetworkStatus2["fetchMore"] = 3] = "fetchMore";
  NetworkStatus2[NetworkStatus2["refetch"] = 4] = "refetch";
  NetworkStatus2[NetworkStatus2["poll"] = 6] = "poll";
  NetworkStatus2[NetworkStatus2["ready"] = 7] = "ready";
  NetworkStatus2[NetworkStatus2["error"] = 8] = "error";
  NetworkStatus2[NetworkStatus2["streaming"] = 9] = "streaming";
})(NetworkStatus || (NetworkStatus = {}));

// node_modules/@apollo/client/core/ObservableQuery.js
var import_rxjs5 = __toESM(require_cjs(), 1);
var { assign, hasOwnProperty: hasOwnProperty5 } = Object;
var uninitialized = {
  loading: true,
  networkStatus: NetworkStatus.loading,
  data: void 0,
  dataState: "empty",
  partial: true
};
var empty2 = {
  loading: false,
  networkStatus: NetworkStatus.ready,
  data: void 0,
  dataState: "empty",
  partial: true
};
var _a;
_a = Symbol.observable;
var ObservableQuery = class {
  constructor({ queryManager, options, transformedQuery = queryManager.transform(options.query) }) {
    __publicField(this, "options");
    __publicField(this, "queryName");
    /**
    * @internal will be read and written from `QueryInfo`
    * 
    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
    */
    __publicField(this, "_lastWrite");
    __publicField(this, "unsubscribeFromCache");
    __publicField(this, "input");
    __publicField(this, "subject");
    __publicField(this, "isTornDown");
    __publicField(this, "queryManager");
    __publicField(this, "subscriptions", /* @__PURE__ */ new Set());
    /**
     * If an `ObservableQuery` is created with a `network-only` fetch policy,
     * it should actually start receiving cache updates, but not before it has
     * received the first result from the network.
     */
    __publicField(this, "waitForNetworkResult");
    __publicField(this, "lastQuery");
    __publicField(this, "linkSubscription");
    __publicField(this, "pollingInfo");
    // We can't use Observable['subscribe'] here as the type as it conflicts with
    // the ability to infer T from Subscribable<T>. This limits the surface area
    // to the non-deprecated signature which works properly with type inference.
    /**
     * Subscribes to the `ObservableQuery`.
     * @param observerOrNext - Either an RxJS `Observer` with some or all callback methods,
     * or the `next` handler that is called for each value emitted from the subscribed Observable.
     * @returns A subscription reference to the registered handlers.
     */
    __publicField(this, "subscribe");
    /**
     * Used to stitch together functional operators into a chain.
     *
     * @example
     *
     * ```ts
     * import { filter, map } from 'rxjs';
     *
     * observableQuery
     *   .pipe(
     *     filter(...),
     *     map(...),
     *   )
     *   .subscribe(x => console.log(x));
     * ```
     *
     * @returns The Observable result of all the operators having been called
     * in the order they were passed in.
     */
    __publicField(this, "pipe");
    __publicField(this, _a);
    __publicField(this, "@@observable");
    __publicField(this, "stableLastResult");
    // Turns polling on or off based on this.options.pollInterval.
    __publicField(this, "didWarnCacheOnlyPolling", false);
    __publicField(this, "dirty", false);
    __publicField(this, "notifyTimeout");
    __publicField(this, "activeOperations", /* @__PURE__ */ new Set());
    __publicField(this, "operator", filterMap((notification) => {
      const { query, variables, meta } = notification;
      if (notification.source === "setResult") {
        return { query, variables, result: notification.value, meta };
      }
      if (notification.kind === "C" || !isEqualQuery(notification, this)) {
        return;
      }
      let result;
      const previous = this.subject.getValue();
      if (notification.source === "cache") {
        result = notification.value;
        if (result.networkStatus === NetworkStatus.ready && result.partial && (!this.options.returnPartialData || previous.result.networkStatus === NetworkStatus.error) && this.options.fetchPolicy !== "cache-only") {
          return;
        }
      } else if (notification.source === "network") {
        if (this.waitForNetworkResult) {
          this.waitForNetworkResult = false;
          this.resubscribeCache();
        }
        result = notification.kind === "E" ? {
          ...isEqualQuery(previous, notification) ? previous.result : { data: void 0, dataState: "empty", partial: true },
          error: notification.error,
          networkStatus: NetworkStatus.error,
          loading: false
        } : notification.value;
        if (notification.kind === "E" && result.dataState === "streaming") {
          result.dataState = "complete";
        }
        if (result.error) {
          meta.shouldEmit = 1;
        }
      } else if (notification.source === "newNetworkStatus") {
        const baseResult = isEqualQuery(previous, notification) ? previous.result : this.getInitialResult(meta.fetchPolicy);
        const { resetError } = notification.value;
        const error = resetError ? void 0 : baseResult.error;
        const networkStatus = error ? NetworkStatus.error : NetworkStatus.ready;
        result = {
          ...baseResult,
          error,
          networkStatus
        };
      }
      invariant2(result);
      if (!result.error)
        delete result.error;
      result.networkStatus = this.calculateNetworkStatus(result.networkStatus);
      result.loading = isNetworkRequestInFlight(result.networkStatus);
      result = this.maskResult(result);
      return { query, variables, result, meta };
    }));
    this.queryManager = queryManager;
    this.waitForNetworkResult = options.fetchPolicy === "network-only";
    this.isTornDown = false;
    this.subscribeToMore = this.subscribeToMore.bind(this);
    this.maskResult = this.maskResult.bind(this);
    const { watchQuery: { fetchPolicy: defaultFetchPolicy = "cache-first" } = {} } = queryManager.defaultOptions;
    const {
      fetchPolicy = defaultFetchPolicy,
      // Make sure we don't store "standby" as the initialFetchPolicy.
      initialFetchPolicy = fetchPolicy === "standby" ? defaultFetchPolicy : fetchPolicy
    } = options;
    this.lastQuery = transformedQuery;
    this.options = {
      ...options,
      // Remember the initial options.fetchPolicy so we can revert back to this
      // policy when variables change. This information can also be specified
      // (or overridden) by providing options.initialFetchPolicy explicitly.
      initialFetchPolicy,
      // This ensures this.options.fetchPolicy always has a string value, in
      // case options.fetchPolicy was not provided.
      fetchPolicy,
      variables: this.getVariablesWithDefaults(options.variables)
    };
    this.initializeObservablesQueue();
    this["@@observable"] = () => this;
    if (Symbol.observable) {
      this[Symbol.observable] = () => this;
    }
    const opDef = getOperationDefinition(this.query);
    this.queryName = opDef && opDef.name && opDef.name.value;
  }
  // The `query` computed property will always reflect the document transformed
  // by the last run query. `this.options.query` will always reflect the raw
  // untransformed query to ensure document transforms with runtime conditionals
  // are run on the original document.
  get query() {
    return this.lastQuery;
  }
  /**
   * An object containing the variables that were provided for the query.
   */
  get variables() {
    return this.options.variables;
  }
  get networkStatus() {
    return this.subject.getValue().result.networkStatus;
  }
  initializeObservablesQueue() {
    this.subject = new import_rxjs5.BehaviorSubject({
      query: this.query,
      variables: this.variables,
      result: uninitialized,
      meta: {}
    });
    const observable = this.subject.pipe((0, import_rxjs5.tap)({
      subscribe: () => {
        if (!this.subject.observed) {
          this.reobserve();
          setTimeout(() => this.updatePolling());
        }
      },
      unsubscribe: () => {
        if (!this.subject.observed) {
          this.tearDownQuery();
        }
      }
    }), filterMap(({ query, variables, result: current, meta }, context) => {
      const { shouldEmit } = meta;
      if (current === uninitialized) {
        context.previous = void 0;
        context.previousVariables = void 0;
      }
      if (this.options.fetchPolicy === "standby" || shouldEmit === 2)
        return;
      if (shouldEmit === 1)
        return emit();
      const { previous, previousVariables } = context;
      if (previous) {
        const documentInfo = this.queryManager.getDocumentInfo(query);
        const dataMasking = this.queryManager.dataMasking;
        const maskedQuery = dataMasking ? documentInfo.nonReactiveQuery : query;
        const resultIsEqual = dataMasking || documentInfo.hasNonreactiveDirective ? equalByQuery(maskedQuery, previous, current, variables) : equal(previous, current);
        if (resultIsEqual && equal(previousVariables, variables)) {
          return;
        }
      }
      if (shouldEmit === 3 && (!this.options.notifyOnNetworkStatusChange || equal(previous, current))) {
        return;
      }
      return emit();
      function emit() {
        context.previous = current;
        context.previousVariables = variables;
        return current;
      }
    }, () => ({})));
    this.pipe = observable.pipe.bind(observable);
    this.subscribe = observable.subscribe.bind(observable);
    this.input = new import_rxjs5.Subject();
    this.input.complete = () => {
    };
    this.input.pipe(this.operator).subscribe(this.subject);
  }
  /**
  * @internal
  * 
  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
  */
  getCacheDiff({ optimistic = true } = {}) {
    return this.queryManager.cache.diff({
      query: this.query,
      variables: this.variables,
      returnPartialData: true,
      optimistic
    });
  }
  getInitialResult(initialFetchPolicy) {
    const fetchPolicy = this.queryManager.prioritizeCacheValues ? "cache-first" : initialFetchPolicy || this.options.fetchPolicy;
    const cacheResult = () => {
      const diff = this.getCacheDiff();
      const data = this.options.returnPartialData || diff.complete ? diff.result ?? void 0 : void 0;
      return this.maskResult({
        data,
        dataState: diff.complete ? "complete" : data === void 0 ? "empty" : "partial",
        loading: !diff.complete,
        networkStatus: diff.complete ? NetworkStatus.ready : NetworkStatus.loading,
        partial: !diff.complete
      });
    };
    switch (fetchPolicy) {
      case "cache-only": {
        return {
          ...cacheResult(),
          loading: false,
          networkStatus: NetworkStatus.ready
        };
      }
      case "cache-first":
        return cacheResult();
      case "cache-and-network":
        return {
          ...cacheResult(),
          loading: true,
          networkStatus: NetworkStatus.loading
        };
      case "standby":
        return empty2;
      default:
        return uninitialized;
    }
  }
  resubscribeCache() {
    var _a2;
    const { variables, fetchPolicy } = this.options;
    const query = this.query;
    const shouldUnsubscribe = fetchPolicy === "standby" || fetchPolicy === "no-cache" || this.waitForNetworkResult;
    const shouldResubscribe = !isEqualQuery({ query, variables }, this.unsubscribeFromCache) && !this.waitForNetworkResult;
    if (shouldUnsubscribe || shouldResubscribe) {
      (_a2 = this.unsubscribeFromCache) == null ? void 0 : _a2.call(this);
    }
    if (shouldUnsubscribe || !shouldResubscribe) {
      return;
    }
    const watch = {
      query,
      variables,
      optimistic: true,
      watcher: this,
      callback: (diff) => {
        const info = this.queryManager.getDocumentInfo(query);
        if (info.hasClientExports || info.hasForcedResolvers) {
          watch.lastDiff = void 0;
        }
        if (watch.lastOwnDiff === diff) {
          return;
        }
        const { result: previousResult } = this.subject.getValue();
        if (!diff.complete && // If we are trying to deliver an incomplete cache result, we avoid
        // reporting it if the query has errored, otherwise we let the broadcast try
        // and repair the partial result by refetching the query. This check avoids
        // a situation where a query that errors and another succeeds with
        // overlapping data does not report the partial data result to the errored
        // query.
        //
        // See https://github.com/apollographql/apollo-client/issues/11400 for more
        // information on this issue.
        (previousResult.error || // Prevent to schedule a notify directly after the `ObservableQuery`
        // has been `reset` (which will set the `previousResult` to `uninitialized` or `empty`)
        // as in those cases, `resetCache` will manually call `refetch` with more intentional timing.
        previousResult === uninitialized || previousResult === empty2)) {
          return;
        }
        if (!equal(previousResult.data, diff.result)) {
          this.scheduleNotify();
        }
      }
    };
    const cancelWatch = this.queryManager.cache.watch(watch);
    this.unsubscribeFromCache = Object.assign(() => {
      this.unsubscribeFromCache = void 0;
      cancelWatch();
    }, { query, variables });
  }
  getCurrentResult() {
    const { result: current } = this.subject.getValue();
    let value = (
      // if the `current` result is in an error state, we will always return that
      // error state, even if we have no observers
      current.networkStatus === NetworkStatus.error || // if we have observers, we are watching the cache and
      // this.subject.getValue() will always be up to date
      this.hasObservers() || // if we are using a `no-cache` fetch policy in which case this
      // `ObservableQuery` cannot have been updated from the outside - in
      // that case, we prefer to keep the current value
      this.options.fetchPolicy === "no-cache" ? current : this.getInitialResult()
    );
    if (value === uninitialized) {
      value = this.getInitialResult();
    }
    if (!equal(this.stableLastResult, value)) {
      this.stableLastResult = value;
    }
    return this.stableLastResult;
  }
  /**
   * Update the variables of this observable query, and fetch the new results.
   * This method should be preferred over `setVariables` in most use cases.
   *
   * Returns a `ResultPromise` with an additional `.retain()` method. Calling
   * `.retain()` keeps the network operation running even if the `ObservableQuery`
   * no longer requires the result.
   *
   * Note: `refetch()` guarantees that a value will be emitted from the
   * observable, even if the result is deep equal to the previous value.
   *
   * @param variables - The new set of variables. If there are missing variables,
   * the previous values of those variables will be used.
   */
  refetch(variables) {
    var _a2;
    const { fetchPolicy } = this.options;
    const reobserveOptions = {
      // Always disable polling for refetches.
      pollInterval: 0
    };
    if (fetchPolicy === "no-cache") {
      reobserveOptions.fetchPolicy = "no-cache";
    } else {
      reobserveOptions.fetchPolicy = "network-only";
    }
    if (__DEV__ && variables && hasOwnProperty5.call(variables, "variables")) {
      const queryDef = getQueryDefinition(this.query);
      const vars = queryDef.variableDefinitions;
      if (!vars || !vars.some((v) => v.variable.name.value === "variables")) {
        __DEV__ && invariant2.warn(77, variables, ((_a2 = queryDef.name) == null ? void 0 : _a2.value) || queryDef);
      }
    }
    if (variables && !equal(this.variables, variables)) {
      reobserveOptions.variables = this.options.variables = this.getVariablesWithDefaults({ ...this.variables, ...variables });
    }
    this._lastWrite = void 0;
    return this._reobserve(reobserveOptions, {
      newNetworkStatus: NetworkStatus.refetch
    });
  }
  fetchMore({ query, variables, context, errorPolicy, updateQuery }) {
    invariant2(
      this.options.fetchPolicy !== "cache-only",
      78,
      getOperationName(this.query, "(anonymous)")
    );
    const combinedOptions = {
      ...compact(this.options, { errorPolicy: "none" }, {
        query,
        context,
        errorPolicy
      }),
      variables: query ? variables : {
        ...this.variables,
        ...variables
      },
      // The fetchMore request goes immediately to the network and does
      // not automatically write its result to the cache (hence no-cache
      // instead of network-only), because we allow the caller of
      // fetchMore to provide an updateQuery callback that determines how
      // the data gets written to the cache.
      fetchPolicy: "no-cache",
      notifyOnNetworkStatusChange: this.options.notifyOnNetworkStatusChange
    };
    combinedOptions.query = this.transformDocument(combinedOptions.query);
    this.lastQuery = query ? this.transformDocument(this.options.query) : combinedOptions.query;
    let wasUpdated = false;
    const isCached = this.options.fetchPolicy !== "no-cache";
    if (!isCached) {
      invariant2(updateQuery, 79);
    }
    const { finalize: finalize2, pushNotification } = this.pushOperation(NetworkStatus.fetchMore);
    pushNotification({
      source: "newNetworkStatus",
      kind: "N",
      value: {}
    }, {
      shouldEmit: 3
      /* EmitBehavior.networkStatusChange */
    });
    return this.queryManager.fetchQuery(combinedOptions, NetworkStatus.fetchMore).then((fetchMoreResult) => {
      finalize2();
      if (isCached) {
        const lastDiff = this.getCacheDiff();
        this.queryManager.cache.batch({
          update: (cache) => {
            if (updateQuery) {
              cache.updateQuery({
                query: this.query,
                variables: this.variables,
                returnPartialData: true,
                optimistic: false
              }, (previous) => updateQuery(previous, {
                fetchMoreResult: fetchMoreResult.data,
                variables: combinedOptions.variables
              }));
            } else {
              cache.writeQuery({
                query: combinedOptions.query,
                variables: combinedOptions.variables,
                data: fetchMoreResult.data
              });
            }
          },
          onWatchUpdated: (watch, diff) => {
            if (watch.watcher === this && !equal(diff.result, lastDiff.result)) {
              wasUpdated = true;
            }
          }
        });
      } else {
        const lastResult = this.getCurrentResult();
        const data = updateQuery(lastResult.data, {
          fetchMoreResult: fetchMoreResult.data,
          variables: combinedOptions.variables
        });
        pushNotification({
          kind: "N",
          value: {
            ...lastResult,
            networkStatus: NetworkStatus.ready,
            // will be overwritten anyways, just here for types sake
            loading: false,
            data,
            dataState: lastResult.dataState === "streaming" ? "streaming" : "complete"
          },
          source: "network"
        });
      }
      return this.maskResult(fetchMoreResult);
    }).finally(() => {
      finalize2();
      if (isCached && !wasUpdated) {
        pushNotification({
          kind: "N",
          source: "newNetworkStatus",
          value: {}
        }, {
          shouldEmit: 1
          /* EmitBehavior.force */
        });
      }
    });
  }
  // XXX the subscription variables are separate from the query variables.
  // if you want to update subscription variables, right now you have to do that separately,
  // and you can only do it by stopping the subscription and then subscribing again with new variables.
  /**
   * A function that enables you to execute a [subscription](https://www.apollographql.com/docs/react/data/subscriptions/), usually to subscribe to specific fields that were included in the query.
   *
   * This function returns _another_ function that you can call to terminate the subscription.
   */
  subscribeToMore(options) {
    const subscription = this.queryManager.startGraphQLSubscription({
      query: options.document,
      variables: options.variables,
      context: options.context
    }).subscribe({
      next: (subscriptionData) => {
        const { updateQuery, onError } = options;
        const { error } = subscriptionData;
        if (error) {
          if (onError) {
            onError(error);
          } else {
            invariant2.error(80, error);
          }
          return;
        }
        if (updateQuery) {
          this.updateQuery((previous, updateOptions) => updateQuery(previous, {
            subscriptionData,
            ...updateOptions
          }));
        }
      }
    });
    this.subscriptions.add(subscription);
    return () => {
      if (this.subscriptions.delete(subscription)) {
        subscription.unsubscribe();
      }
    };
  }
  /**
  * @internal
  * 
  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
  */
  applyOptions(newOptions) {
    const mergedOptions = compact(this.options, newOptions || {});
    assign(this.options, mergedOptions);
    this.updatePolling();
  }
  /**
   * Update the variables of this observable query, and fetch the new results
   * if they've changed. Most users should prefer `refetch` instead of
   * `setVariables` in order to to be properly notified of results even when
   * they come from the cache.
   *
   * Note: `setVariables()` guarantees that a value will be emitted from the
   * observable, even if the result is deeply equal to the previous value.
   *
   * Note: the promise will resolve with the last emitted result
   * when either the variables match the current variables or there
   * are no subscribers to the query.
   *
   * @param variables - The new set of variables. If there are missing variables,
   * the previous values of those variables will be used.
   */
  async setVariables(variables) {
    variables = this.getVariablesWithDefaults(variables);
    if (equal(this.variables, variables)) {
      return toQueryResult(this.getCurrentResult());
    }
    this.options.variables = variables;
    if (!this.hasObservers()) {
      return toQueryResult(this.getCurrentResult());
    }
    return this._reobserve({
      // Reset options.fetchPolicy to its original value.
      fetchPolicy: this.options.initialFetchPolicy,
      variables
    }, { newNetworkStatus: NetworkStatus.setVariables });
  }
  /**
   * A function that enables you to update the query's cached result without executing a followup GraphQL operation.
   *
   * See [using updateQuery and updateFragment](https://www.apollographql.com/docs/react/caching/cache-interaction/#using-updatequery-and-updatefragment) for additional information.
   */
  updateQuery(mapFn) {
    const { queryManager } = this;
    const { result, complete } = this.getCacheDiff({ optimistic: false });
    const newResult = mapFn(result, {
      variables: this.variables,
      complete: !!complete,
      previousData: result
    });
    if (newResult) {
      queryManager.cache.writeQuery({
        query: this.options.query,
        data: newResult,
        variables: this.variables
      });
      queryManager.broadcastQueries();
    }
  }
  /**
   * A function that instructs the query to begin re-executing at a specified interval (in milliseconds).
   */
  startPolling(pollInterval) {
    this.options.pollInterval = pollInterval;
    this.updatePolling();
  }
  /**
   * A function that instructs the query to stop polling after a previous call to `startPolling`.
   */
  stopPolling() {
    this.options.pollInterval = 0;
    this.updatePolling();
  }
  // Update options.fetchPolicy according to options.nextFetchPolicy.
  applyNextFetchPolicy(reason, options) {
    if (options.nextFetchPolicy) {
      const { fetchPolicy = "cache-first", initialFetchPolicy = fetchPolicy } = options;
      if (fetchPolicy === "standby") {
      } else if (typeof options.nextFetchPolicy === "function") {
        options.fetchPolicy = options.nextFetchPolicy.call(options, fetchPolicy, { reason, options, observable: this, initialFetchPolicy });
      } else if (reason === "variables-changed") {
        options.fetchPolicy = initialFetchPolicy;
      } else {
        options.fetchPolicy = options.nextFetchPolicy;
      }
    }
    return options.fetchPolicy;
  }
  fetch(options, networkStatus, fetchQuery, operator) {
    const initialFetchPolicy = this.options.fetchPolicy;
    options.context ?? (options.context = {});
    let synchronouslyEmitted = false;
    const onCacheHit = () => {
      synchronouslyEmitted = true;
    };
    const fetchQueryOperator = (
      // we cannot use `tap` here, since it allows only for a "before subscription"
      // hook with `subscribe` and we care for "directly before and after subscription"
      (source) => new import_rxjs5.Observable((subscriber) => {
        try {
          return source.subscribe({
            next(value) {
              synchronouslyEmitted = true;
              subscriber.next(value);
            },
            error: (error) => subscriber.error(error),
            complete: () => subscriber.complete()
          });
        } finally {
          if (!synchronouslyEmitted) {
            operation.override = networkStatus;
            this.input.next({
              kind: "N",
              source: "newNetworkStatus",
              value: {
                resetError: true
              },
              query,
              variables,
              meta: {
                shouldEmit: 3,
                /*
                 * The moment this notification is emitted, `nextFetchPolicy`
                 * might already have switched from a `network-only` to a
                 * `cache-something` policy, so we want to ensure that the
                 * loading state emit doesn't accidentally read from the cache
                 * in those cases.
                 */
                fetchPolicy: initialFetchPolicy
              }
            });
          }
        }
      })
    );
    let { observable, fromLink } = this.queryManager.fetchObservableWithInfo(options, {
      networkStatus,
      query: fetchQuery,
      onCacheHit,
      fetchQueryOperator,
      observableQuery: this
    });
    const { query, variables } = this;
    const operation = {
      abort: () => {
        subscription.unsubscribe();
      },
      query,
      variables
    };
    this.activeOperations.add(operation);
    let forceFirstValueEmit = networkStatus == NetworkStatus.refetch || networkStatus == NetworkStatus.setVariables;
    observable = observable.pipe(operator, (0, import_rxjs5.share)());
    const subscription = observable.pipe((0, import_rxjs5.tap)({
      next: (notification) => {
        if (notification.source === "newNetworkStatus" || notification.kind === "N" && notification.value.loading) {
          operation.override = networkStatus;
        } else {
          delete operation.override;
        }
      },
      finalize: () => this.activeOperations.delete(operation)
    })).subscribe({
      next: (value) => {
        const meta = {};
        if (forceFirstValueEmit && value.kind === "N" && "loading" in value.value && !value.value.loading) {
          forceFirstValueEmit = false;
          meta.shouldEmit = 1;
        }
        this.input.next({ ...value, query, variables, meta });
      }
    });
    return { fromLink, subscription, observable };
  }
  updatePolling() {
    if (this.queryManager.ssrMode) {
      return;
    }
    const { pollingInfo, options: { fetchPolicy, pollInterval } } = this;
    if (!pollInterval || !this.hasObservers() || fetchPolicy === "cache-only") {
      if (__DEV__) {
        if (!this.didWarnCacheOnlyPolling && pollInterval && fetchPolicy === "cache-only") {
          __DEV__ && invariant2.warn(81, getOperationName(this.query, "(anonymous)"));
          this.didWarnCacheOnlyPolling = true;
        }
      }
      this.cancelPolling();
      return;
    }
    if ((pollingInfo == null ? void 0 : pollingInfo.interval) === pollInterval) {
      return;
    }
    const info = pollingInfo || (this.pollingInfo = {});
    info.interval = pollInterval;
    const maybeFetch = () => {
      var _a2, _b;
      if (this.pollingInfo) {
        if (!isNetworkRequestInFlight(this.networkStatus) && !((_b = (_a2 = this.options).skipPollAttempt) == null ? void 0 : _b.call(_a2))) {
          this._reobserve({
            // Most fetchPolicy options don't make sense to use in a polling context, as
            // users wouldn't want to be polling the cache directly. However, network-only and
            // no-cache are both useful for when the user wants to control whether or not the
            // polled results are written to the cache.
            fetchPolicy: this.options.initialFetchPolicy === "no-cache" ? "no-cache" : "network-only"
          }, {
            newNetworkStatus: NetworkStatus.poll
          }).then(poll, poll);
        } else {
          poll();
        }
      }
    };
    const poll = () => {
      const info2 = this.pollingInfo;
      if (info2) {
        clearTimeout(info2.timeout);
        info2.timeout = setTimeout(maybeFetch, info2.interval);
      }
    };
    poll();
  }
  // This differs from stopPolling in that it does not set pollInterval to 0
  cancelPolling() {
    if (this.pollingInfo) {
      clearTimeout(this.pollingInfo.timeout);
      delete this.pollingInfo;
    }
  }
  /**
   * Reevaluate the query, optionally against new options. New options will be
   * merged with the current options when given.
   *
   * Note: `variables` can be reset back to their defaults (typically empty) by calling `reobserve` with
   * `variables: undefined`.
   */
  reobserve(newOptions) {
    return this._reobserve(newOptions);
  }
  _reobserve(newOptions, internalOptions) {
    this.isTornDown = false;
    let { newNetworkStatus } = internalOptions || {};
    this.queryManager.obsQueries.add(this);
    const useDisposableObservable = (
      // Refetching uses a disposable Observable to allow refetches using different
      // options, without permanently altering the options of the
      // original ObservableQuery.
      newNetworkStatus === NetworkStatus.refetch || // Polling uses a disposable Observable so the polling options (which force
      // fetchPolicy to be "network-only" or "no-cache") won't override the original options.
      newNetworkStatus === NetworkStatus.poll
    );
    const oldVariables = this.variables;
    const oldFetchPolicy = this.options.fetchPolicy;
    const mergedOptions = compact(this.options, newOptions || {});
    const options = useDisposableObservable ? (
      // Disposable Observable fetches receive a shallow copy of this.options
      // (merged with newOptions), leaving this.options unmodified.
      mergedOptions
    ) : assign(this.options, mergedOptions);
    const query = this.transformDocument(options.query);
    this.lastQuery = query;
    if (newOptions && "variables" in newOptions) {
      options.variables = this.getVariablesWithDefaults(newOptions.variables);
    }
    if (!useDisposableObservable) {
      this.updatePolling();
      if (newOptions && newOptions.variables && !equal(newOptions.variables, oldVariables) && // Don't mess with the fetchPolicy if it's currently "standby".
      options.fetchPolicy !== "standby" && // If we're changing the fetchPolicy anyway, don't try to change it here
      // using applyNextFetchPolicy. The explicit options.fetchPolicy wins.
      (options.fetchPolicy === oldFetchPolicy || // A `nextFetchPolicy` function has even higher priority, though,
      // so in that case `applyNextFetchPolicy` must be called.
      typeof options.nextFetchPolicy === "function")) {
        this.applyNextFetchPolicy("variables-changed", options);
        if (newNetworkStatus === void 0) {
          newNetworkStatus = NetworkStatus.setVariables;
        }
      }
    }
    const oldNetworkStatus = this.networkStatus;
    if (!newNetworkStatus) {
      newNetworkStatus = NetworkStatus.loading;
      if (oldNetworkStatus !== NetworkStatus.loading && (newOptions == null ? void 0 : newOptions.variables) && !equal(newOptions.variables, oldVariables)) {
        newNetworkStatus = NetworkStatus.setVariables;
      }
      if (options.fetchPolicy === "standby") {
        newNetworkStatus = NetworkStatus.ready;
      }
    }
    if (options.fetchPolicy === "standby") {
      this.cancelPolling();
    }
    this.resubscribeCache();
    const { promise, operator: promiseOperator } = getTrackingOperatorPromise(
      (value) => {
        switch (value.kind) {
          case "E":
            throw value.error;
          case "N":
            if (value.source !== "newNetworkStatus" && !value.value.loading)
              return value.value;
        }
      },
      // This default value should only be used when using a `fetchPolicy` of
      // `standby` since that fetch policy completes without emitting a
      // result. Since we are converting this to a QueryResult type, we
      // omit the extra fields from ApolloQueryResult in the default value.
      options.fetchPolicy === "standby" ? { data: void 0 } : void 0
    );
    const { subscription, observable, fromLink } = this.fetch(options, newNetworkStatus, query, promiseOperator);
    if (!useDisposableObservable && (fromLink || !this.linkSubscription)) {
      if (this.linkSubscription) {
        this.linkSubscription.unsubscribe();
      }
      this.linkSubscription = subscription;
    }
    const ret = Object.assign(preventUnhandledRejection(promise.then((result) => toQueryResult(this.maskResult(result))).finally(() => {
      if (!this.hasObservers() && this.activeOperations.size === 0) {
        this.tearDownQuery();
      }
    })), {
      retain: () => {
        const subscription2 = observable.subscribe({});
        const unsubscribe = () => subscription2.unsubscribe();
        promise.then(unsubscribe, unsubscribe);
        return ret;
      }
    });
    return ret;
  }
  hasObservers() {
    return this.subject.observed;
  }
  /**
   * Tears down the `ObservableQuery` and stops all active operations by sending a `complete` notification.
   */
  stop() {
    this.subject.complete();
    this.initializeObservablesQueue();
    this.tearDownQuery();
  }
  tearDownQuery() {
    var _a2;
    if (this.isTornDown)
      return;
    this.resetNotifications();
    (_a2 = this.unsubscribeFromCache) == null ? void 0 : _a2.call(this);
    if (this.linkSubscription) {
      this.linkSubscription.unsubscribe();
      delete this.linkSubscription;
    }
    this.stopPolling();
    this.subscriptions.forEach((sub) => sub.unsubscribe());
    this.subscriptions.clear();
    this.queryManager.obsQueries.delete(this);
    this.isTornDown = true;
    this.abortActiveOperations();
    this._lastWrite = void 0;
  }
  transformDocument(document) {
    return this.queryManager.transform(document);
  }
  maskResult(result) {
    const masked = this.queryManager.maskOperation({
      document: this.query,
      data: result.data,
      fetchPolicy: this.options.fetchPolicy,
      cause: this
    });
    return masked === result.data ? result : { ...result, data: masked };
  }
  /**
  * @internal
  * 
  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
  */
  resetNotifications() {
    if (this.notifyTimeout) {
      clearTimeout(this.notifyTimeout);
      this.notifyTimeout = void 0;
    }
    this.dirty = false;
  }
  /**
  * @internal
  * 
  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
  */
  scheduleNotify() {
    if (this.dirty)
      return;
    this.dirty = true;
    if (!this.notifyTimeout) {
      this.notifyTimeout = setTimeout(() => this.notify(true), 0);
    }
  }
  /**
  * @internal
  * 
  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
  */
  notify(scheduled = false) {
    if (!scheduled) {
      const info = this.queryManager.getDocumentInfo(this.query);
      if (info.hasClientExports || info.hasForcedResolvers) {
        return;
      }
    }
    const { dirty } = this;
    this.resetNotifications();
    if (dirty && (this.options.fetchPolicy == "cache-only" || this.options.fetchPolicy == "cache-and-network" || !this.activeOperations.size)) {
      const diff = this.getCacheDiff();
      if (
        // `fromOptimisticTransaction` is not available through the `cache.diff`
        // code path, so we need to check it this way
        equal(diff.result, this.getCacheDiff({ optimistic: false }).result)
      ) {
        this.reobserveCacheFirst();
      } else {
        this.input.next({
          kind: "N",
          value: {
            data: diff.result,
            dataState: diff.complete ? "complete" : diff.result ? "partial" : "empty",
            networkStatus: NetworkStatus.ready,
            loading: false,
            error: void 0,
            partial: !diff.complete
          },
          source: "cache",
          query: this.query,
          variables: this.variables,
          meta: {}
        });
      }
    }
  }
  pushOperation(networkStatus) {
    let aborted = false;
    const { query, variables } = this;
    const finalize2 = () => {
      this.activeOperations.delete(operation);
    };
    const operation = {
      override: networkStatus,
      abort: () => {
        aborted = true;
        finalize2();
      },
      query,
      variables
    };
    this.activeOperations.add(operation);
    return {
      finalize: finalize2,
      pushNotification: (notification, additionalMeta) => {
        if (!aborted) {
          this.input.next({
            ...notification,
            query,
            variables,
            meta: { ...additionalMeta }
          });
        }
      }
    };
  }
  calculateNetworkStatus(baseNetworkStatus) {
    if (baseNetworkStatus === NetworkStatus.streaming) {
      return baseNetworkStatus;
    }
    const operation = Array.from(this.activeOperations.values()).findLast((operation2) => isEqualQuery(operation2, this) && operation2.override !== void 0);
    return (operation == null ? void 0 : operation.override) ?? baseNetworkStatus;
  }
  abortActiveOperations() {
    this.activeOperations.forEach((operation) => operation.abort());
  }
  /**
  * @internal
  * Called from `clearStore`.
  *
  * - resets the query to its initial state
  * - cancels all active operations and their subscriptions
  * 
  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
  */
  reset() {
    const resetToEmpty = this.options.fetchPolicy === "cache-only";
    this.setResult(resetToEmpty ? empty2 : uninitialized, {
      shouldEmit: resetToEmpty ? 1 : 2
    });
    this.abortActiveOperations();
  }
  /**
  * @internal
  * 
  * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
  */
  setResult(result, additionalMeta) {
    this.input.next({
      source: "setResult",
      kind: "N",
      value: result,
      query: this.query,
      variables: this.variables,
      meta: { ...additionalMeta }
    });
  }
  // Reobserve with fetchPolicy effectively set to "cache-first", triggering
  // delivery of any new data from the cache, possibly falling back to the network
  // if any cache data are missing. This allows _complete_ cache results to be
  // delivered without also kicking off unnecessary network requests when
  // this.options.fetchPolicy is "cache-and-network" or "network-only". When
  // this.options.fetchPolicy is any other policy ("cache-first", "cache-only",
  // "standby", or "no-cache"), we call this.reobserve() as usual.
  reobserveCacheFirst() {
    const { fetchPolicy, nextFetchPolicy } = this.options;
    if (fetchPolicy === "cache-and-network" || fetchPolicy === "network-only") {
      this.reobserve({
        fetchPolicy: "cache-first",
        // Use a temporary nextFetchPolicy function that replaces itself with the
        // previous nextFetchPolicy value and returns the original fetchPolicy.
        nextFetchPolicy(currentFetchPolicy, context) {
          this.nextFetchPolicy = nextFetchPolicy;
          if (typeof this.nextFetchPolicy === "function") {
            return this.nextFetchPolicy(currentFetchPolicy, context);
          }
          return fetchPolicy;
        }
      });
    } else {
      this.reobserve();
    }
  }
  getVariablesWithDefaults(variables) {
    return this.queryManager.getVariables(this.query, variables);
  }
};
function logMissingFieldErrors(missing) {
  if (__DEV__ && missing) {
    __DEV__ && invariant2.debug(82, missing);
  }
}
function isEqualQuery(a, b) {
  return !!(a && b && a.query === b.query && equal(a.variables, b.variables));
}
function getTrackingOperatorPromise(filterMapCb, defaultValue) {
  let lastValue = defaultValue, resolve, reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  const operator = (0, import_rxjs5.tap)({
    next(value) {
      try {
        const newValue = filterMapCb(value);
        if (newValue !== void 0) {
          lastValue = newValue;
        }
      } catch (error) {
        reject(error);
      }
    },
    finalize: () => {
      if (lastValue) {
        resolve(lastValue);
      } else {
        const message = "The operation was aborted.";
        const name = "AbortError";
        reject(typeof DOMException !== "undefined" ? new DOMException(message, name) : Object.assign(new Error(message), { name }));
      }
    }
  });
  return { promise, operator };
}

// node_modules/@apollo/client/core/QueryInfo.js
var IGNORE = {};
var destructiveMethodCounts = /* @__PURE__ */ new WeakMap();
function wrapDestructiveCacheMethod(cache, methodName) {
  const original = cache[methodName];
  if (typeof original === "function") {
    cache[methodName] = function() {
      destructiveMethodCounts.set(
        cache,
        // The %1e15 allows the count to wrap around to 0 safely every
        // quadrillion evictions, so there's no risk of overflow. To be
        // clear, this is more of a pedantic principle than something
        // that matters in any conceivable practical scenario.
        (destructiveMethodCounts.get(cache) + 1) % 1e15
      );
      return original.apply(this, arguments);
    };
  }
}
var queryInfoIds = /* @__PURE__ */ new WeakMap();
var QueryInfo = class {
  constructor(queryManager, observableQuery) {
    // TODO remove soon - this should be able to be handled by cancelling old operations before starting new ones
    __publicField(this, "lastRequestId", 1);
    __publicField(this, "cache");
    __publicField(this, "queryManager");
    __publicField(this, "id");
    __publicField(this, "observableQuery");
    __publicField(this, "incremental");
    /**
    * @internal
    * For feud-preventing behaviour, `lastWrite` should be shared by all `QueryInfo` instances of an `ObservableQuery`.
    * In the case of a standalone `QueryInfo`, we will keep a local version.
    * 
    * @deprecated This is an internal API and should not be used directly. This can be removed or changed at any time.
    */
    __publicField(this, "_lastWrite");
    const cache = this.cache = queryManager.cache;
    const id = (queryInfoIds.get(queryManager) || 0) + 1;
    queryInfoIds.set(queryManager, id);
    this.id = id + "";
    this.observableQuery = observableQuery;
    this.queryManager = queryManager;
    if (!destructiveMethodCounts.has(cache)) {
      destructiveMethodCounts.set(cache, 0);
      wrapDestructiveCacheMethod(cache, "evict");
      wrapDestructiveCacheMethod(cache, "modify");
      wrapDestructiveCacheMethod(cache, "reset");
    }
  }
  get lastWrite() {
    return (this.observableQuery || this)._lastWrite;
  }
  set lastWrite(value) {
    (this.observableQuery || this)._lastWrite = value;
  }
  resetLastWrite() {
    this.lastWrite = void 0;
  }
  shouldWrite(result, variables) {
    const { lastWrite } = this;
    return !(lastWrite && // If cache.evict has been called since the last time we wrote this
    // data into the cache, there's a chance writing this result into
    // the cache will repair what was evicted.
    lastWrite.dmCount === destructiveMethodCounts.get(this.cache) && equal(variables, lastWrite.variables) && equal(result.data, lastWrite.result.data));
  }
  get hasNext() {
    return this.incremental ? this.incremental.hasNext : false;
  }
  maybeHandleIncrementalResult(cacheData, incoming, query) {
    const { incrementalHandler } = this.queryManager;
    if (incrementalHandler.isIncrementalResult(incoming)) {
      this.incremental || (this.incremental = incrementalHandler.startRequest({
        query
      }));
      return this.incremental.handle(cacheData, incoming);
    }
    return incoming;
  }
  markQueryResult(incoming, { document: query, variables, errorPolicy, cacheWriteBehavior }) {
    var _a2;
    const diffOptions = {
      query,
      variables,
      returnPartialData: true,
      optimistic: true
    };
    (_a2 = this.observableQuery) == null ? void 0 : _a2["resetNotifications"]();
    const skipCache = cacheWriteBehavior === 0;
    const lastDiff = skipCache ? void 0 : this.cache.diff(diffOptions);
    let result = this.maybeHandleIncrementalResult(lastDiff == null ? void 0 : lastDiff.result, incoming, query);
    if (skipCache) {
      return result;
    }
    if (shouldWriteResult(result, errorPolicy)) {
      this.cache.batch({
        onWatchUpdated: (watch, diff) => {
          if (watch.watcher === this.observableQuery) {
            watch.lastOwnDiff = diff;
          }
        },
        update: (cache) => {
          if (this.shouldWrite(result, variables)) {
            cache.writeQuery({
              query,
              data: result.data,
              variables,
              overwrite: cacheWriteBehavior === 1
            });
            this.lastWrite = {
              result,
              variables,
              dmCount: destructiveMethodCounts.get(this.cache)
            };
          } else {
            if (lastDiff && lastDiff.complete) {
              result = { ...result, data: lastDiff.result };
              return;
            }
          }
          const diff = cache.diff(diffOptions);
          if (diff.complete) {
            result = { ...result, data: diff.result };
          }
        }
      });
    } else {
      this.lastWrite = void 0;
    }
    return result;
  }
  markMutationResult(incoming, mutation, cache = this.cache) {
    const cacheWrites = [];
    const skipCache = mutation.cacheWriteBehavior === 0;
    let result = this.maybeHandleIncrementalResult(skipCache ? void 0 : cache.diff({
      id: "ROOT_MUTATION",
      // The cache complains if passed a mutation where it expects a
      // query, so we transform mutations and subscriptions to queries
      // (only once, thanks to this.transformCache).
      query: this.queryManager.getDocumentInfo(mutation.document).asQuery,
      variables: mutation.variables,
      optimistic: false,
      returnPartialData: true
    }).result, incoming, mutation.document);
    if (mutation.errorPolicy === "ignore") {
      result = { ...result, errors: [] };
    }
    if (graphQLResultHasError(result) && mutation.errorPolicy === "none") {
      return Promise.resolve(result);
    }
    const getResultWithDataState = () => ({
      ...result,
      dataState: this.hasNext ? "streaming" : "complete"
    });
    if (!skipCache && shouldWriteResult(result, mutation.errorPolicy)) {
      cacheWrites.push({
        result: result.data,
        dataId: "ROOT_MUTATION",
        query: mutation.document,
        variables: mutation.variables
      });
      const { updateQueries } = mutation;
      if (updateQueries) {
        this.queryManager.getObservableQueries("all").forEach((observableQuery) => {
          const queryName = observableQuery && observableQuery.queryName;
          if (!queryName || !Object.hasOwnProperty.call(updateQueries, queryName)) {
            return;
          }
          const updater = updateQueries[queryName];
          const { query: document, variables } = observableQuery;
          const { result: currentQueryResult, complete } = observableQuery.getCacheDiff({ optimistic: false });
          if (complete && currentQueryResult) {
            const nextQueryResult = updater(currentQueryResult, {
              mutationResult: getResultWithDataState(),
              queryName: document && getOperationName(document) || void 0,
              queryVariables: variables
            });
            if (nextQueryResult) {
              cacheWrites.push({
                result: nextQueryResult,
                dataId: "ROOT_QUERY",
                query: document,
                variables
              });
            }
          }
        });
      }
    }
    let refetchQueries = mutation.refetchQueries;
    if (typeof refetchQueries === "function") {
      refetchQueries = refetchQueries(getResultWithDataState());
    }
    if (cacheWrites.length > 0 || (refetchQueries || "").length > 0 || mutation.update || mutation.onQueryUpdated || mutation.removeOptimistic) {
      const results = [];
      this.queryManager.refetchQueries({
        updateCache: (cache2) => {
          if (!skipCache) {
            cacheWrites.forEach((write) => cache2.write(write));
          }
          const { update } = mutation;
          if (update) {
            if (!skipCache) {
              const diff = cache2.diff({
                id: "ROOT_MUTATION",
                // The cache complains if passed a mutation where it expects a
                // query, so we transform mutations and subscriptions to queries
                // (only once, thanks to this.transformCache).
                query: this.queryManager.getDocumentInfo(mutation.document).asQuery,
                variables: mutation.variables,
                optimistic: false,
                returnPartialData: true
              });
              if (diff.complete) {
                result = {
                  ...result,
                  data: diff.result
                };
              }
            }
            if (!this.hasNext) {
              update(cache2, result, {
                context: mutation.context,
                variables: mutation.variables
              });
            }
          }
          if (!skipCache && !mutation.keepRootFields && !this.hasNext) {
            cache2.modify({
              id: "ROOT_MUTATION",
              fields(value, { fieldName, DELETE: DELETE2 }) {
                return fieldName === "__typename" ? value : DELETE2;
              }
            });
          }
        },
        include: refetchQueries,
        // Write the final mutation.result to the root layer of the cache.
        optimistic: false,
        // Remove the corresponding optimistic layer at the same time as we
        // write the final non-optimistic result.
        removeOptimistic: mutation.removeOptimistic,
        // Let the caller of client.mutate optionally determine the refetching
        // behavior for watched queries after the mutation.update function runs.
        // If no onQueryUpdated function was provided for this mutation, pass
        // null instead of undefined to disable the default refetching behavior.
        onQueryUpdated: mutation.onQueryUpdated || null
      }).forEach((result2) => results.push(result2));
      if (mutation.awaitRefetchQueries || mutation.onQueryUpdated) {
        return Promise.all(results).then(() => result);
      }
    }
    return Promise.resolve(result);
  }
  markMutationOptimistic(optimisticResponse, mutation) {
    const data = typeof optimisticResponse === "function" ? optimisticResponse(mutation.variables, { IGNORE }) : optimisticResponse;
    if (data === IGNORE) {
      return false;
    }
    this.cache.recordOptimisticTransaction((cache) => {
      try {
        this.markMutationResult({ data }, mutation, cache);
      } catch (error) {
        invariant2.error(error);
      }
    }, this.id);
    return true;
  }
  markSubscriptionResult(result, { document, variables, errorPolicy, cacheWriteBehavior }) {
    if (cacheWriteBehavior !== 0) {
      if (shouldWriteResult(result, errorPolicy)) {
        this.cache.write({
          query: document,
          result: result.data,
          dataId: "ROOT_SUBSCRIPTION",
          variables
        });
      }
      this.queryManager.broadcastQueries();
    }
  }
};
function shouldWriteResult(result, errorPolicy = "none") {
  const ignoreErrors = errorPolicy === "ignore" || errorPolicy === "all";
  let writeWithErrors = !graphQLResultHasError(result);
  if (!writeWithErrors && ignoreErrors && result.data) {
    writeWithErrors = true;
  }
  return writeWithErrors;
}

// node_modules/@apollo/client/core/QueryManager.js
var QueryManager = class {
  constructor(options) {
    __publicField(this, "defaultOptions");
    __publicField(this, "client");
    /**
     * The options that were passed to the ApolloClient constructor.
     */
    __publicField(this, "clientOptions");
    __publicField(this, "assumeImmutableResults");
    __publicField(this, "documentTransform");
    __publicField(this, "ssrMode");
    __publicField(this, "defaultContext");
    __publicField(this, "dataMasking");
    __publicField(this, "incrementalHandler");
    __publicField(this, "localState");
    __publicField(this, "queryDeduplication");
    /**
     * Whether to prioritize cache values over network results when
     * `fetchObservableWithInfo` is called.
     * This will essentially turn a `"network-only"` or `"cache-and-network"`
     * fetchPolicy into a `"cache-first"` fetchPolicy, but without influencing
     * the `fetchPolicy` of the `ObservableQuery`.
     *
     * This can e.g. be used to prioritize the cache during the first render after
     * SSR.
     */
    __publicField(this, "prioritizeCacheValues", false);
    __publicField(this, "onBroadcast");
    __publicField(this, "mutationStore");
    /**
     * All ObservableQueries that currently have at least one subscriber.
     */
    __publicField(this, "obsQueries", /* @__PURE__ */ new Set());
    // Maps from queryInfo.id strings to Promise rejection functions for
    // currently active queries and fetches.
    // Use protected instead of private field so
    // @apollo/experimental-nextjs-app-support can access type info.
    __publicField(this, "fetchCancelFns", /* @__PURE__ */ new Map());
    __publicField(this, "transformCache", new AutoCleanedWeakCache(
      cacheSizes["queryManager.getDocumentInfo"] || 2e3
      /* defaultCacheSizes["queryManager.getDocumentInfo"] */
    ));
    __publicField(this, "requestIdCounter", 1);
    // Use protected instead of private field so
    // @apollo/experimental-nextjs-app-support can access type info.
    __publicField(this, "inFlightLinkObservables", new Trie(false));
    __publicField(this, "noCacheWarningsByCause", /* @__PURE__ */ new WeakSet());
    const defaultDocumentTransform = new DocumentTransform(
      (document) => this.cache.transformDocument(document),
      // Allow the apollo cache to manage its own transform caches
      { cache: false }
    );
    this.client = options.client;
    this.defaultOptions = options.defaultOptions;
    this.queryDeduplication = options.queryDeduplication;
    this.clientOptions = options.clientOptions;
    this.ssrMode = options.ssrMode;
    this.assumeImmutableResults = options.assumeImmutableResults;
    this.dataMasking = options.dataMasking;
    this.localState = options.localState;
    this.incrementalHandler = options.incrementalHandler;
    const documentTransform = options.documentTransform;
    this.documentTransform = documentTransform ? defaultDocumentTransform.concat(documentTransform).concat(defaultDocumentTransform) : defaultDocumentTransform;
    this.defaultContext = options.defaultContext || {};
    if (this.onBroadcast = options.onBroadcast) {
      this.mutationStore = {};
    }
  }
  get link() {
    return this.client.link;
  }
  get cache() {
    return this.client.cache;
  }
  /**
   * Call this method to terminate any active query processes, making it safe
   * to dispose of this QueryManager instance.
   */
  stop() {
    this.obsQueries.forEach((oq) => oq.stop());
    this.cancelPendingFetches(newInvariantError(83));
  }
  cancelPendingFetches(error) {
    this.fetchCancelFns.forEach((cancel) => cancel(error));
    this.fetchCancelFns.clear();
  }
  async mutate({ mutation, variables, optimisticResponse, updateQueries, refetchQueries = [], awaitRefetchQueries = false, update: updateWithProxyFn, onQueryUpdated, fetchPolicy, errorPolicy, keepRootFields, context }) {
    const queryInfo = new QueryInfo(this);
    mutation = this.cache.transformForLink(this.transform(mutation));
    const { hasClientExports } = this.getDocumentInfo(mutation);
    variables = this.getVariables(mutation, variables);
    if (hasClientExports) {
      if (__DEV__) {
        invariant2(this.localState, 84, getOperationName(mutation, "(anonymous)"));
      }
      variables = await this.localState.getExportedVariables({
        client: this.client,
        document: mutation,
        variables,
        context
      });
    }
    const mutationStoreValue = this.mutationStore && (this.mutationStore[queryInfo.id] = {
      mutation,
      variables,
      loading: true,
      error: null
    });
    const isOptimistic = optimisticResponse && queryInfo.markMutationOptimistic(optimisticResponse, {
      document: mutation,
      variables,
      cacheWriteBehavior: fetchPolicy === "no-cache" ? 0 : 2,
      errorPolicy,
      context,
      updateQueries,
      update: updateWithProxyFn,
      keepRootFields
    });
    this.broadcastQueries();
    return new Promise((resolve, reject) => {
      const cause = {};
      return this.getObservableFromLink(mutation, {
        ...context,
        optimisticResponse: isOptimistic ? optimisticResponse : void 0
      }, variables, {}, false).observable.pipe(validateDidEmitValue(), (0, import_rxjs7.mergeMap)((result) => {
        const storeResult = { ...result };
        return (0, import_rxjs7.from)(queryInfo.markMutationResult(storeResult, {
          document: mutation,
          variables,
          cacheWriteBehavior: fetchPolicy === "no-cache" ? 0 : 2,
          errorPolicy,
          context,
          update: updateWithProxyFn,
          updateQueries,
          awaitRefetchQueries,
          refetchQueries,
          removeOptimistic: isOptimistic ? queryInfo.id : void 0,
          onQueryUpdated,
          keepRootFields
        }));
      })).pipe((0, import_rxjs7.map)((storeResult) => {
        const hasErrors = graphQLResultHasError(storeResult);
        if (hasErrors && errorPolicy === "none") {
          throw new CombinedGraphQLErrors(storeResult);
        }
        if (mutationStoreValue) {
          mutationStoreValue.loading = false;
          mutationStoreValue.error = null;
        }
        return storeResult;
      })).subscribe({
        next: (storeResult) => {
          this.broadcastQueries();
          if (!queryInfo.hasNext) {
            const result = {
              data: this.maskOperation({
                document: mutation,
                data: storeResult.data,
                fetchPolicy,
                cause
              })
            };
            if (graphQLResultHasError(storeResult)) {
              result.error = new CombinedGraphQLErrors(storeResult);
            }
            if (Object.keys(storeResult.extensions || {}).length) {
              result.extensions = storeResult.extensions;
            }
            resolve(result);
          }
        },
        error: (error) => {
          if (mutationStoreValue) {
            mutationStoreValue.loading = false;
            mutationStoreValue.error = error;
          }
          if (isOptimistic) {
            this.cache.removeOptimistic(queryInfo.id);
          }
          this.broadcastQueries();
          if (errorPolicy === "ignore") {
            return resolve({ data: void 0 });
          }
          if (errorPolicy === "all") {
            return resolve({ data: void 0, error });
          }
          reject(error);
        }
      });
    });
  }
  fetchQuery(options, networkStatus) {
    checkDocument(options.query, OperationTypeNode.QUERY);
    return (async () => (0, import_rxjs7.lastValueFrom)(this.fetchObservableWithInfo(options, {
      networkStatus
    }).observable.pipe(filterMap((value) => {
      switch (value.kind) {
        case "E":
          throw value.error;
        case "N": {
          if (value.source !== "newNetworkStatus")
            return toQueryResult(value.value);
        }
      }
    })), {
      // This default is needed when a `standby` fetch policy is used to avoid
      // an EmptyError from rejecting this promise.
      defaultValue: { data: void 0 }
    }))();
  }
  transform(document) {
    return this.documentTransform.transformDocument(document);
  }
  getDocumentInfo(document) {
    const { transformCache } = this;
    if (!transformCache.has(document)) {
      const operationDefinition = getOperationDefinition(document);
      const cacheEntry = {
        // TODO These three calls (hasClientExports, shouldForceResolvers, and
        // usesNonreactiveDirective) are performing independent full traversals
        // of the transformed document. We should consider merging these
        // traversals into a single pass in the future, though the work is
        // cached after the first time.
        hasClientExports: hasDirectives(["client", "export"], document, true),
        hasForcedResolvers: hasForcedResolvers(document),
        hasNonreactiveDirective: hasDirectives(["nonreactive"], document),
        hasIncrementalDirective: hasDirectives(["defer"], document),
        nonReactiveQuery: addNonReactiveToNamedFragments(document),
        clientQuery: hasDirectives(["client"], document) ? document : null,
        serverQuery: removeDirectivesFromDocument([
          { name: "client", remove: true },
          { name: "connection" },
          { name: "nonreactive" },
          { name: "unmask" }
        ], document),
        operationType: operationDefinition == null ? void 0 : operationDefinition.operation,
        defaultVars: getDefaultValues(operationDefinition),
        // Transform any mutation or subscription operations to query operations
        // so we can read/write them from/to the cache.
        asQuery: {
          ...document,
          definitions: document.definitions.map((def) => {
            if (def.kind === "OperationDefinition" && def.operation !== "query") {
              return { ...def, operation: "query" };
            }
            return def;
          })
        }
      };
      transformCache.set(document, cacheEntry);
    }
    const entry = transformCache.get(document);
    if (entry.violation) {
      throw entry.violation;
    }
    return entry;
  }
  getVariables(document, variables) {
    const defaultVars = this.getDocumentInfo(document).defaultVars;
    const varsWithDefaults = Object.entries(variables ?? {}).map(([key, value]) => [key, value === void 0 ? defaultVars[key] : value]);
    return {
      ...defaultVars,
      ...Object.fromEntries(varsWithDefaults)
    };
  }
  watchQuery(options) {
    checkDocument(options.query, OperationTypeNode.QUERY);
    const query = this.transform(options.query);
    options = {
      ...options,
      variables: this.getVariables(query, options.variables)
    };
    if (typeof options.notifyOnNetworkStatusChange === "undefined") {
      options.notifyOnNetworkStatusChange = true;
    }
    const observable = new ObservableQuery({
      queryManager: this,
      options,
      transformedQuery: query
    });
    return observable;
  }
  query(options) {
    const query = this.transform(options.query);
    return this.fetchQuery({
      ...options,
      query
    }).then((value) => ({
      ...value,
      data: this.maskOperation({
        document: query,
        data: value == null ? void 0 : value.data,
        fetchPolicy: options.fetchPolicy
      })
    }));
  }
  generateRequestId() {
    return this.requestIdCounter++;
  }
  clearStore(options = {
    discardWatches: true
  }) {
    this.cancelPendingFetches(newInvariantError(85));
    this.obsQueries.forEach((observableQuery) => {
      observableQuery.reset();
    });
    if (this.mutationStore) {
      this.mutationStore = {};
    }
    return this.cache.reset(options);
  }
  getObservableQueries(include = "active") {
    const queries = /* @__PURE__ */ new Set();
    const queryNames = /* @__PURE__ */ new Map();
    const queryNamesAndQueryStrings = /* @__PURE__ */ new Map();
    const legacyQueryOptions = /* @__PURE__ */ new Set();
    if (Array.isArray(include)) {
      include.forEach((desc) => {
        if (typeof desc === "string") {
          queryNames.set(desc, desc);
          queryNamesAndQueryStrings.set(desc, false);
        } else if (isDocumentNode(desc)) {
          const queryString = print2(this.transform(desc));
          queryNames.set(queryString, getOperationName(desc));
          queryNamesAndQueryStrings.set(queryString, false);
        } else if (isNonNullObject(desc) && desc.query) {
          legacyQueryOptions.add(desc);
        }
      });
    }
    this.obsQueries.forEach((oq) => {
      const document = print2(this.transform(oq.options.query));
      if (include === "all") {
        queries.add(oq);
        return;
      }
      const { queryName, options: { fetchPolicy } } = oq;
      if (include === "active" && fetchPolicy === "standby") {
        return;
      }
      if (include === "active" || queryName && queryNamesAndQueryStrings.has(queryName) || document && queryNamesAndQueryStrings.has(document)) {
        queries.add(oq);
        if (queryName)
          queryNamesAndQueryStrings.set(queryName, true);
        if (document)
          queryNamesAndQueryStrings.set(document, true);
      }
    });
    if (legacyQueryOptions.size) {
      legacyQueryOptions.forEach((options) => {
        const oq = new ObservableQuery({
          queryManager: this,
          options: {
            ...options,
            fetchPolicy: "network-only"
          }
        });
        queries.add(oq);
      });
    }
    if (__DEV__ && queryNamesAndQueryStrings.size) {
      queryNamesAndQueryStrings.forEach((included, nameOrQueryString) => {
        if (!included) {
          const queryName = queryNames.get(nameOrQueryString);
          if (queryName) {
            __DEV__ && invariant2.warn(86, queryName);
          } else {
            __DEV__ && invariant2.warn(87);
          }
        }
      });
    }
    return queries;
  }
  refetchObservableQueries(includeStandby = false) {
    const observableQueryPromises = [];
    this.getObservableQueries(includeStandby ? "all" : "active").forEach((observableQuery) => {
      const { fetchPolicy } = observableQuery.options;
      if ((includeStandby || fetchPolicy !== "standby") && fetchPolicy !== "cache-only") {
        observableQueryPromises.push(observableQuery.refetch());
      }
    });
    this.broadcastQueries();
    return Promise.all(observableQueryPromises);
  }
  startGraphQLSubscription(options) {
    let { query, variables } = options;
    const { fetchPolicy, errorPolicy = "none", context = {}, extensions = {} } = options;
    checkDocument(query, OperationTypeNode.SUBSCRIPTION);
    query = this.transform(query);
    variables = this.getVariables(query, variables);
    let restart;
    if (__DEV__) {
      invariant2(
        !this.getDocumentInfo(query).hasClientExports || this.localState,
        88,
        getOperationName(query, "(anonymous)")
      );
    }
    const observable = (this.getDocumentInfo(query).hasClientExports ? (0, import_rxjs7.from)(this.localState.getExportedVariables({
      client: this.client,
      document: query,
      variables,
      context
    })) : (0, import_rxjs7.of)(variables)).pipe((0, import_rxjs7.mergeMap)((variables2) => {
      const { observable: observable2, restart: res } = this.getObservableFromLink(query, context, variables2, extensions);
      const queryInfo = new QueryInfo(this);
      restart = res;
      return observable2.pipe((0, import_rxjs7.map)((rawResult) => {
        queryInfo.markSubscriptionResult(rawResult, {
          document: query,
          variables: variables2,
          errorPolicy,
          cacheWriteBehavior: fetchPolicy === "no-cache" ? 0 : 2
        });
        const result = {
          data: rawResult.data ?? void 0
        };
        if (graphQLResultHasError(rawResult)) {
          result.error = new CombinedGraphQLErrors(rawResult);
        } else if (graphQLResultHasProtocolErrors(rawResult)) {
          result.error = rawResult.extensions[PROTOCOL_ERRORS_SYMBOL];
          delete rawResult.extensions[PROTOCOL_ERRORS_SYMBOL];
        }
        if (rawResult.extensions && Object.keys(rawResult.extensions).length) {
          result.extensions = rawResult.extensions;
        }
        if (result.error && errorPolicy === "none") {
          result.data = void 0;
        }
        if (errorPolicy === "ignore") {
          delete result.error;
        }
        return result;
      }), (0, import_rxjs7.catchError)((error) => {
        if (errorPolicy === "ignore") {
          return (0, import_rxjs7.of)({
            data: void 0
          });
        }
        return (0, import_rxjs7.of)({ data: void 0, error });
      }), (0, import_rxjs7.filter)((result) => !!(result.data || result.error)));
    }));
    return Object.assign(observable, { restart: () => restart == null ? void 0 : restart() });
  }
  broadcastQueries() {
    if (this.onBroadcast)
      this.onBroadcast();
    this.obsQueries.forEach((observableQuery) => observableQuery.notify());
  }
  getObservableFromLink(query, context, variables, extensions, deduplication = (context == null ? void 0 : context.queryDeduplication) ?? this.queryDeduplication) {
    let entry = {};
    const { serverQuery, clientQuery, operationType, hasIncrementalDirective } = this.getDocumentInfo(query);
    const operationName = getOperationName(query);
    const executeContext = {
      client: this.client
    };
    if (serverQuery) {
      const { inFlightLinkObservables, link } = this;
      try {
        let withRestart = function(source) {
          return new import_rxjs6.Observable((observer) => {
            function subscribe() {
              return source.subscribe({
                next: observer.next.bind(observer),
                complete: observer.complete.bind(observer),
                error: observer.error.bind(observer)
              });
            }
            let subscription = subscribe();
            entry.restart || (entry.restart = () => {
              subscription.unsubscribe();
              subscription = subscribe();
            });
            return () => {
              subscription.unsubscribe();
              entry.restart = void 0;
            };
          });
        };
        const operation = this.incrementalHandler.prepareRequest({
          query: serverQuery,
          variables,
          context: {
            ...this.defaultContext,
            ...context,
            queryDeduplication: deduplication
          },
          extensions
        });
        context = operation.context;
        if (deduplication) {
          const printedServerQuery = print2(serverQuery);
          const varJson = canonicalStringify(variables);
          entry = inFlightLinkObservables.lookup(printedServerQuery, varJson);
          if (!entry.observable) {
            entry.observable = execute(link, operation, executeContext).pipe(
              withRestart,
              (0, import_rxjs7.finalize)(() => {
                if (inFlightLinkObservables.peek(printedServerQuery, varJson) === entry) {
                  inFlightLinkObservables.remove(printedServerQuery, varJson);
                }
              }),
              // We don't want to replay the last emitted value for
              // subscriptions and instead opt to wait to receive updates until
              // the subscription emits new values.
              operationType === OperationTypeNode.SUBSCRIPTION ? (0, import_rxjs7.share)() : (0, import_rxjs7.shareReplay)({ refCount: true })
            );
          }
        } else {
          entry.observable = execute(link, operation, executeContext).pipe(withRestart);
        }
      } catch (error) {
        entry.observable = (0, import_rxjs6.throwError)(() => error);
      }
    } else {
      entry.observable = (0, import_rxjs7.of)({ data: {} });
    }
    if (clientQuery) {
      const { operation } = getOperationDefinition(query);
      if (__DEV__) {
        invariant2(
          this.localState,
          89,
          operation[0].toUpperCase() + operation.slice(1),
          operationName ?? "(anonymous)"
        );
      }
      invariant2(
        !hasIncrementalDirective,
        90,
        operation[0].toUpperCase() + operation.slice(1),
        operationName ?? "(anonymous)"
      );
      entry.observable = entry.observable.pipe((0, import_rxjs7.mergeMap)((result) => {
        return (0, import_rxjs7.from)(this.localState.execute({
          client: this.client,
          document: clientQuery,
          remoteResult: result,
          context,
          variables
        }));
      }));
    }
    return {
      restart: () => {
        var _a2;
        return (_a2 = entry.restart) == null ? void 0 : _a2.call(entry);
      },
      observable: entry.observable.pipe((0, import_rxjs7.catchError)((error) => {
        error = toErrorLike(error);
        registerLinkError(error);
        throw error;
      }))
    };
  }
  getResultsFromLink(options, { queryInfo, cacheWriteBehavior, observableQuery }) {
    const requestId = queryInfo.lastRequestId = this.generateRequestId();
    const { errorPolicy } = options;
    const linkDocument = this.cache.transformForLink(options.query);
    return this.getObservableFromLink(linkDocument, options.context, options.variables).observable.pipe((0, import_rxjs7.map)((incoming) => {
      const result = queryInfo.markQueryResult(incoming, {
        ...options,
        document: linkDocument,
        cacheWriteBehavior
      });
      const hasErrors = graphQLResultHasError(result);
      if (hasErrors && errorPolicy === "none") {
        queryInfo.resetLastWrite();
        observableQuery == null ? void 0 : observableQuery["resetNotifications"]();
        throw new CombinedGraphQLErrors(result);
      }
      const aqr = {
        data: result.data,
        ...queryInfo.hasNext ? {
          loading: true,
          networkStatus: NetworkStatus.streaming,
          dataState: "streaming",
          partial: true
        } : {
          dataState: result.data ? "complete" : "empty",
          loading: false,
          networkStatus: NetworkStatus.ready,
          partial: !result.data
        }
      };
      if (hasErrors) {
        if (errorPolicy === "none") {
          aqr.data = void 0;
          aqr.dataState = "empty";
        }
        if (errorPolicy !== "ignore") {
          aqr.error = new CombinedGraphQLErrors(result);
          if (aqr.dataState !== "streaming") {
            aqr.networkStatus = NetworkStatus.error;
          }
        }
      }
      return aqr;
    }), (0, import_rxjs7.catchError)((error) => {
      if (requestId >= queryInfo.lastRequestId && errorPolicy === "none") {
        queryInfo.resetLastWrite();
        observableQuery == null ? void 0 : observableQuery["resetNotifications"]();
        throw error;
      }
      const aqr = {
        data: void 0,
        dataState: "empty",
        loading: false,
        networkStatus: NetworkStatus.ready,
        partial: true
      };
      if (errorPolicy !== "ignore") {
        aqr.error = error;
        aqr.networkStatus = NetworkStatus.error;
      }
      return (0, import_rxjs7.of)(aqr);
    }));
  }
  fetchObservableWithInfo(options, {
    // The initial networkStatus for this fetch, most often
    // NetworkStatus.loading, but also possibly fetchMore, poll, refetch,
    // or setVariables.
    networkStatus = NetworkStatus.loading,
    query = options.query,
    fetchQueryOperator = (x) => x,
    onCacheHit = () => {
    },
    observableQuery
  }) {
    const variables = this.getVariables(query, options.variables);
    const defaults = this.defaultOptions.watchQuery;
    let { fetchPolicy = defaults && defaults.fetchPolicy || "cache-first", errorPolicy = defaults && defaults.errorPolicy || "none", returnPartialData = false, notifyOnNetworkStatusChange = true, context = {} } = options;
    if (this.prioritizeCacheValues && (fetchPolicy === "network-only" || fetchPolicy === "cache-and-network")) {
      fetchPolicy = "cache-first";
    }
    const normalized = Object.assign({}, options, {
      query,
      variables,
      fetchPolicy,
      errorPolicy,
      returnPartialData,
      notifyOnNetworkStatusChange,
      context
    });
    const queryInfo = new QueryInfo(this, observableQuery);
    const fromVariables = (variables2) => {
      normalized.variables = variables2;
      const cacheWriteBehavior = fetchPolicy === "no-cache" ? 0 : networkStatus === NetworkStatus.refetch && normalized.refetchWritePolicy !== "merge" ? 1 : 2;
      const observableWithInfo = this.fetchQueryByPolicy(normalized, { queryInfo, cacheWriteBehavior, onCacheHit, observableQuery });
      observableWithInfo.observable = observableWithInfo.observable.pipe(fetchQueryOperator);
      if (
        // If we're in standby, postpone advancing options.fetchPolicy using
        // applyNextFetchPolicy.
        normalized.fetchPolicy !== "standby"
      ) {
        observableQuery == null ? void 0 : observableQuery["applyNextFetchPolicy"]("after-fetch", options);
      }
      return observableWithInfo;
    };
    const cleanupCancelFn = () => {
      this.fetchCancelFns.delete(queryInfo.id);
    };
    this.fetchCancelFns.set(queryInfo.id, (error) => {
      fetchCancelSubject.next({
        kind: "E",
        error,
        source: "network"
      });
    });
    const fetchCancelSubject = new import_rxjs7.Subject();
    let observable, containsDataFromLink;
    if (this.getDocumentInfo(normalized.query).hasClientExports) {
      if (__DEV__) {
        invariant2(this.localState, 91, getOperationName(normalized.query, "(anonymous)"));
      }
      observable = (0, import_rxjs7.from)(this.localState.getExportedVariables({
        client: this.client,
        document: normalized.query,
        variables: normalized.variables,
        context: normalized.context
      })).pipe((0, import_rxjs7.mergeMap)((variables2) => fromVariables(variables2).observable));
      containsDataFromLink = true;
    } else {
      const sourcesWithInfo = fromVariables(normalized.variables);
      containsDataFromLink = sourcesWithInfo.fromLink;
      observable = sourcesWithInfo.observable;
    }
    return {
      // Merge `observable` with `fetchCancelSubject`, in a way that completing or
      // erroring either of them will complete the merged obserable.
      observable: new import_rxjs6.Observable((observer) => {
        observer.add(cleanupCancelFn);
        observable.subscribe(observer);
        fetchCancelSubject.subscribe(observer);
      }).pipe((0, import_rxjs7.share)()),
      fromLink: containsDataFromLink
    };
  }
  refetchQueries({ updateCache, include, optimistic = false, removeOptimistic = optimistic ? makeUniqueId("refetchQueries") : void 0, onQueryUpdated }) {
    const includedQueriesByOq = /* @__PURE__ */ new Map();
    if (include) {
      this.getObservableQueries(include).forEach((oq) => {
        if (oq.options.fetchPolicy === "cache-only") {
          return;
        }
        const current = oq.getCurrentResult();
        includedQueriesByOq.set(oq, {
          oq,
          lastDiff: {
            result: current == null ? void 0 : current.data,
            complete: !(current == null ? void 0 : current.partial)
          }
        });
      });
    }
    const results = /* @__PURE__ */ new Map();
    if (updateCache) {
      const handled = /* @__PURE__ */ new Set();
      this.cache.batch({
        update: updateCache,
        // Since you can perform any combination of cache reads and/or writes in
        // the cache.batch update function, its optimistic option can be either
        // a boolean or a string, representing three distinct modes of
        // operation:
        //
        // * false: read/write only the root layer
        // * true: read/write the topmost layer
        // * string: read/write a fresh optimistic layer with that ID string
        //
        // When typeof optimistic === "string", a new optimistic layer will be
        // temporarily created within cache.batch with that string as its ID. If
        // we then pass that same string as the removeOptimistic option, we can
        // make cache.batch immediately remove the optimistic layer after
        // running the updateCache function, triggering only one broadcast.
        //
        // However, the refetchQueries method accepts only true or false for its
        // optimistic option (not string). We interpret true to mean a temporary
        // optimistic layer should be created, to allow efficiently rolling back
        // the effect of the updateCache function, which involves passing a
        // string instead of true as the optimistic option to cache.batch, when
        // refetchQueries receives optimistic: true.
        //
        // In other words, we are deliberately not supporting the use case of
        // writing to an *existing* optimistic layer (using the refetchQueries
        // updateCache function), since that would potentially interfere with
        // other optimistic updates in progress. Instead, you can read/write
        // only the root layer by passing optimistic: false to refetchQueries,
        // or you can read/write a brand new optimistic layer that will be
        // automatically removed by passing optimistic: true.
        optimistic: optimistic && removeOptimistic || false,
        // The removeOptimistic option can also be provided by itself, even if
        // optimistic === false, to remove some previously-added optimistic
        // layer safely and efficiently, like we do in markMutationResult.
        //
        // If an explicit removeOptimistic string is provided with optimistic:
        // true, the removeOptimistic string will determine the ID of the
        // temporary optimistic layer, in case that ever matters.
        removeOptimistic,
        onWatchUpdated(watch, diff, lastDiff) {
          const oq = watch.watcher;
          if (oq instanceof ObservableQuery && !handled.has(oq)) {
            handled.add(oq);
            if (onQueryUpdated) {
              includedQueriesByOq.delete(oq);
              let result = onQueryUpdated(oq, diff, lastDiff);
              if (result === true) {
                result = oq.refetch().retain(
                  /* create a persistent subscription on the query */
                );
              }
              if (result !== false) {
                results.set(oq, result);
              }
              return result;
            }
            if (onQueryUpdated !== null && oq.options.fetchPolicy !== "cache-only") {
              includedQueriesByOq.set(oq, { oq, lastDiff, diff });
            }
          }
        }
      });
    }
    if (includedQueriesByOq.size) {
      includedQueriesByOq.forEach(({ oq, lastDiff, diff }) => {
        let result;
        if (onQueryUpdated) {
          if (!diff) {
            diff = oq.getCacheDiff();
          }
          result = onQueryUpdated(oq, diff, lastDiff);
        }
        if (!onQueryUpdated || result === true) {
          result = oq.refetch().retain(
            /* create a persistent subscription on the query */
          );
        }
        if (result !== false) {
          results.set(oq, result);
        }
      });
    }
    if (removeOptimistic) {
      this.cache.removeOptimistic(removeOptimistic);
    }
    return results;
  }
  maskOperation(options) {
    var _a2;
    const { document, data } = options;
    if (__DEV__) {
      const { fetchPolicy, cause = {} } = options;
      const operationType = (_a2 = getOperationDefinition(document)) == null ? void 0 : _a2.operation;
      if (this.dataMasking && fetchPolicy === "no-cache" && !isFullyUnmaskedOperation(document) && !this.noCacheWarningsByCause.has(cause)) {
        this.noCacheWarningsByCause.add(cause);
        __DEV__ && invariant2.warn(92, getOperationName(document, `Unnamed ${operationType ?? "operation"}`));
      }
    }
    return this.dataMasking ? maskOperation(data, document, this.cache) : data;
  }
  maskFragment(options) {
    const { data, fragment, fragmentName } = options;
    return this.dataMasking ? maskFragment(data, fragment, this.cache, fragmentName) : data;
  }
  fetchQueryByPolicy({ query, variables, fetchPolicy, errorPolicy, returnPartialData, context }, { cacheWriteBehavior, onCacheHit, queryInfo, observableQuery }) {
    const readCache = () => this.cache.diff({
      query,
      variables,
      returnPartialData: true,
      optimistic: true
    });
    const resultsFromCache = (diff, networkStatus) => {
      const data = diff.result;
      if (__DEV__ && !returnPartialData && data !== null) {
        logMissingFieldErrors(diff.missing);
      }
      const toResult = (data2) => {
        if (!diff.complete && !returnPartialData) {
          data2 = void 0;
        }
        return {
          // TODO: Handle partial data
          data: data2,
          dataState: diff.complete ? "complete" : data2 ? "partial" : "empty",
          loading: isNetworkRequestInFlight(networkStatus),
          networkStatus,
          partial: !diff.complete
        };
      };
      const fromData = (data2) => {
        return (0, import_rxjs7.of)({
          kind: "N",
          value: toResult(data2),
          source: "cache"
        });
      };
      if (
        // Don't attempt to run forced resolvers if we have incomplete cache
        // data and partial isn't allowed since this result would get set to
        // `undefined` anyways in `toResult`.
        (diff.complete || returnPartialData) && this.getDocumentInfo(query).hasForcedResolvers
      ) {
        if (__DEV__) {
          invariant2(this.localState, 93, getOperationName(query, "(anonymous)"));
        }
        onCacheHit();
        return (0, import_rxjs7.from)(this.localState.execute({
          client: this.client,
          document: query,
          remoteResult: data ? { data } : void 0,
          context,
          variables,
          onlyRunForcedResolvers: true,
          returnPartialData: true
        }).then((resolved) => ({
          kind: "N",
          value: toResult(resolved.data || void 0),
          source: "cache"
        })));
      }
      if (errorPolicy === "none" && networkStatus === NetworkStatus.refetch && diff.missing) {
        return fromData(void 0);
      }
      return fromData(data || void 0);
    };
    const resultsFromLink = () => this.getResultsFromLink({
      query,
      variables,
      context,
      fetchPolicy,
      errorPolicy
    }, {
      cacheWriteBehavior,
      queryInfo,
      observableQuery
    }).pipe(validateDidEmitValue(), (0, import_rxjs7.materialize)(), (0, import_rxjs7.map)((result) => ({
      ...result,
      source: "network"
    })));
    switch (fetchPolicy) {
      default:
      case "cache-first": {
        const diff = readCache();
        if (diff.complete) {
          return {
            fromLink: false,
            observable: resultsFromCache(diff, NetworkStatus.ready)
          };
        }
        if (returnPartialData) {
          return {
            fromLink: true,
            observable: (0, import_rxjs7.concat)(resultsFromCache(diff, NetworkStatus.loading), resultsFromLink())
          };
        }
        return { fromLink: true, observable: resultsFromLink() };
      }
      case "cache-and-network": {
        const diff = readCache();
        if (diff.complete || returnPartialData) {
          return {
            fromLink: true,
            observable: (0, import_rxjs7.concat)(resultsFromCache(diff, NetworkStatus.loading), resultsFromLink())
          };
        }
        return { fromLink: true, observable: resultsFromLink() };
      }
      case "cache-only":
        return {
          fromLink: false,
          observable: (0, import_rxjs7.concat)(resultsFromCache(readCache(), NetworkStatus.ready))
        };
      case "network-only":
        return { fromLink: true, observable: resultsFromLink() };
      case "no-cache":
        return { fromLink: true, observable: resultsFromLink() };
      case "standby":
        return { fromLink: false, observable: import_rxjs7.EMPTY };
    }
  }
};
function validateDidEmitValue() {
  let didEmitValue = false;
  return (0, import_rxjs7.tap)({
    next() {
      didEmitValue = true;
    },
    complete() {
      invariant2(didEmitValue, 94);
    }
  });
}
function isFullyUnmaskedOperation(document) {
  let isUnmasked = true;
  visit(document, {
    FragmentSpread: (node) => {
      isUnmasked = !!node.directives && node.directives.some((directive) => directive.name.value === "unmask");
      if (!isUnmasked) {
        return BREAK;
      }
    }
  });
  return isUnmasked;
}
function addNonReactiveToNamedFragments(document) {
  return visit(document, {
    FragmentSpread: (node) => {
      var _a2;
      if ((_a2 = node.directives) == null ? void 0 : _a2.some((directive) => directive.name.value === "unmask")) {
        return;
      }
      return {
        ...node,
        directives: [
          ...node.directives || [],
          {
            kind: Kind.DIRECTIVE,
            name: { kind: Kind.NAME, value: "nonreactive" }
          }
        ]
      };
    }
  });
}

// node_modules/@apollo/client/core/ApolloClient.js
var hasSuggestedDevtools = false;
var ApolloClient = class {
  /**
   * Constructs an instance of `ApolloClient`.
   *
   * @example
   *
   * ```js
   * import { ApolloClient, InMemoryCache } from "@apollo/client";
   *
   * const cache = new InMemoryCache();
   *
   * const client = new ApolloClient({
   *   // Provide required constructor fields
   *   cache: cache,
   *   uri: "http://localhost:4000/",
   *
   *   // Provide some optional constructor fields
   *   name: "react-web-client",
   *   version: "1.3",
   *   queryDeduplication: false,
   *   defaultOptions: {
   *     watchQuery: {
   *       fetchPolicy: "cache-and-network",
   *     },
   *   },
   * });
   * ```
   */
  constructor(options) {
    __publicField(this, "link");
    __publicField(this, "cache");
    /**
     * @deprecated `disableNetworkFetches` has been renamed to `prioritizeCacheValues`.
     */
    __publicField(this, "disableNetworkFetches");
    __publicField(this, "version");
    __publicField(this, "queryDeduplication");
    __publicField(this, "defaultOptions");
    __publicField(this, "devtoolsConfig");
    __publicField(this, "queryManager");
    __publicField(this, "devToolsHookCb");
    __publicField(this, "resetStoreCallbacks", []);
    __publicField(this, "clearStoreCallbacks", []);
    /**
     * Refetches all of your active queries.
     *
     * `reFetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage
     *
     * It is important to remember that `reFetchObservableQueries()` _will_ refetch any active
     * queries. This means that any components that might be mounted will execute
     * their queries again using your network interface. If you do not want to
     * re-execute any queries then you should make sure to stop watching any
     * active queries.
     * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.
     *
     * Note: `cache-only` queries are not refetched by this function.
     *
     * @deprecated Please use `refetchObservableQueries` instead.
     */
    __publicField(this, "reFetchObservableQueries");
    __publicField(this, "maskedFragmentTransform", new DocumentTransform(removeMaskedFragmentSpreads));
    if (__DEV__) {
      invariant2(options.cache, 65);
      invariant2(options.link, 66);
    }
    const { cache, documentTransform, ssrMode = false, ssrForceFetchDelay = 0, queryDeduplication = true, defaultOptions: defaultOptions2, defaultContext, assumeImmutableResults = cache.assumeImmutableResults, localState, devtools, dataMasking, link, incrementalHandler = new NotImplementedHandler() } = options;
    this.link = link;
    this.cache = cache;
    this.queryDeduplication = queryDeduplication;
    this.defaultOptions = defaultOptions2 || {};
    this.devtoolsConfig = {
      ...devtools,
      enabled: (devtools == null ? void 0 : devtools.enabled) ?? __DEV__
    };
    this.watchQuery = this.watchQuery.bind(this);
    this.query = this.query.bind(this);
    this.mutate = this.mutate.bind(this);
    this.watchFragment = this.watchFragment.bind(this);
    this.resetStore = this.resetStore.bind(this);
    this.reFetchObservableQueries = this.refetchObservableQueries = this.refetchObservableQueries.bind(this);
    this.version = version;
    this.queryManager = new QueryManager({
      client: this,
      defaultOptions: this.defaultOptions,
      defaultContext,
      documentTransform,
      queryDeduplication,
      ssrMode,
      dataMasking: !!dataMasking,
      clientOptions: options,
      incrementalHandler,
      assumeImmutableResults,
      onBroadcast: this.devtoolsConfig.enabled ? () => {
        if (this.devToolsHookCb) {
          this.devToolsHookCb();
        }
      } : void 0,
      localState
    });
    this.prioritizeCacheValues = ssrMode || ssrForceFetchDelay > 0;
    if (ssrForceFetchDelay) {
      setTimeout(() => {
        this.prioritizeCacheValues = false;
      }, ssrForceFetchDelay);
    }
    if (this.devtoolsConfig.enabled)
      this.connectToDevTools();
  }
  set prioritizeCacheValues(value) {
    this.queryManager.prioritizeCacheValues = value;
  }
  /**
   * Whether to prioritize cache values over network results when `query` or `watchQuery` is called.
   * This will essentially turn a `"network-only"` or `"cache-and-network"` fetchPolicy into a `"cache-first"` fetchPolicy,
   * but without influencing the `fetchPolicy` of the created `ObservableQuery` long-term.
   *
   * This can e.g. be used to prioritize the cache during the first render after SSR.
   */
  get prioritizeCacheValues() {
    return this.queryManager.prioritizeCacheValues;
  }
  connectToDevTools() {
    if (typeof window === "undefined") {
      return;
    }
    const windowWithDevTools = window;
    const devtoolsSymbol = Symbol.for("apollo.devtools");
    (windowWithDevTools[devtoolsSymbol] = windowWithDevTools[devtoolsSymbol] || []).push(this);
    windowWithDevTools.__APOLLO_CLIENT__ = this;
    if (!hasSuggestedDevtools && __DEV__) {
      hasSuggestedDevtools = true;
      if (window.document && window.top === window.self && /^(https?|file):$/.test(window.location.protocol)) {
        setTimeout(() => {
          if (!window.__APOLLO_DEVTOOLS_GLOBAL_HOOK__) {
            const nav = window.navigator;
            const ua = nav && nav.userAgent;
            let url;
            if (typeof ua === "string") {
              if (ua.indexOf("Chrome/") > -1) {
                url = "https://chrome.google.com/webstore/detail/apollo-client-developer-t/jdkknkkbebbapilgoeccciglkfbmbnfm";
              } else if (ua.indexOf("Firefox/") > -1) {
                url = "https://addons.mozilla.org/en-US/firefox/addon/apollo-developer-tools/";
              }
            }
            if (url) {
              __DEV__ && invariant2.log("Download the Apollo DevTools for a better development experience: %s", url);
            }
          }
        }, 1e4);
      }
    }
  }
  /**
   * The `DocumentTransform` used to modify GraphQL documents before a request
   * is made. If a custom `DocumentTransform` is not provided, this will be the
   * default document transform.
   */
  get documentTransform() {
    return this.queryManager.documentTransform;
  }
  /**
   * The configured `LocalState` instance used to enable the use of `@client`
   * fields.
   */
  get localState() {
    return this.queryManager.localState;
  }
  set localState(localState) {
    this.queryManager.localState = localState;
  }
  /**
   * Call this method to terminate any active client processes, making it safe
   * to dispose of this `ApolloClient` instance.
   *
   * This method performs aggressive cleanup to prevent memory leaks:
   *
   * - Unsubscribes all active `ObservableQuery` instances by emitting a `completed` event
   * - Rejects all currently running queries with "QueryManager stopped while query was in flight"
   * - Removes all queryRefs from the suspense cache
   */
  stop() {
    this.queryManager.stop();
  }
  /**
   * This watches the cache store of the query according to the options specified and
   * returns an `ObservableQuery`. We can subscribe to this `ObservableQuery` and
   * receive updated results through an observer when the cache store changes.
   *
   * Note that this method is not an implementation of GraphQL subscriptions. Rather,
   * it uses Apollo's store in order to reactively deliver updates to your query results.
   *
   * For example, suppose you call watchQuery on a GraphQL query that fetches a person's
   * first and last name and this person has a particular object identifier, provided by
   * `cache.identify`. Later, a different query fetches that same person's
   * first and last name and the first name has now changed. Then, any observers associated
   * with the results of the first query will be updated with a new result object.
   *
   * Note that if the cache does not change, the subscriber will _not_ be notified.
   *
   * See [here](https://medium.com/apollo-stack/the-concepts-of-graphql-bc68bd819be3#.3mb0cbcmc) for
   * a description of store reactivity.
   */
  watchQuery(options) {
    if (this.defaultOptions.watchQuery) {
      options = mergeOptions(this.defaultOptions.watchQuery, options);
    }
    return this.queryManager.watchQuery(options);
  }
  /**
   * This resolves a single query according to the options specified and
   * returns a `Promise` which is either resolved with the resulting data
   * or rejected with an error.
   *
   * @param options - An object of type `QueryOptions` that allows us to
   * describe how this query should be treated e.g. whether it should hit the
   * server at all or just resolve from the cache, etc.
   */
  query(options) {
    if (this.defaultOptions.query) {
      options = mergeOptions(this.defaultOptions.query, options);
    }
    if (__DEV__) {
      invariant2(options.fetchPolicy !== "cache-and-network", 67);
      invariant2(options.fetchPolicy !== "standby", 68);
      invariant2(options.query, 69);
      invariant2(options.query.kind === "Document", 70);
      invariant2(!options.returnPartialData, 71);
      invariant2(!options.pollInterval, 72);
      invariant2(!options.notifyOnNetworkStatusChange, 73);
    }
    return this.queryManager.query(options);
  }
  /**
   * This resolves a single mutation according to the options specified and returns a
   * Promise which is either resolved with the resulting data or rejected with an
   * error. In some cases both `data` and `errors` might be undefined, for example
   * when `errorPolicy` is set to `'ignore'`.
   *
   * It takes options as an object with the following keys and values:
   */
  mutate(options) {
    const optionsWithDefaults = mergeOptions(compact({
      fetchPolicy: "network-only",
      errorPolicy: "none"
    }, this.defaultOptions.mutate), options);
    if (__DEV__) {
      invariant2(optionsWithDefaults.mutation, 74);
      invariant2(optionsWithDefaults.fetchPolicy === "network-only" || optionsWithDefaults.fetchPolicy === "no-cache", 75);
    }
    checkDocument(optionsWithDefaults.mutation, OperationTypeNode.MUTATION);
    return this.queryManager.mutate(optionsWithDefaults);
  }
  /**
   * This subscribes to a graphql subscription according to the options specified and returns an
   * `Observable` which either emits received data or an error.
   */
  subscribe(options) {
    const cause = {};
    const observable = this.queryManager.startGraphQLSubscription(options);
    const mapped = observable.pipe((0, import_rxjs8.map)((result) => ({
      ...result,
      data: this.queryManager.maskOperation({
        document: options.query,
        data: result.data,
        fetchPolicy: options.fetchPolicy,
        cause
      })
    })));
    return Object.assign(mapped, { restart: observable.restart });
  }
  readQuery(options, optimistic = false) {
    return this.cache.readQuery({ ...options, query: this.transform(options.query) }, optimistic);
  }
  /**
   * Watches the cache store of the fragment according to the options specified
   * and returns an `Observable`. We can subscribe to this
   * `Observable` and receive updated results through an
   * observer when the cache store changes.
   *
   * You must pass in a GraphQL document with a single fragment or a document
   * with multiple fragments that represent what you are reading. If you pass
   * in a document with multiple fragments then you must also specify a
   * `fragmentName`.
   *
   * @since 3.10.0
   * @param options - An object of type `WatchFragmentOptions` that allows
   * the cache to identify the fragment and optionally specify whether to react
   * to optimistic updates.
   */
  watchFragment(options) {
    const dataMasking = this.queryManager.dataMasking;
    return this.cache.watchFragment({
      ...options,
      fragment: this.transform(options.fragment, dataMasking)
    }).pipe((0, import_rxjs8.map)((result) => {
      if (__DEV__) {
        if (dataMasking) {
          const data = this.queryManager.maskFragment({
            ...options,
            data: result.data
          });
          return { ...result, data };
        }
      }
      return result;
    }));
  }
  readFragment(options, optimistic = false) {
    return this.cache.readFragment({ ...options, fragment: this.transform(options.fragment) }, optimistic);
  }
  /**
   * Writes some data in the shape of the provided GraphQL query directly to
   * the store. This method will start at the root query. To start at a
   * specific id returned by `cache.identify` then use `writeFragment`.
   */
  writeQuery(options) {
    const ref = this.cache.writeQuery(options);
    if (options.broadcast !== false) {
      this.queryManager.broadcastQueries();
    }
    return ref;
  }
  /**
   * Writes some data in the shape of the provided GraphQL fragment directly to
   * the store. This method will write to a GraphQL fragment from any arbitrary
   * id that is currently cached, unlike `writeQuery` which will only write
   * from the root query.
   *
   * You must pass in a GraphQL document with a single fragment or a document
   * with multiple fragments that represent what you are writing. If you pass
   * in a document with multiple fragments then you must also specify a
   * `fragmentName`.
   */
  writeFragment(options) {
    const ref = this.cache.writeFragment(options);
    if (options.broadcast !== false) {
      this.queryManager.broadcastQueries();
    }
    return ref;
  }
  __actionHookForDevTools(cb) {
    this.devToolsHookCb = cb;
  }
  __requestRaw(request) {
    return execute(this.link, request, { client: this });
  }
  /**
   * Resets your entire store by clearing out your cache and then re-executing
   * all of your active queries. This makes it so that you may guarantee that
   * there is no data left in your store from a time before you called this
   * method.
   *
   * `resetStore()` is useful when your user just logged out. Youve removed the
   * user session, and you now want to make sure that any references to data you
   * might have fetched while the user session was active is gone.
   *
   * It is important to remember that `resetStore()` _will_ refetch any active
   * queries. This means that any components that might be mounted will execute
   * their queries again using your network interface. If you do not want to
   * re-execute any queries then you should make sure to stop watching any
   * active queries.
   */
  resetStore() {
    return Promise.resolve().then(() => this.queryManager.clearStore({
      discardWatches: false
    })).then(() => Promise.all(this.resetStoreCallbacks.map((fn) => fn()))).then(() => this.refetchObservableQueries());
  }
  /**
   * Remove all data from the store. Unlike `resetStore`, `clearStore` will
   * not refetch any active queries.
   */
  clearStore() {
    return Promise.resolve().then(() => this.queryManager.clearStore({
      discardWatches: true
    })).then(() => Promise.all(this.clearStoreCallbacks.map((fn) => fn())));
  }
  /**
   * Allows callbacks to be registered that are executed when the store is
   * reset. `onResetStore` returns an unsubscribe function that can be used
   * to remove registered callbacks.
   */
  onResetStore(cb) {
    this.resetStoreCallbacks.push(cb);
    return () => {
      this.resetStoreCallbacks = this.resetStoreCallbacks.filter((c) => c !== cb);
    };
  }
  /**
   * Allows callbacks to be registered that are executed when the store is
   * cleared. `onClearStore` returns an unsubscribe function that can be used
   * to remove registered callbacks.
   */
  onClearStore(cb) {
    this.clearStoreCallbacks.push(cb);
    return () => {
      this.clearStoreCallbacks = this.clearStoreCallbacks.filter((c) => c !== cb);
    };
  }
  /**
   * Refetches all of your active queries.
   *
   * `refetchObservableQueries()` is useful if you want to bring the client back to proper state in case of a network outage
   *
   * It is important to remember that `refetchObservableQueries()` _will_ refetch any active
   * queries. This means that any components that might be mounted will execute
   * their queries again using your network interface. If you do not want to
   * re-execute any queries then you should make sure to stop watching any
   * active queries.
   * Takes optional parameter `includeStandby` which will include queries in standby-mode when refetching.
   *
   * Note: `cache-only` queries are not refetched by this function.
   */
  refetchObservableQueries(includeStandby) {
    return this.queryManager.refetchObservableQueries(includeStandby);
  }
  /**
   * Refetches specified active queries. Similar to "refetchObservableQueries()" but with a specific list of queries.
   *
   * `refetchQueries()` is useful for use cases to imperatively refresh a selection of queries.
   *
   * It is important to remember that `refetchQueries()` _will_ refetch specified active
   * queries. This means that any components that might be mounted will execute
   * their queries again using your network interface. If you do not want to
   * re-execute any queries then you should make sure to stop watching any
   * active queries.
   */
  refetchQueries(options) {
    const map3 = this.queryManager.refetchQueries(options);
    const queries = [];
    const results = [];
    map3.forEach((result2, obsQuery) => {
      queries.push(obsQuery);
      results.push(result2);
    });
    const result = Promise.all(results);
    result.queries = queries;
    result.results = results;
    result.catch((error) => {
      __DEV__ && invariant2.debug(76, error);
    });
    return result;
  }
  /**
   * Get all currently active `ObservableQuery` objects, in a `Set`.
   *
   * An "active" query is one that has observers and a `fetchPolicy` other than
   * "standby" or "cache-only".
   *
   * You can include all `ObservableQuery` objects (including the inactive ones)
   * by passing "all" instead of "active", or you can include just a subset of
   * active queries by passing an array of query names or DocumentNode objects.
   *
   * Note: This method only returns queries that have active subscribers. Queries
   * without subscribers are not tracked by the client.
   */
  getObservableQueries(include = "active") {
    return this.queryManager.getObservableQueries(include);
  }
  /**
   * Exposes the cache's complete state, in a serializable format for later restoration.
   *
   * @remarks
   *
   * This can be useful for debugging in order to inspect the full state of the
   * cache.
   *
   * @param optimistic - Determines whether the result contains data from the
   * optimistic layer
   */
  extract(optimistic) {
    return this.cache.extract(optimistic);
  }
  /**
   * Replaces existing state in the cache (if any) with the values expressed by
   * `serializedState`.
   *
   * Called when hydrating a cache (server side rendering, or offline storage),
   * and also (potentially) during hot reloads.
   */
  restore(serializedState) {
    return this.cache.restore(serializedState);
  }
  /**
   * Define a new ApolloLink (or link chain) that Apollo Client will use.
   */
  setLink(newLink) {
    this.link = newLink;
  }
  get defaultContext() {
    return this.queryManager.defaultContext;
  }
  transform(document, dataMasking = false) {
    const transformed = this.queryManager.transform(document);
    return dataMasking ? this.maskedFragmentTransform.transformDocument(transformed) : transformed;
  }
};
if (__DEV__) {
  ApolloClient.prototype.getMemoryInternals = getApolloClientMemoryInternals;
}

// node_modules/@apollo/client/link/http/parseAndCheckHttpResponse.js
var { hasOwnProperty: hasOwnProperty6 } = Object.prototype;
function isApolloPayloadResult(value) {
  return isNonNullObject(value) && "payload" in value;
}
async function* consumeMultipartBody(response) {
  var _a2;
  const decoder = new TextDecoder("utf-8");
  const contentType = (_a2 = response.headers) == null ? void 0 : _a2.get("content-type");
  const match = contentType == null ? void 0 : contentType.match(
    /*
      ;\s*boundary=                # Match the boundary parameter
      (?:                          # either
        '([^']*)'                  # a string starting with ' doesn't contain ', ends with '
        |                          # or
        "([^"]*)"                  # a string starting with " doesn't contain ", ends with "
        |                          # or
        ([^"'].*?)                 # a string that doesn't start with ' or ", parsed non-greedily
        )                          # end of the group
      \s*                          # optional whitespace
      (?:;|$)                        # match a semicolon or end of string
    */
    /;\s*boundary=(?:'([^']+)'|"([^"]+)"|([^"'].+?))\s*(?:;|$)/i
  );
  const boundary = "\r\n--" + ((match == null ? void 0 : match.findLast((val) => !!val)) || "-");
  let buffer = "";
  invariant2(response.body && typeof response.body.getReader === "function", 60);
  const stream = response.body;
  const reader = stream.getReader();
  let done = false;
  let encounteredBoundary = false;
  let value;
  const passedFinalBoundary = () => encounteredBoundary && buffer[0] == "-" && buffer[1] == "-";
  try {
    while (!done) {
      ({ value, done } = await reader.read());
      const chunk = typeof value === "string" ? value : decoder.decode(value);
      const searchFrom = buffer.length - boundary.length + 1;
      buffer += chunk;
      let bi = buffer.indexOf(boundary, searchFrom);
      while (bi > -1 && !passedFinalBoundary()) {
        encounteredBoundary = true;
        let message;
        [message, buffer] = [
          buffer.slice(0, bi),
          buffer.slice(bi + boundary.length)
        ];
        const i = message.indexOf("\r\n\r\n");
        const headers = parseHeaders(message.slice(0, i));
        const contentType2 = headers["content-type"];
        if (contentType2 && contentType2.toLowerCase().indexOf("application/json") === -1) {
          throw new Error("Unsupported patch content type: application/json is required.");
        }
        const body = message.slice(i);
        if (body) {
          yield body;
        }
        bi = buffer.indexOf(boundary);
      }
      if (passedFinalBoundary()) {
        return;
      }
    }
    throw new Error("premature end of multipart body");
  } finally {
    reader.cancel();
  }
}
async function readMultipartBody(response, nextValue) {
  for await (const body of consumeMultipartBody(response)) {
    const result = parseJsonEncoding(response, body);
    if (Object.keys(result).length == 0)
      continue;
    if (isApolloPayloadResult(result)) {
      if (Object.keys(result).length === 1 && result.payload === null) {
        return;
      }
      let next = { ...result.payload };
      if ("errors" in result) {
        next.extensions = {
          ...next.extensions,
          [PROTOCOL_ERRORS_SYMBOL]: new CombinedProtocolErrors(result.errors ?? [])
        };
      }
      nextValue(next);
    } else {
      nextValue(result);
    }
  }
}
function parseHeaders(headerText) {
  const headersInit = {};
  headerText.split("\n").forEach((line) => {
    const i = line.indexOf(":");
    if (i > -1) {
      const name = line.slice(0, i).trim().toLowerCase();
      const value = line.slice(i + 1).trim();
      headersInit[name] = value;
    }
  });
  return headersInit;
}
function parseJsonEncoding(response, bodyText) {
  if (response.status >= 300) {
    throw new ServerError(`Response not successful: Received status code ${response.status}`, { response, bodyText });
  }
  try {
    return JSON.parse(bodyText);
  } catch (err) {
    throw new ServerParseError(err, { response, bodyText });
  }
}
function parseGraphQLResponseJsonEncoding(response, bodyText) {
  try {
    return JSON.parse(bodyText);
  } catch (err) {
    throw new ServerParseError(err, { response, bodyText });
  }
}
function parseResponse(response, bodyText) {
  const contentType = response.headers.get("content-type");
  if (contentType == null ? void 0 : contentType.includes("application/graphql-response+json")) {
    return parseGraphQLResponseJsonEncoding(response, bodyText);
  }
  return parseJsonEncoding(response, bodyText);
}
function parseAndCheckHttpResponse(operations) {
  return (response) => response.text().then((bodyText) => {
    const result = parseResponse(response, bodyText);
    if (!Array.isArray(result) && !hasOwnProperty6.call(result, "data") && !hasOwnProperty6.call(result, "errors")) {
      throw new ServerError(`Server response was malformed for query '${Array.isArray(operations) ? operations.map((op) => op.operationName) : operations.operationName}'.`, { response, bodyText });
    }
    return result;
  });
}

// node_modules/@apollo/client/link/http/selectHttpOptionsAndBody.js
var defaultHttpOptions = {
  includeQuery: true,
  includeExtensions: true,
  preserveHeaderCase: false
};
var defaultHeaders = {
  // headers are case insensitive (https://stackoverflow.com/a/5259004)
  accept: "application/graphql-response+json,application/json;q=0.9",
  // The content-type header describes the type of the body of the request, and
  // so it typically only is sent with requests that actually have bodies. One
  // could imagine that Apollo Client would remove this header when constructing
  // a GET request (which has no body), but we historically have not done that.
  // This means that browsers will preflight all Apollo Client requests (even
  // GET requests). Apollo Server's CSRF prevention feature (introduced in
  // AS3.7) takes advantage of this fact and does not block requests with this
  // header. If you want to drop this header from GET requests, then you should
  // probably replace it with a `apollo-require-preflight` header, or servers
  // with CSRF prevention enabled might block your GET request. See
  // https://www.apollographql.com/docs/apollo-server/security/cors/#preventing-cross-site-request-forgery-csrf
  // for more details.
  "content-type": "application/json"
};
var defaultOptions = {
  method: "POST"
};
var fallbackHttpConfig = {
  http: defaultHttpOptions,
  headers: defaultHeaders,
  options: defaultOptions
};
var defaultPrinter = (ast, printer) => printer(ast);
function selectHttpOptionsAndBody(operation, fallbackConfig, ...configs) {
  configs.unshift(fallbackConfig);
  return selectHttpOptionsAndBodyInternal(operation, defaultPrinter, ...configs);
}
function selectHttpOptionsAndBodyInternal(operation, printer, ...configs) {
  let options = {};
  let http = {};
  configs.forEach((config) => {
    var _a2;
    options = {
      ...options,
      ...config.options,
      headers: {
        ...options.headers,
        ...config.headers
      }
    };
    if (config.credentials) {
      options.credentials = config.credentials;
    }
    options.headers.accept = (((_a2 = config.http) == null ? void 0 : _a2.accept) || []).concat(options.headers.accept).join(",");
    http = {
      ...http,
      ...config.http
    };
  });
  options.headers = removeDuplicateHeaders(options.headers, http.preserveHeaderCase);
  const { operationName, extensions, variables, query } = operation;
  const body = { operationName, variables };
  if (http.includeExtensions && Object.keys(extensions || {}).length)
    body.extensions = extensions;
  if (http.includeQuery)
    body.query = printer(query, print2);
  return {
    options,
    body
  };
}
function removeDuplicateHeaders(headers, preserveHeaderCase) {
  if (!preserveHeaderCase) {
    const normalizedHeaders2 = {};
    Object.keys(Object(headers)).forEach((name) => {
      normalizedHeaders2[name.toLowerCase()] = headers[name];
    });
    return normalizedHeaders2;
  }
  const headerData = {};
  Object.keys(Object(headers)).forEach((name) => {
    headerData[name.toLowerCase()] = {
      originalName: name,
      value: headers[name]
    };
  });
  const normalizedHeaders = {};
  Object.keys(headerData).forEach((name) => {
    normalizedHeaders[headerData[name].originalName] = headerData[name].value;
  });
  return normalizedHeaders;
}

// node_modules/@apollo/client/link/http/checkFetcher.js
var checkFetcher = (fetcher) => {
  invariant2(fetcher || typeof fetch !== "undefined", 59);
};

// node_modules/@apollo/client/link/http/createSignalIfSupported.js
var createSignalIfSupported = () => {
  if (typeof AbortController === "undefined")
    return { controller: false, signal: false };
  const controller = new AbortController();
  const signal = controller.signal;
  return { controller, signal };
};

// node_modules/@apollo/client/link/http/selectURI.js
var selectURI = (operation, fallbackURI) => {
  const context = operation.getContext();
  const contextURI = context.uri;
  if (contextURI) {
    return contextURI;
  } else if (typeof fallbackURI === "function") {
    return fallbackURI(operation);
  } else {
    return fallbackURI || "/graphql";
  }
};

// node_modules/@apollo/client/link/http/BaseHttpLink.js
var import_rxjs9 = __toESM(require_cjs(), 1);

// node_modules/@apollo/client/link/http/rewriteURIForGET.js
function rewriteURIForGET(chosenURI, body) {
  const queryParams = [];
  const addQueryParam = (key, value) => {
    queryParams.push(`${key}=${encodeURIComponent(value)}`);
  };
  if ("query" in body) {
    addQueryParam("query", body.query);
  }
  if (body.operationName) {
    addQueryParam("operationName", body.operationName);
  }
  if (body.variables) {
    let serializedVariables;
    try {
      serializedVariables = JSON.stringify(body.variables);
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("variables", serializedVariables);
  }
  if (body.extensions) {
    let serializedExtensions;
    try {
      serializedExtensions = JSON.stringify(body.extensions);
    } catch (parseError) {
      return { parseError };
    }
    addQueryParam("extensions", serializedExtensions);
  }
  let fragment = "", preFragment = chosenURI;
  const fragmentStart = chosenURI.indexOf("#");
  if (fragmentStart !== -1) {
    fragment = chosenURI.substr(fragmentStart);
    preFragment = chosenURI.substr(0, fragmentStart);
  }
  const queryParamsPrefix = preFragment.indexOf("?") === -1 ? "?" : "&";
  const newURI = preFragment + queryParamsPrefix + queryParams.join("&") + fragment;
  return { newURI };
}

// node_modules/@apollo/client/link/http/BaseHttpLink.js
var backupFetch = maybe(() => fetch);
function noop2() {
}
var BaseHttpLink = class extends ApolloLink {
  constructor(options = {}) {
    let {
      uri = "/graphql",
      // use default global fetch if nothing passed in
      fetch: preferredFetch,
      print: print3 = defaultPrinter,
      includeExtensions,
      preserveHeaderCase,
      useGETForQueries,
      includeUnusedVariables = false,
      ...requestOptions
    } = options;
    if (__DEV__) {
      checkFetcher(preferredFetch || backupFetch);
    }
    const linkConfig = {
      http: compact({ includeExtensions, preserveHeaderCase }),
      options: requestOptions.fetchOptions,
      credentials: requestOptions.credentials,
      headers: requestOptions.headers
    };
    super((operation) => {
      let chosenURI = selectURI(operation, uri);
      const context = operation.getContext();
      const http = { ...context.http };
      if (isSubscriptionOperation(operation.query)) {
        http.accept = [
          "multipart/mixed;boundary=graphql;subscriptionSpec=1.0",
          ...http.accept || []
        ];
      }
      const contextConfig = {
        http,
        options: context.fetchOptions,
        credentials: context.credentials,
        headers: context.headers
      };
      const { options: options2, body } = selectHttpOptionsAndBodyInternal(operation, print3, fallbackHttpConfig, linkConfig, contextConfig);
      if (body.variables && !includeUnusedVariables) {
        body.variables = filterOperationVariables(body.variables, operation.query);
      }
      let controller = new AbortController();
      let cleanupController = () => {
        controller = void 0;
      };
      if (options2.signal) {
        const externalSignal = options2.signal;
        const listener = () => {
          controller == null ? void 0 : controller.abort(externalSignal.reason);
        };
        externalSignal.addEventListener("abort", listener, { once: true });
        cleanupController = () => {
          controller == null ? void 0 : controller.signal.removeEventListener("abort", cleanupController);
          controller = void 0;
          externalSignal.removeEventListener("abort", listener);
          cleanupController = noop2;
        };
        controller.signal.addEventListener("abort", cleanupController, {
          once: true
        });
      }
      options2.signal = controller.signal;
      if (useGETForQueries && !isMutationOperation(operation.query)) {
        options2.method = "GET";
      }
      return new import_rxjs9.Observable((observer) => {
        if (options2.method === "GET") {
          const { newURI, parseError } = rewriteURIForGET(chosenURI, body);
          if (parseError) {
            throw parseError;
          }
          chosenURI = newURI;
        } else {
          options2.body = JSON.stringify(body);
        }
        const currentFetch = preferredFetch || maybe(() => fetch) || backupFetch;
        const observerNext = observer.next.bind(observer);
        currentFetch(chosenURI, options2).then((response) => {
          var _a2;
          operation.setContext({ response });
          const ctype = (_a2 = response.headers) == null ? void 0 : _a2.get("content-type");
          if (ctype !== null && /^multipart\/mixed/i.test(ctype)) {
            return readMultipartBody(response, observerNext);
          } else {
            return parseAndCheckHttpResponse(operation)(response).then(observerNext);
          }
        }).then(() => {
          cleanupController();
          observer.complete();
        }).catch((err) => {
          cleanupController();
          observer.error(err);
        });
        return () => {
          if (controller)
            controller.abort();
        };
      });
    });
  }
};

// node_modules/@apollo/client/link/client-awareness/ClientAwarenessLink.js
var ClientAwarenessLink = class extends ApolloLink {
  constructor(options = {}) {
    super((operation, forward) => {
      const client = operation.client;
      const clientOptions = client["queryManager"].clientOptions;
      const context = operation.getContext();
      {
        const { name, version: version2, transport = "headers" } = compact({}, clientOptions.clientAwareness, options.clientAwareness, context.clientAwareness);
        if (transport === "headers") {
          operation.setContext(({ headers, extensions }) => {
            return {
              headers: compact(
                // setting these first so that they can be overridden by user-provided headers
                {
                  "apollographql-client-name": name,
                  "apollographql-client-version": version2
                },
                headers
              )
            };
          });
        }
      }
      {
        const { transport = "extensions" } = compact({}, clientOptions.enhancedClientAwareness, options.enhancedClientAwareness);
        if (transport === "extensions") {
          operation.extensions = compact(
            // setting these first so that it can be overridden by user-provided extensions
            {
              clientLibrary: {
                name: "@apollo/client",
                version: client.version
              }
            },
            operation.extensions
          );
        }
      }
      return forward(operation);
    });
  }
};

// node_modules/@apollo/client/link/http/HttpLink.js
var HttpLink = class extends ApolloLink {
  constructor(options = {}) {
    const { left, right, request } = ApolloLink.from([
      new ClientAwarenessLink(options),
      new BaseHttpLink(options)
    ]);
    super(request);
    Object.assign(this, { left, right });
  }
};
var createHttpLink = (options = {}) => new HttpLink(options);

export {
  maybe,
  version,
  build,
  __DEV__,
  setVerbosity,
  invariant2 as invariant,
  canUseDOM,
  Trie,
  createFulfilledPromise,
  createRejectedPromise,
  decoratePromise,
  canonicalStringify,
  maybeDeepFreeze,
  mergeOptions,
  preventUnhandledRejection,
  equal,
  ApolloLink,
  empty,
  from,
  split,
  concat,
  execute,
  DocumentTransform,
  isReference,
  isNetworkRequestSettled,
  import_rxjs3 as import_rxjs,
  ApolloCache,
  MissingFieldError,
  defaultDataIdFromObject,
  makeVar,
  InMemoryCache,
  CombinedProtocolErrors,
  UnconventionalError,
  CombinedGraphQLErrors,
  LinkError,
  LocalStateError,
  ServerError,
  ServerParseError,
  NetworkStatus,
  ObservableQuery,
  ApolloClient,
  parseAndCheckHttpResponse,
  fallbackHttpConfig,
  defaultPrinter,
  selectHttpOptionsAndBody,
  selectHttpOptionsAndBodyInternal,
  checkFetcher,
  createSignalIfSupported,
  selectURI,
  rewriteURIForGET,
  HttpLink,
  createHttpLink
};
//# sourceMappingURL=chunk-7FVMHOEX.js.map
